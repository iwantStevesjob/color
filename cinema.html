<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crash-Proof P2P Streamer</title>
    <style>
        body { background: #0a0a0a; color: #e0e0e0; font-family: monospace; text-align: center; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; background: #111; padding: 20px; border-radius: 8px; border: 1px solid #333; }
        .hidden { display: none !important; }

        video { width: 100%; aspect-ratio: 16/9; background: #000; border: 1px solid #333; }

        /* Progress Bar */
        .track { width: 100%; height: 20px; background: #222; border-radius: 10px; margin: 15px 0; overflow: hidden; border: 1px solid #444; }
        .fill { height: 100%; background: #007bff; width: 0%; transition: width 0.2s; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; text-shadow: 0 1px 2px black; }
        .fill.done { background: #28a745; }

        button { padding: 12px 20px; border-radius: 4px; cursor: pointer; border: none; font-weight: bold; margin: 5px; background: #333; color: white; border: 1px solid #444; }
        button.primary { background: #007bff; border-color: #0056b3; }
        button:hover { filter: brightness(1.2); }
        
        input[type="text"] { padding: 10px; border-radius: 4px; border: 1px solid #444; background: #222; color: white; text-align: center; }

        #logs { font-family: monospace; font-size: 11px; color: #666; text-align: left; height: 120px; overflow-y: auto; margin-top: 20px; border-top: 1px solid #222; padding-top: 10px; }
        .log-warn { color: #ffc107; }
        .log-err { color: #ff5555; }
        .log-ok { color: #28a745; }
    </style>
    <script type="module">
        import { joinRoom } from 'https://esm.run/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>
</head>
<body>

<div class="container">
    <h2>P2P <span style="color:#28a745">Crash-Proof</span> Streamer</h2>

    <!-- SETUP -->
    <div id="setup">
        <input type="text" id="room" value="movie-night" placeholder="Room Name">
        <br><br>
        <div style="border:1px dashed #444; padding:20px; margin-bottom:20px;">
            <strong>HOST:</strong> <input type="file" id="file-in">
            <br><br>
            <button class="primary" onclick="startHost()">Send File</button>
        </div>
        <button onclick="startViewer()">Receive File</button>
    </div>

    <!-- PLAYER -->
    <div id="player" class="hidden">
        <video id="vid" controls playsinline></video>
        
        <div class="track">
            <div id="bar" class="fill">0%</div>
        </div>
        
        <div style="display:flex; justify-content:space-between; font-size:12px; color:#aaa;">
            <span id="status">Waiting for host...</span>
            <span id="details">0 / 0 MB</span>
        </div>
        
        <button id="try-play-btn" onclick="buildAndPlay()" style="display:none; width:100%; margin-top:10px;">
            â–¶ Play Downloaded So Far
        </button>
    </div>

    <div id="logs"></div>
</div>

<script>
    // 16KB is safer for avoiding queue fullness than 64KB
    const CHUNK_SIZE = 16 * 1024; 
    let room, sendBin, onBin;
    let file;
    let chunks = [];
    let receivedBytes = 0;
    let fileMeta = { size: 0, type: 'video/mp4', name: '' };
    let isHost = false;
    let isTransferring = false;

    // --- HOST ---
    async function startHost() {
        const input = document.getElementById('file-in');
        if(!input.files.length) return alert("Select a file");
        file = input.files[0];
        isHost = true;
        
        showPlayer();
        log(`Host initialized. File: ${file.name}`);
        
        // Host local preview
        document.getElementById('vid').src = URL.createObjectURL(file);
        document.getElementById('status').innerText = "Hosting... Waiting for peers.";
        document.getElementById('bar').style.width = "100%";
        document.getElementById('bar').classList.add('done');
        document.getElementById('bar').innerText = "HOST";

        initP2P();
    }

    // --- VIEWER ---
    function startViewer() {
        isHost = false;
        showPlayer();
        initP2P();
    }

    function showPlayer() {
        document.getElementById('setup').classList.add('hidden');
        document.getElementById('player').classList.remove('hidden');
    }

    // --- P2P ---
    function initP2P() {
        if(!window.joinRoom) return alert("Library loading...");
        const roomName = document.getElementById('room').value;
        
        log(`Connecting to room: ${roomName}`);
        room = window.joinRoom({ appId: 'p2p-robust-v5' }, roomName);
        
        const [send, getPid, onRecv] = room.makeAction('binary');
        sendBin = send;
        onBin = onRecv;

        room.onPeerJoin(peerId => {
            log(`Peer joined: ${peerId.substr(0,4)}`, 'ok');
            if(isHost && !isTransferring) {
                startTransfer(peerId);
            }
        });

        onBin((data, peerId) => {
            if(!isHost) handleData(data);
        });
    }

    // --- VIEWER HANDLER ---
    function handleData(data) {
        // Metadata Check
        if(data.byteLength < 500) {
            try {
                const txt = new TextDecoder().decode(data);
                if(txt.includes('"type":"META"')) {
                    const meta = JSON.parse(txt);
                    fileMeta = meta;
                    chunks = [];
                    receivedBytes = 0;
                    log(`Metadata: ${meta.name} (${(meta.size/1024/1024).toFixed(2)} MB)`);
                    document.getElementById('try-play-btn').style.display = 'block';
                    return;
                }
            } catch(e) {}
        }

        // Chunk Handling
        chunks.push(data);
        receivedBytes += data.byteLength;

        // UI Update (throttle slightly to save CPU)
        if(chunks.length % 10 === 0 || receivedBytes >= fileMeta.size) {
            const pct = (receivedBytes / fileMeta.size) * 100;
            document.getElementById('bar').style.width = pct + '%';
            document.getElementById('bar').innerText = Math.floor(pct) + '%';
            document.getElementById('details').innerText = `${(receivedBytes/1024/1024).toFixed(1)} / ${(fileMeta.size/1024/1024).toFixed(1)} MB`;
        }

        if(receivedBytes >= fileMeta.size) {
            log("Download Complete.", 'ok');
            document.getElementById('status').innerText = "Complete.";
            document.getElementById('bar').classList.add('done');
            document.getElementById('try-play-btn').style.display = 'none';
            buildAndPlay(true);
        }
    }

    function buildAndPlay(auto = false) {
        if(chunks.length === 0) return;
        const vid = document.getElementById('vid');
        const currentTime = vid.currentTime;
        const wasPlaying = !vid.paused;

        log(`Building blob (${chunks.length} chunks)...`);
        const blob = new Blob(chunks, { type: fileMeta.fileType });
        vid.src = URL.createObjectURL(blob);
        
        if(auto) {
            vid.muted = false;
            vid.play().catch(() => {
                vid.muted = true; 
                vid.play();
                log("Auto-played muted (browser policy). Click volume to unmute.", 'warn');
            });
        } else {
            vid.currentTime = currentTime;
            if(wasPlaying) vid.play();
        }
    }

    // --- HOST TRANSFER LOGIC (THE FIX) ---
    async function startTransfer(peerId) {
        isTransferring = true;
        
        // 1. Send Metadata
        const meta = JSON.stringify({ type: 'META', fileType: file.type || 'video/mp4', size: file.size, name: file.name });
        trySend(new TextEncoder().encode(meta), peerId);

        // 2. Stream File with Backpressure Logic
        let offset = 0;
        const reader = new FileReader();

        reader.onload = async (e) => {
            const chunk = e.target.result;

            // RETRY LOOP: This prevents the "Queue Full" crash
            let sent = false;
            let retryCount = 0;
            
            while(!sent) {
                try {
                    sendBin(chunk, peerId);
                    sent = true;
                } catch (err) {
                    if (err.message && err.message.includes('queue is full')) {
                        retryCount++;
                        if(retryCount % 20 === 0) log("Network busy (backpressure)... slowing down.", 'warn');
                        // Wait 50ms before retrying
                        await new Promise(r => setTimeout(r, 50));
                    } else {
                        log("Critical Error: " + err.message, 'err');
                        isTransferring = false;
                        return; // Stop on fatal error
                    }
                }
            }

            // Chunk sent successfully
            offset += CHUNK_SIZE;
            
            // Progress UI
            if (offset % (CHUNK_SIZE * 50) === 0) {
                const pct = (offset / file.size) * 100;
                document.getElementById('status').innerText = `Sending: ${pct.toFixed(1)}%`;
            }

            if(offset < file.size) {
                // Adaptive Delay: If we had retries, wait longer to let network recover
                const delay = retryCount > 0 ? 20 : 5;
                setTimeout(readNext, delay);
            } else {
                log("File Sent Successfully.", 'ok');
                document.getElementById('status').innerText = "Transfer Complete";
                isTransferring = false;
            }
        };

        const readNext = () => {
            const slice = file.slice(offset, offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };

        // Start reading
        readNext();
    }

    // Helper wrapper for non-async sends (like metadata)
    async function trySend(data, peerId) {
        try { sendBin(data, peerId); } catch(e) { console.error("Meta send failed", e); }
    }

    function log(msg, type='') {
        const d = document.getElementById('logs');
        d.innerHTML = `<div class="log-${type}">> ${msg}</div>` + d.innerHTML;
        console.log(msg);
    }
</script>
</body>
</html>
