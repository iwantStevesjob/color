<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamLink P2P Stable</title>
    <style>
        :root { --bg: #0d1117; --panel: #161b22; --accent: #238636; --text: #e6edf3; }
        body { background: var(--bg); color: var(--text); font-family: sans-serif; margin: 0; padding: 20px; text-align: center; }
        
        .container { max-width: 800px; margin: 0 auto; display: grid; gap: 20px; }
        .panel { background: var(--panel); border: 1px solid #30363d; padding: 20px; border-radius: 8px; }
        
        /* Hidden host player needed for captureStream */
        #host-source { position: absolute; opacity: 0; pointer-events: none; width: 1px; height: 1px; }

        video { width: 100%; aspect-ratio: 16/9; background: #000; border-radius: 6px; border: 1px solid #30363d; }
        
        button { background: #21262d; border: 1px solid #30363d; color: var(--text); padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; }
        button:hover { background: #30363d; }
        button.primary { background: var(--accent); border-color: rgba(255,255,255,0.1); }
        
        .bar { height: 4px; background: #21262d; width: 100%; margin-top: 8px; border-radius: 2px; }
        .fill { height: 100%; background: #2f81f7; width: 0%; transition: width 0.2s; }
        
        #logs { text-align: left; height: 120px; overflow-y: auto; background: #000; border: 1px solid #30363d; padding: 10px; font-size: 11px; font-family: monospace; color: #7ee787; margin-top: 10px; }
        .hidden { display: none !important; }
    </style>
    
    <script type="module">
        import { joinRoom } from 'https://esm.sh/trystero@0.19.0/torrent';
        window.joinRoom = joinRoom;
    </script>
</head>
<body>

<div class="container">
    <h2>StreamLink <span style="color:#2f81f7">P2P</span></h2>

    <div id="setup-panel" class="panel">
        <input type="text" id="room-input" value="cinema-fix-v3" style="background:#0d1117; border:1px solid #30363d; color:white; padding:10px; border-radius:4px;">
        <br><br>
        <button onclick="startApp('viewer')">Join as Viewer</button>
        <button class="primary" onclick="document.getElementById('file-input').click()">Host File</button>
        <input type="file" id="file-input" accept="video/*" style="display:none" onchange="startApp('host')">
    </div>

    <div id="player-panel" class="panel hidden">
        <video id="host-source" playsinline muted></video> <!-- Source for capture -->
        <video id="main-display" controls playsinline autoplay></video> <!-- View for user -->
        
        <div class="bar"><div id="buffer-bar" class="fill"></div></div>
        <div style="display:flex; justify-content:space-between; font-size:12px; margin-top:5px; color:#8b949e;">
            <span id="role-badge">Waiting...</span>
            <span>Buffer: <span id="buffer-stat">0.0</span>s</span>
        </div>
    </div>
    
    <div id="logs"></div>
</div>

<script>
    // --- CONFIG ---
    // VP8 is the most compatible codec for Real-time MediaRecorder -> MSE pipeline
    const CODEC = 'video/webm; codecs="vp8"'; 
    const CHUNK_MS = 200; 

    let state = {
        room: null,
        peers: [],
        recorder: null,
        mediaSource: null,
        sourceBuffer: null,
        queue: [],
        header: null, // Critical: stores the first WebM chunk (Initialization Segment)
        busy: false
    };

    let sendData;

    function log(msg) {
        const box = document.getElementById('logs');
        box.innerHTML += `<div>${msg}</div>`;
        box.scrollTop = box.scrollHeight;
    }

    // --- APP START ---
    async function startApp(role) {
        document.getElementById('setup-panel').classList.add('hidden');
        document.getElementById('player-panel').classList.remove('hidden');
        document.getElementById('role-badge').innerText = role.toUpperCase();

        if (role === 'host') await initHost();
        
        initNetwork(role);
    }

    // --- HOST LOGIC ---
    async function initHost() {
        const file = document.getElementById('file-input').files[0];
        if (!file) return;

        const hostVid = document.getElementById('host-source');
        const viewVid = document.getElementById('main-display');
        
        hostVid.src = URL.createObjectURL(file);
        await new Promise(r => hostVid.onloadedmetadata = r); // Wait for dimensions

        // Capture stream (24fps to save CPU)
        const stream = (hostVid.captureStream || hostVid.mozCaptureStream).call(hostVid, 24);
        
        // Show local preview (muted)
        viewVid.srcObject = stream;
        viewVid.muted = true;

        // Init Recorder
        if (!MediaRecorder.isTypeSupported(CODEC)) return alert(`Browser needs ${CODEC}`);
        
        state.recorder = new MediaRecorder(stream, { 
            mimeType: CODEC,
            videoBitsPerSecond: 1500000 // 1.5 Mbps
        });

        state.recorder.ondataavailable = async (e) => {
            if (e.data.size > 0) {
                const chunk = await e.data.arrayBuffer();
                
                // First chunk is ALWAYS the header. Cache it.
                if (!state.header) {
                    state.header = chunk;
                    log(`[HOST] Captured Header (${chunk.byteLength}b)`);
                }

                if (state.peers.length > 0) sendData(chunk);
            }
        };

        state.recorder.start(CHUNK_MS);
        hostVid.play();
        log("[HOST] Transcoding started.");
    }

    // --- VIEWER LOGIC ---
    function initViewerMSE(onData) {
        const vid = document.getElementById('main-display');
        state.mediaSource = new MediaSource();
        vid.src = URL.createObjectURL(state.mediaSource);

        state.mediaSource.addEventListener('sourceopen', () => {
            log("[MSE] Source Open");
            try {
                // Important: mode='sequence' handles timestamp gaps if packets arrive late
                state.sourceBuffer = state.mediaSource.addSourceBuffer(CODEC);
                state.sourceBuffer.mode = 'sequence';
                state.sourceBuffer.addEventListener('updateend', processQueue);
                
                // Try processing immediately in case header is waiting in queue
                processQueue();
            } catch (e) {
                log(`[MSE Error] ${e.message}`);
            }
        });

        return (data) => {
            state.queue.push(new Uint8Array(data));
            if (state.sourceBuffer && !state.sourceBuffer.updating) processQueue();
        };
    }

    function processQueue() {
        // SAFETY CHECKS
        if (!state.sourceBuffer) return;
        if (state.sourceBuffer.updating) return;
        if (state.queue.length === 0) return;
        if (state.mediaSource.readyState !== 'open') return;

        const chunk = state.queue.shift();
        
        try {
            state.sourceBuffer.appendBuffer(chunk);
        } catch (e) {
            log(`[Buffer Error] ${e.name}`);
            // If InvalidStateError occurs, usually means MediaSource closed unexpectedly.
            // We could try to re-init, but usually fatal.
        }

        updateStats();
    }

    function updateStats() {
        const vid = document.getElementById('main-display');
        if (state.sourceBuffer && state.sourceBuffer.buffered.length) {
            const end = state.sourceBuffer.buffered.end(state.sourceBuffer.buffered.length - 1);
            const diff = end - vid.currentTime;
            
            document.getElementById('buffer-stat').innerText = diff.toFixed(1);
            
            // Visual Bar
            const pct = Math.min(100, (diff / 20) * 100);
            document.getElementById('buffer-bar').style.width = `${pct}%`;

            // Autoplay logic
            if (vid.paused && diff > 1) vid.play().catch(()=>{});
        }
    }

    // --- NETWORK ---
    function initNetwork(role) {
        const roomId = document.getElementById('room-input').value;
        log(`[P2P] Connecting to ${roomId}...`);
        
        state.room = window.joinRoom({ appId: 'p2p-cinema-fix-v4' }, roomId);
        const [send, get] = state.room.makeAction('stream');
        sendData = send;

        state.room.onPeerJoin(id => {
            log(`[P2P] Peer joined: ${id}`);
            state.peers.push(id);
            
            // HOST: Send cached header immediately to new peer
            if (role === 'host' && state.header) {
                log(`[HOST] Sending Header to ${id}`);
                sendData(state.header, id);
            }
        });

        if (role === 'viewer') {
            const handler = initViewerMSE();
            get(handler);
        }
    }
</script>
</body>
</html>
