<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Buffered P2P Cinema</title>
    <style>
        body { background: #000; color: #eee; font-family: sans-serif; text-align: center; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .panel { border: 1px solid #333; padding: 20px; border-radius: 8px; background: #111; margin-bottom: 20px; }
        .hidden { display: none !important; }
        
        video { width: 100%; aspect-ratio: 16/9; background: #000; border: 1px solid #333; }
        
        button { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 5px; }
        button:hover { background: #0056b3; }
        button.secondary { background: #444; }

        .progress-bar { width: 100%; height: 10px; background: #333; margin-top: 5px; border-radius: 5px; overflow: hidden; }
        .fill { height: 100%; background: #28a745; width: 0%; transition: width 0.2s; }
        
        #stats { font-family: monospace; font-size: 12px; color: #888; margin-top: 10px; }
    </style>
    
    <!-- Using Trystero Torrent Strategy -->
    <script type="module">
        import { joinRoom } from 'https://esm.run/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>
</head>
<body>

<div class="container">
    <h2>P2P <span style="color:#007bff">Buffered</span> Cinema</h2>

    <!-- SETUP -->
    <div id="setup-panel" class="panel">
        <input type="text" id="room-input" value="movie-night" style="padding:10px; border-radius:4px; border:none;">
        <br><br>
        
        <div id="host-controls">
            <p><strong>Host:</strong> Select a video file (.mp4 recommended)</p>
            <input type="file" id="file-input" accept="video/mp4,video/webm">
            <br><br>
            <button onclick="startHost()">Start Broadcast</button>
        </div>
        <hr style="border-color:#333; margin: 20px 0;">
        <div id="viewer-controls">
            <button class="secondary" onclick="startViewer()">Join as Viewer</button>
        </div>
    </div>

    <!-- PLAYER -->
    <div id="player-panel" class="panel hidden">
        <video id="video-player" controls playsinline></video>
        <div class="progress-bar"><div id="buffer-bar" class="fill"></div></div>
        
        <div id="stats">
            Status: <span id="status-text">Connecting...</span> | 
            Peers: <span id="peer-count">0</span> | 
            Downloaded: <span id="dl-size">0</span> MB
        </div>
    </div>
</div>

<script>
    const CHUNK_SIZE = 16 * 1024; // 16KB chunks (Safe for WebRTC)
    let room, sendChunk, getPeerId, onChunkReceived;
    let state = {
        role: 'viewer',
        peers: [],
        mediaSource: null,
        sourceBuffer: null,
        queue: [], // Chunks waiting to be appended to buffer
        totalBytes: 0,
        isBufferBusy: false,
        fileReader: null,
        file: null
    };

    // --- INITIALIZATION ---

    async function startHost() {
        const fileInput = document.getElementById('file-input');
        if (!fileInput.files.length) return alert("Please select a file!");
        
        state.file = fileInput.files[0];
        state.role = 'host';
        
        // Setup UI
        initUI();
        
        // Setup Video for Local Playback (Host watches directly)
        const vid = document.getElementById('video-player');
        vid.src = URL.createObjectURL(state.file);
        
        // Start Trystero
        initP2P();
    }

    function startViewer() {
        state.role = 'viewer';
        initUI();
        initMSE(); // Viewer needs MediaSource to buffer incoming data
        initP2P();
    }

    function initUI() {
        document.getElementById('setup-panel').classList.add('hidden');
        document.getElementById('player-panel').classList.remove('hidden');
    }

    // --- P2P SIGNALING (Trystero) ---

    function initP2P() {
        const roomName = document.getElementById('room-input').value;
        const appId = 'p2p-buffered-cinema-v1';
        
        document.getElementById('status-text').innerText = "Joining Swarm...";

        room = window.joinRoom({ appId }, roomName);
        
        // Create a binary channel for chunks
        const [sendBin, getPid, onBin] = room.makeAction('binary');
        sendChunk = sendBin;
        onChunkReceived = onBin;
        getPeerId = getPid;

        room.onPeerJoin(peerId => {
            state.peers.push(peerId);
            updateStats();
            
            if (state.role === 'host') {
                // New peer joined? Start sending them the file from 0!
                // NOTE: A real robust app would check where they are. 
                // Here we just stream the file linearly to everyone.
                streamFileToPeer(peerId);
            }
        });

        room.onPeerLeave(peerId => {
            state.peers = state.peers.filter(p => p !== peerId);
            updateStats();
        });

        // Handle Incoming Chunks (Viewer Logic)
        onChunkReceived((data, senderId) => {
            if (state.role === 'viewer') {
                handleIncomingChunk(data);
                
                // RECURSIVE RELAY (The "Bucket Brigade")
                // If I have other peers connected (that aren't the sender), forward data!
                // Note: Trystero is mesh, so usually the host sends to everyone. 
                // But if Host -> A, and B joins A (but can't see Host), A forwards.
                // For simplicity in this demo, we just process playback.
            }
        });
    }

    // --- HOST LOGIC: READ & SEND FILE ---

    function streamFileToPeer(peerId) {
        if (!state.file) return;

        // We create a dedicated reader for this peer to send file start-to-finish
        // This is simplified. In production, you'd sync playback position.
        let offset = 0;
        const reader = new FileReader();

        reader.onload = (e) => {
            if (state.peers.indexOf(peerId) === -1) return; // Peer left

            const chunk = e.target.result; // ArrayBuffer
            
            // 1. Send Chunk
            sendChunk(chunk, peerId);
            
            // 2. Read Next
            offset += CHUNK_SIZE;
            if (offset < state.file.size) {
                // Small delay to prevent flooding the data channel buffer
                // Trystero/WebRTC handles backpressure internally but this helps UI
                setTimeout(() => {
                    readNext();
                }, 5); 
            } else {
                console.log("Finished sending file to", peerId);
            }
        };

        const readNext = () => {
            const slice = state.file.slice(offset, offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };

        readNext();
    }

    // --- VIEWER LOGIC: MEDIA SOURCE EXTENSIONS (MSE) ---
function initMSE() {
    const vid = document.getElementById('video-player');
    state.mediaSource = new MediaSource();
    vid.src = URL.createObjectURL(state.mediaSource);

    state.mediaSource.addEventListener('sourceopen', () => {
        // Standard H.264 MP4 mime type
        const mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'; 
        
        try {
            state.sourceBuffer = state.mediaSource.addSourceBuffer(mime);
            
            // FIX: Set mode to 'sequence' to handle raw file slices
            state.sourceBuffer.mode = 'sequence'; 

            state.sourceBuffer.addEventListener('updateend', processQueue);
            document.getElementById('status-text').innerText = "Ready to Buffer";
        } catch (e) {
            console.error(e);
            alert("Codec Error: Try using a standard H.264 MP4 file.");
        }
    });
}
    function handleIncomingChunk(data) {
    if (!data) return;

    // FIX: Explicitly cast to Uint8Array. 
    // This handles cases where Trystero returns a plain JS Array or an ArrayBuffer.
    const chunk = new Uint8Array(data);

    state.totalBytes += chunk.byteLength;
    document.getElementById('dl-size').innerText = (state.totalBytes / 1024 / 1024).toFixed(1);

    state.queue.push(chunk);
    processQueue();
}

    function processQueue() {
        if (state.sourceBuffer && !state.sourceBuffer.updating && state.queue.length > 0) {
            const chunk = state.queue.shift();
            try {
                state.sourceBuffer.appendBuffer(chunk);
            } catch (e) {
                console.error("MSE Error:", e);
            }
        }
    }

    // --- UTILS ---

    function updateStats() {
        document.getElementById('peer-count').innerText = state.peers.length;
        if (state.peers.length > 0 && state.role === 'host') {
            document.getElementById('status-text').innerText = "Streaming to Peers";
        }
    }
</script>
</body>
</html>
