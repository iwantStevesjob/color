<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>P2P ACK Streamer (Stable)</title>
    <style>
        body { background: #050505; color: #ddd; font-family: monospace; text-align: center; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; background: #111; padding: 20px; border-radius: 8px; border: 1px solid #333; }
        .hidden { display: none !important; }

        video { width: 100%; aspect-ratio: 16/9; background: #000; border: 1px solid #333; }

        .track { width: 100%; height: 20px; background: #222; border-radius: 10px; margin: 15px 0; overflow: hidden; border: 1px solid #444; }
        .fill { height: 100%; background: #007bff; width: 0%; transition: width 0.2s; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; }
        .fill.done { background: #28a745; }

        button { padding: 12px 20px; border-radius: 4px; cursor: pointer; border: none; font-weight: bold; margin: 5px; background: #333; color: white; border: 1px solid #444; }
        button.primary { background: #0d6efd; border-color: #0d6efd; }
        button:hover { filter: brightness(1.2); }
        
        input[type="text"] { padding: 10px; border-radius: 4px; border: 1px solid #444; background: #222; color: white; text-align: center; }
        
        #logs { font-family: monospace; font-size: 11px; color: #666; text-align: left; height: 100px; overflow-y: auto; margin-top: 20px; border-top: 1px solid #222; padding-top: 10px; }
    </style>
    <script type="module">
        import { joinRoom } from 'https://esm.run/trystero/torrent';
        window.joinRoom = joinRoom;
    </script>
</head>
<body>

<div class="container">
    <h2>P2P <span style="color:#007bff">Flow Control</span> Streamer</h2>

    <!-- SETUP -->
    <div id="setup">
        <input type="text" id="room" value="cinema-ack" placeholder="Room Name">
        <br><br>
        <div style="border:1px dashed #444; padding:20px; margin-bottom:20px;">
            <strong>HOST:</strong> <input type="file" id="file-in">
            <br><br>
            <button class="primary" onclick="startHost()">Send File</button>
        </div>
        <button onclick="startViewer()">Receive File</button>
    </div>

    <!-- PLAYER -->
    <div id="player" class="hidden">
        <video id="vid" controls playsinline></video>
        
        <div class="track">
            <div id="bar" class="fill">0%</div>
        </div>
        
        <div style="display:flex; justify-content:space-between; font-size:12px; color:#aaa;">
            <span id="status">Waiting...</span>
            <span id="details">0 / 0 MB</span>
        </div>
        
        <button id="play-btn" onclick="buildAndPlay()" style="display:none; width:100%; margin-top:10px;">
            ▶ Play Downloaded
        </button>
    </div>

    <div id="logs"></div>
</div>

<script>
    // CONFIG
    const CHUNK_SIZE = 16 * 1024; // 16KB chunks
    const BATCH_SIZE = 4;         // Send 4 chunks, then wait for ACK
                                  // Lower = More stable, Higher = Faster but riskier
    
    // STATE
    let room, sendBin, onBin; // Trystero handles
    let file;
    let chunks = [];
    let receivedBytes = 0;
    let fileMeta = { size: 0, type: 'video/mp4', name: '' };
    let isHost = false;
    
    // Flow Control State
    let ackResolvers = {}; // Map of peerId -> resolve function

    // --- HOST ---
    async function startHost() {
        const input = document.getElementById('file-in');
        if(!input.files.length) return alert("Select file");
        file = input.files[0];
        isHost = true;
        
        showPlayer();
        log(`Host initialized. File: ${file.name}`);
        
        // Host preview
        document.getElementById('vid').src = URL.createObjectURL(file);
        document.getElementById('status').innerText = "Hosting... Waiting for peers.";
        document.getElementById('bar').style.width = "100%";
        document.getElementById('bar').classList.add('done');
        document.getElementById('bar').innerText = "HOST";

        initP2P();
    }

    // --- VIEWER ---
    function startViewer() {
        isHost = false;
        showPlayer();
        initP2P();
    }

    function showPlayer() {
        document.getElementById('setup').classList.add('hidden');
        document.getElementById('player').classList.remove('hidden');
    }

    // --- P2P ---
    function initP2P() {
        if(!window.joinRoom) return alert("Library loading...");
        const roomName = document.getElementById('room').value;
        
        log(`Connecting: ${roomName}`);
        room = window.joinRoom({ appId: 'p2p-ack-v1' }, roomName);
        
        const [send, getPid, onRecv] = room.makeAction('binary');
        sendBin = send;
        onBin = onRecv;

        room.onPeerJoin(peerId => {
            log(`Peer joined: ${peerId.substr(0,4)}`);
            if(isHost) {
                // Start sending loop
                transferFile(peerId);
            }
        });

        onBin((data, peerId) => {
            handleMessage(data, peerId);
        });
    }

    // --- MESSAGE ROUTER ---
    function handleMessage(data, peerId) {
        // 1. Check if ACK (Small text message)
        if(data.byteLength < 20) {
            try {
                const txt = new TextDecoder().decode(data);
                if(txt === 'ACK') {
                    // Resolve the waiting promise for this peer
                    if(ackResolvers[peerId]) {
                        ackResolvers[peerId](); 
                        ackResolvers[peerId] = null;
                    }
                    return;
                }
            } catch(e) {}
        }

        // 2. Check if Metadata (JSON)
        if(data.byteLength < 1000) {
            try {
                const txt = new TextDecoder().decode(data);
                if(txt.includes('"type":"META"')) {
                    const meta = JSON.parse(txt);
                    fileMeta = meta;
                    chunks = [];
                    receivedBytes = 0;
                    log(`Meta: ${meta.name} (${(meta.size/1024/1024).toFixed(1)} MB)`);
                    document.getElementById('play-btn').style.display = 'block';
                    return;
                }
            } catch(e) {}
        }

        // 3. Binary Data Chunk
        chunks.push(data);
        receivedBytes += data.byteLength;
        updateProgress();

        // FLOW CONTROL: Send ACK periodically
        // We act like a reliable receiver. 
        // Host sends BATCH_SIZE chunks. Host pauses. We receive. We send ACK. Host resumes.
        if(chunks.length % BATCH_SIZE === 0) {
            sendAck(peerId);
        }
        
        // Also send ACK on completion so Host knows we finished
        if(receivedBytes >= fileMeta.size) {
            sendAck(peerId);
            finishDownload();
        }
    }

    function sendAck(peerId) {
        sendBin(new TextEncoder().encode('ACK'), peerId);
    }

    // --- HOST TRANSFER LOGIC (With ACK Wait) ---
    async function transferFile(peerId) {
        // 1. Send Metadata
        const meta = JSON.stringify({ type: 'META', fileType: file.type || 'video/mp4', size: file.size, name: file.name });
        sendBin(new TextEncoder().encode(meta), peerId);

        let offset = 0;
        let chunkCount = 0;
        const reader = new FileReader();

        // We use a Promise-based loop instead of FileReader.onload recursion
        // to make the "await ACK" logic cleaner.
        
        const readChunk = (start, end) => {
            return new Promise((resolve) => {
                const slice = file.slice(start, end);
                const r = new FileReader();
                r.onload = (e) => resolve(e.target.result);
                r.readAsArrayBuffer(slice);
            });
        };

        log(`Starting transfer to ${peerId.substr(0,4)}...`);

        while(offset < file.size) {
            const chunk = await readChunk(offset, offset + CHUNK_SIZE);
            
            // Send Data
            try {
                sendBin(chunk, peerId);
            } catch(e) {
                log("Send Error: " + e);
                break;
            }

            offset += CHUNK_SIZE;
            chunkCount++;

            // Update UI
            if(chunkCount % 20 === 0) {
                const pct = (offset / file.size) * 100;
                document.getElementById('status').innerText = `Sending: ${pct.toFixed(1)}%`;
            }

            // FLOW CONTROL CHECK
            if(chunkCount % BATCH_SIZE === 0) {
                // Pause and wait for ACK from Viewer
                // This guarantees we never overflow the browser buffer
                await waitForAck(peerId);
            }
        }

        log("Transfer Complete!");
        document.getElementById('status').innerText = "Transfer Complete";
    }

    function waitForAck(peerId) {
        return new Promise((resolve) => {
            // Store the resolve function so handleMessage can call it
            ackResolvers[peerId] = resolve;
            
            // Safety timeout: If peer disconnects or ACK lost, resume anyway after 2s
            // to prevents Host from freezing forever.
            setTimeout(() => {
                if(ackResolvers[peerId]) {
                    // console.log("ACK Timeout - resuming anyway");
                    ackResolvers[peerId]();
                    ackResolvers[peerId] = null;
                }
            }, 2000);
        });
    }

    // --- VIEWER UI ---
    function updateProgress() {
        const pct = (receivedBytes / fileMeta.size) * 100;
        document.getElementById('bar').style.width = pct + '%';
        document.getElementById('bar').innerText = Math.floor(pct) + '%';
        document.getElementById('details').innerText = `${(receivedBytes/1024/1024).toFixed(1)} MB`;
    }

    function finishDownload() {
        log("Download Complete");
        document.getElementById('bar').classList.add('done');
        document.getElementById('status').innerText = "Ready to play";
        document.getElementById('play-btn').innerText = "▶ Play Full Video";
        buildAndPlay(true);
    }

    function buildAndPlay(auto = false) {
        if(chunks.length === 0) return;
        const vid = document.getElementById('vid');
        const currentTime = vid.currentTime;
        const wasPlaying = !vid.paused;

        const blob = new Blob(chunks, { type: fileMeta.fileType });
        vid.src = URL.createObjectURL(blob);
        
        if(auto) {
            vid.muted = false;
            vid.play().catch(e => {
                vid.muted = true; vid.play();
            });
        } else {
            vid.currentTime = currentTime;
            if(wasPlaying) vid.play();
        }
    }

    function log(msg) {
        const d = document.getElementById('logs');
        d.innerHTML = `<div>> ${msg}</div>` + d.innerHTML;
        console.log(msg);
    }
</script>
</body>
</html>
