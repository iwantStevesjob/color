<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Cinema | Real-time Transcoding</title>
    <style>
        :root { --bg: #000; --panel: #111; --accent: #00e5ff; --text: #eee; }
        body { background: var(--bg); color: var(--text); font-family: monospace; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        
        .container { width: 100%; max-width: 900px; display: grid; gap: 20px; }
        .panel { background: var(--panel); border: 1px solid #333; padding: 20px; border-radius: 8px; }
        
        video { width: 100%; aspect-ratio: 16/9; background: #000; border: 1px solid #333; }
        
        button { background: #222; border: 1px solid #444; color: #fff; padding: 10px 20px; cursor: pointer; border-radius: 4px; font-family: inherit; transition: 0.2s; }
        button:hover { border-color: var(--accent); color: var(--accent); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.primary { background: var(--accent); color: #000; border: none; font-weight: bold; }
        button.primary:hover { background: #00b8cc; color: #000; }

        input[type="text"] { background: #222; border: 1px solid #444; color: #fff; padding: 10px; width: 200px; text-align: center; }
        
        .hidden { display: none !important; }
        .stats { font-size: 12px; color: #888; margin-top: 10px; display: flex; justify-content: space-between; }
        .log-box { height: 100px; overflow-y: scroll; background: #050505; border: 1px solid #333; padding: 10px; font-size: 11px; color: #0f0; margin-top: 10px; white-space: pre-wrap; }

        .progress-track { height: 5px; background: #333; margin-top: 5px; position: relative; }
        .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.2s; }
    </style>

    <script type="module">
        import { joinRoom } from 'https://esm.sh/trystero@0.19.0/torrent';
        window.joinRoom = joinRoom;
    </script>
</head>
<body>

<div class="container">
    <div class="panel">
        <h2 style="margin: 0 0 15px 0;">P2P Cinema <span style="color:var(--accent)">Transcoder</span></h2>
        
        <!-- SETUP UI -->
        <div id="setup-ui">
            <input type="text" id="room-input" value="cinema-transcode" placeholder="Room ID">
            <br><br>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <div style="border:1px solid #333; padding: 15px; border-radius:4px;">
                    <h3>HOST</h3>
                    <input type="file" id="file-input" accept="video/*">
                    <br><br>
                    <button class="primary" onclick="startHost()">Broadcast File</button>
                </div>
                <div style="border:1px solid #333; padding: 15px; border-radius:4px;">
                    <h3>VIEWER</h3>
                    <p style="margin: 5px 0 22px 0; color:#666">Join room and wait</p>
                    <button onclick="startViewer()">Join Stream</button>
                </div>
            </div>
        </div>

        <!-- PLAYER UI -->
        <div id="player-ui" class="hidden">
            <video id="host-source" class="hidden" playsinline muted></video>
            <video id="main-display" controls playsinline autoplay></video>
            <div class="progress-track"><div id="buffer-bar" class="progress-fill"></div></div>
            
            <div class="stats">
                <span id="role-badge">ROLE: -</span>
                <span>Buffer: <span id="buffer-stat">0</span>s</span>
                <span>Peers: <span id="peer-count">0</span></span>
            </div>
        </div>
        
        <div id="logs" class="log-box"></div>
    </div>
</div>

<script>
    const CONFIG = {
        appId: 'p2p-cinema-transcode-v1',
        mimeType: 'video/webm; codecs="vp9"' 
    };

    let state = {
        room: null,
        peers: [],
        mediaSource: null,
        sourceBuffer: null,
        queue: [],
        isUpdating: false,
        recorder: null,
        isHost: false
    };

    let sendChunk;

    function log(msg) {
        const d = document.getElementById('logs');
        d.innerHTML += `> ${msg}\n`;
        d.scrollTop = d.scrollHeight;
        console.log(msg);
    }

    // --- BUTTON HANDLERS ---
    
    // This was missing in the previous version!
    function startViewer() {
        initP2P('viewer');
    }

    async function startHost() {
        const fileInput = document.getElementById('file-input');
        if (!fileInput.files.length) return alert("Select a file first");

        // Prepare Host Video
        const hostVid = document.getElementById('host-source');
        const fileURL = URL.createObjectURL(fileInput.files[0]);
        hostVid.src = fileURL;
        
        await new Promise(r => hostVid.onloadedmetadata = r);
        
        // Start P2P
        initP2P('host');

        // Setup Transcoding
        let stream;
        if (hostVid.captureStream) stream = hostVid.captureStream(30);
        else if (hostVid.mozCaptureStream) stream = hostVid.mozCaptureStream(30);
        else return alert("Browser does not support captureStream");

        // Setup Preview
        const displayVid = document.getElementById('main-display');
        displayVid.srcObject = stream;
        displayVid.muted = true; 

        // Setup Recorder
        let mime = CONFIG.mimeType;
        if (!MediaRecorder.isTypeSupported(mime)) {
            mime = 'video/webm; codecs="vp8"';
            if (!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm';
        }
        log(`Transcoding to: ${mime}`);

        state.recorder = new MediaRecorder(stream, { 
            mimeType: mime,
            videoBitsPerSecond: 2500000 
        });

        state.recorder.ondataavailable = async (e) => {
            if (e.data.size > 0) {
                const buffer = await e.data.arrayBuffer();
                if (state.peers.length > 0) {
                    sendChunk(buffer);
                }
            }
        };

        state.recorder.start(100); 
        hostVid.play();
        log("Broadcasting started!");
    }

    // --- P2P LOGIC ---

    function initP2P(role) {
        const roomId = document.getElementById('room-input').value;
        document.getElementById('setup-ui').classList.add('hidden');
        document.getElementById('player-ui').classList.remove('hidden');
        document.getElementById('role-badge').innerText = `ROLE: ${role.toUpperCase()}`;

        state.isHost = (role === 'host');
        
        log(`Joining room: ${roomId}...`);
        
        if (!window.joinRoom) return alert("Library loading... wait 1 sec");
        state.room = window.joinRoom({ appId: CONFIG.appId }, roomId);

        const [send, get] = state.room.makeAction('video-stream');
        sendChunk = send;

        state.room.onPeerJoin(id => {
            log(`Peer joined: ${id}`);
            state.peers.push(id);
            document.getElementById('peer-count').innerText = state.peers.length;
            
            if(state.isHost && state.recorder && state.recorder.state === 'recording') {
                state.recorder.requestData();
            }
        });

        state.room.onPeerLeave(id => {
            state.peers = state.peers.filter(p => p !== id);
            document.getElementById('peer-count').innerText = state.peers.length;
        });

        if (!state.isHost) {
            setupViewerMSE(get);
        }
    }

    // --- VIEWER MSE LOGIC ---

    function setupViewerMSE(getChunkAction) {
        const vid = document.getElementById('main-display');
        state.mediaSource = new MediaSource();
        vid.src = URL.createObjectURL(state.mediaSource);

        state.mediaSource.addEventListener('sourceopen', () => {
            log("MediaSource Ready. Waiting for data...");
            
            // Try to match the recorder's likely output
            const mime = 'video/webm; codecs="vp9, opus"'; 
            
            try {
                if (MediaSource.isTypeSupported(mime)) {
                    state.sourceBuffer = state.mediaSource.addSourceBuffer(mime);
                } else {
                    state.sourceBuffer = state.mediaSource.addSourceBuffer('video/webm; codecs="vp8, vorbis"');
                }
                
                state.sourceBuffer.mode = 'sequence';
                state.sourceBuffer.addEventListener('updateend', processQueue);

            } catch (e) {
                log(`MSE Error: ${e.message}`);
            }
        });

        getChunkAction((data, peerId) => {
            let chunk = data instanceof Uint8Array ? data : new Uint8Array(data);
            state.queue.push(chunk);
            if (state.sourceBuffer && !state.sourceBuffer.updating) processQueue();
        });
    }

    function processQueue() {
        if (!state.sourceBuffer || state.sourceBuffer.updating || state.queue.length === 0) return;

        const chunk = state.queue.shift();
        try {
            state.sourceBuffer.appendBuffer(chunk);
            updateStats();
        } catch (e) {
            // log(`Buffer append error`);
        }
    }

    function updateStats() {
        const vid = document.getElementById('main-display');
        if (state.sourceBuffer && state.sourceBuffer.buffered.length) {
            const end = state.sourceBuffer.buffered.end(state.sourceBuffer.buffered.length - 1);
            const current = vid.currentTime;
            const diff = end - current;

            document.getElementById('buffer-stat').innerText = diff.toFixed(1);
            
            if (vid.paused && diff > 1) {
                vid.play().catch(e => {});
            }

            const pct = Math.min(100, (diff / 30) * 100);
            document.getElementById('buffer-bar').style.width = `${pct}%`;
        }
    }

</script>
</body>
</html>
