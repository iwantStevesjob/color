<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sphere</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #333; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        // --- Shader Sources ---
        const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uNormalMatrix;
    uniform highp vec3 uLightPositionView; // ADDED highp

    varying highp vec3 vLighting;
    varying highp vec3 vNormalView;   
    varying highp vec3 vPositionView; 

    void main(void) {
        // ... (rest of vsSource is the same)
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vPositionView = vec3(uModelViewMatrix * aVertexPosition);
        vNormalView = normalize(vec3(uNormalMatrix * vec4(aVertexNormal, 0.0)));
        highp vec3 ambientLight = vec3(0.2, 0.2, 0.2); 
        highp vec3 diffuseLightColor = vec3(1.0, 1.0, 1.0);
        highp vec3 lightDirection = normalize(uLightPositionView - vPositionView);
        highp float diffuseIntensity = max(dot(vNormalView, lightDirection), 0.0);
        vLighting = ambientLight + (diffuseLightColor * diffuseIntensity);
    }
`;
const fsSource = `
    precision mediump float; // Default for most things in FS

    varying highp vec3 vLighting; 
    varying highp vec3 vNormalView;   
    varying highp vec3 vPositionView; 

    uniform vec4 uColor;
    uniform bool uUseLighting;
    uniform highp vec3 uLightPositionView; // ADDED highp

    // Halo Effect Uniforms
    uniform highp vec3 uHaloColor;        // Also good to be highp
    uniform highp float uHaloIntensity;   // Floats also inherit default or can be specified
    uniform highp float uHaloSharpness;   
    uniform highp float uBehindFactorPower; 

    void main(void) {
        // ... (rest of fsSource is the same)
        vec3 finalColor = vec3(0.0);
        if (uUseLighting) {
            finalColor = uColor.rgb * vLighting;
        } else {
            finalColor = uColor.rgb;
        }
        if (uUseLighting) { 
            vec3 viewDir = normalize(-vPositionView);
            float rimDot = abs(dot(viewDir, vNormalView)); 
            float rimFactor = pow(1.0 - rimDot, uHaloSharpness);
            vec3 lightDirFromFragment = normalize(uLightPositionView - vPositionView);
            float lightBehindFragmentScore = -dot(viewDir, lightDirFromFragment); 
            float behindFactor = pow(max(0.0, lightBehindFragmentScore), uBehindFactorPower);
            vec3 haloContribution = uHaloColor * rimFactor * behindFactor * uHaloIntensity;
            finalColor += haloContribution;
        }
        gl_FragColor = vec4(finalColor, uColor.a);
    }
`;

        // --- Minimal gl-matrix style functions (collapsed for brevity) ---
        const mat4 = { create:()=>new Float32Array(16),identity:out=>{out.fill(0);out[0]=out[5]=out[10]=out[15]=1;return out},translate:(out,a,v)=>{let x=v[0],y=v[1],z=v[2],a00,a01,a02,a03,a10,a11,a12,a13,a20,a21,a22,a23,a30,a31,a32,a33;if(a===out){out[12]=a[0]*x+a[4]*y+a[8]*z+a[12];out[13]=a[1]*x+a[5]*y+a[9]*z+a[13];out[14]=a[2]*x+a[6]*y+a[10]*z+a[14];out[15]=a[3]*x+a[7]*y+a[11]*z+a[15]}else{a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];a30=a[12];a31=a[13];a32=a[14];a33=a[15];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a03;out[4]=a10;out[5]=a11;out[6]=a12;out[7]=a13;out[8]=a20;out[9]=a21;out[10]=a22;out[11]=a23;out[12]=a00*x+a10*y+a20*z+a30;out[13]=a01*x+a11*y+a21*z+a31;out[14]=a02*x+a12*y+a22*z+a32;out[15]=a03*x+a13*y+a23*z+a33}return out},multiply:(out,a,b)=>{let a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15],b0=b[0],b1=b[1],b2=b[2],b3=b[3];out[0]=b0*a00+b1*a10+b2*a20+b3*a30;out[1]=b0*a01+b1*a11+b2*a21+b3*a31;out[2]=b0*a02+b1*a12+b2*a22+b3*a32;out[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];out[4]=b0*a00+b1*a10+b2*a20+b3*a30;out[5]=b0*a01+b1*a11+b2*a21+b3*a31;out[6]=b0*a02+b1*a12+b2*a22+b3*a32;out[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];out[8]=b0*a00+b1*a10+b2*a20+b3*a30;out[9]=b0*a01+b1*a11+b2*a21+b3*a31;out[10]=b0*a02+b1*a12+b2*a22+b3*a32;out[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];out[12]=b0*a00+b1*a10+b2*a20+b3*a30;out[13]=b0*a01+b1*a11+b2*a21+b3*a31;out[14]=b0*a02+b1*a12+b2*a22+b3*a32;out[15]=b0*a03+b1*a13+b2*a23+b3*a33;return out},perspective:(out,fovy,aspect,near,far)=>{const f=1/Math.tan(fovy/2);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[11]=-1;out[15]=0;if(far!=null&&far!==Infinity){const nf=1/(near-far);out[10]=(far+near)*nf;out[14]=2*far*near*nf}else{out[10]=-1;out[14]=-2*near}return out},lookAt:(out,eye,center,up)=>{let x0,x1,x2,y0,y1,y2,z0,z1,z2,len,eyex=eye[0],eyey=eye[1],eyez=eye[2],upx=up[0],upy=up[1],upz=up[2],centerx=center[0],centery=center[1],centerz=center[2];if(Math.abs(eyex-centerx)<1e-6&&Math.abs(eyey-centery)<1e-6&&Math.abs(eyez-centerz)<1e-6)return mat4.identity(out);z0=eyex-centerx;z1=eyey-centery;z2=eyez-centerz;len=1/Math.sqrt(z0*z0+z1*z1+z2*z2);z0*=len;z1*=len;z2*=len;x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.sqrt(x0*x0+x1*x1+x2*x2);if(!len){x0=0;x1=0;x2=0}else{len=1/len;x0*=len;x1*=len;x2*=len}y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.sqrt(y0*y0+y1*y1+y2*y2);if(!len){y0=0;y1=0;y2=0}else{len=1/len;y0*=len;y1*=len;y2*=len}out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eyex+x1*eyey+x2*eyez);out[13]=-(y0*eyex+y1*eyey+y2*eyez);out[14]=-(z0*eyex+z1*eyey+z2*eyez);out[15]=1;return out},invert:(out,a)=>{let b,d,A=a[0],B=a[1],C=a[2],D=a[3],E=a[4],F=a[5],G=a[6],H=a[7],I=a[8],J=a[9],K=a[10],L=a[11],M=a[12],N=a[13],O=a[14],P=a[15],Q=A*F-B*E,R=A*G-C*E,S=A*H-D*E,T=B*G-C*F,U=B*H-D*F,V=C*H-D*G,W=I*N-J*M,X=I*O-K*M,Y=I*P-L*M,Z=J*O-K*N,$=J*P-L*N,_=K*P-L*O;d=Q*_-R*$+S*Z+T*Y-U*X+V*W;if(!d)return null;d=1/d;out[0]=(F*_-G*$+H*Z)*d;out[1]=(C*$-B*_-D*Z)*d;out[2]=(N*V-O*U+P*T)*d;out[3]=(K*U-J*V-L*T)*d;out[4]=(G*Y-E*_-H*X)*d;out[5]=(A*_-C*Y+D*X)*d;out[6]=(M*V-O*S+P*R)*d;out[7]=(I*V-K*S-L*R)*d;out[8]=(E*$-F*Y+H*W)*d;out[9]=(B*Y-A*$+D*W)*d;out[10]=(M*U-N*R+P*Q)*d;out[11]=(J*R-I*U-L*Q)*d;out[12]=(E*Z-F*X+G*W)*d;out[13]=(A*X-B*Z-C*W)*d;out[14]=(M*S-N*Q+O*P)*d;out[15]=(I*S-J*Q-K*P)*d;return out},transpose:(out,a)=>{if(out===a){let b=a[1],c=a[2],d=a[3],e=a[6],f=a[7],g=a[11];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=b;out[6]=a[9];out[7]=a[13];out[8]=c;out[9]=e;out[11]=a[14];out[12]=d;out[13]=f;out[14]=g}else{out[0]=a[0];out[1]=a[4];out[2]=a[8];out[3]=a[12];out[4]=a[1];out[5]=a[5];out[6]=a[9];out[7]=a[13];out[8]=a[2];out[9]=a[6];out[10]=a[10];out[11]=a[14];out[12]=a[3];out[13]=a[7];out[14]=a[11];out[15]=a[15]}return out}};
        const vec3 = { create:()=>new Float32Array(3),fromValues:(x,y,z)=>Float32Array.of(x,y,z),clone:a=>Float32Array.from(a),add:(out,a,b)=>{out[0]=a[0]+b[0];out[1]=a[1]+b[1];out[2]=a[2]+b[2];return out},subtract:(out,a,b)=>{out[0]=a[0]-b[0];out[1]=a[1]-b[1];out[2]=a[2]-b[2];return out},multiply:(out,a,b)=>{out[0]=a[0]*b[0];out[1]=a[1]*b[1];out[2]=a[2]*b[2];return out},scale:(out,a,b)=>{out[0]=a[0]*b;out[1]=a[1]*b;out[2]=a[2]*b;return out},dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],cross:(out,a,b)=>{let c=a[0],d=a[1],e=a[2],f=b[0],g=b[1],h=b[2];out[0]=d*h-e*g;out[1]=e*f-c*h;out[2]=c*g-d*f;return out},length:a=>Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]),normalize:(out,a)=>{let b=a[0],c=a[1],d=a[2],e=b*b+c*c+d*d;e>0&&(e=1/Math.sqrt(e),out[0]=a[0]*e,out[1]=a[1]*e,out[2]=a[2]*e);return out},transformMat4:(out,a,m)=>{let x=a[0],y=a[1],z=a[2],w=m[3]*x+m[7]*y+m[11]*z+m[15];w=w||1;out[0]=(m[0]*x+m[4]*y+m[8]*z+m[12])/w;out[1]=(m[1]*x+m[5]*y+m[9]*z+m[13])/w;out[2]=(m[2]*x+m[6]*y+m[10]*z+m[14])/w;return out},scaleAndAdd:(out,a,b,scale)=>{out[0]=a[0]+b[0]*scale;out[1]=a[1]+b[1]*scale;out[2]=a[2]+b[2]*scale;return out}};
        const vec4 = { create:()=>new Float32Array(4),fromValues:(x,y,z,w)=>Float32Array.of(x,y,z,w),transformMat4:(out,a,m)=>{let x=a[0],y=a[1],z=a[2],w=a[3];out[0]=m[0]*x+m[4]*y+m[8]*z+m[12]*w;out[1]=m[1]*x+m[5]*y+m[9]*z+m[13]*w;out[2]=m[2]*x+m[6]*y+m[10]*z+m[14]*w;out[3]=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return out}};

        // --- Global Variables ---
        let gl;
        let shaderProgram;
        let programInfo;
        
        let centralSphereBuffer;
        let satelliteConeBuffer;

        const centralSphereRadius = 2.0;
        const satelliteConeRadius = 0.5;
        const satelliteConeHeight = satelliteConeRadius * 2.0;
        const satelliteConeSegments = 24;
        const satelliteGuidanceRadius = 4.0;

        let satelliteAzimuth = Math.PI / 4;    
        let satelliteInclination = Math.PI / 3; 
        let satelliteAzimuthalVelocity = 0.0; 
        let satelliteInclinationVelocity = 0.0; 
        
        const inertiaDamping = 0.98; 
        const dragMotionMultiplier = 5.0; 
        const releaseVelocityScale = 0.3; 

        let isDragging = false;
        let lastProjectedAzimuth = 0.0;     
        let lastProjectedInclination = Math.PI / 2; 

        // Halo Effect Constants
        const haloColor = [1.0, 0.95, 0.8]; // Warm white/yellowish
        const haloIntensity = 2.0;         // How bright
        const haloSharpness = 5.0;         // How tight the rim is (higher = tighter)
        const behindFactorPower = 7.0;     // How sharply "behind" matters (higher = more distinct)


        let cameraPosition = vec3.fromValues(0, 3, 10); 
        let cameraTarget = vec3.fromValues(0, 0, 0);
        let cameraUp = vec3.fromValues(0, 1, 0);

        const projectionMatrix = mat4.create(); 
        const viewMatrix = mat4.create();       
        const modelMatrix = mat4.create();      

        // --- Main Function ---
        function main() { 
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');
            if (!gl) { alert('Unable to initialize WebGL.'); return; }
            shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            if (!shaderProgram) return;
            programInfo = { 
                program: shaderProgram,
                attribLocations: { 
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'), 
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), 
                },
                uniformLocations: { 
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), 
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), 
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), 
                    color: gl.getUniformLocation(shaderProgram, 'uColor'), 
                    useLighting: gl.getUniformLocation(shaderProgram, 'uUseLighting'), 
                    lightPositionView: gl.getUniformLocation(shaderProgram, 'uLightPositionView'),
                    // Halo Uniforms
                    haloColor: gl.getUniformLocation(shaderProgram, 'uHaloColor'),
                    haloIntensity: gl.getUniformLocation(shaderProgram, 'uHaloIntensity'),
                    haloSharpness: gl.getUniformLocation(shaderProgram, 'uHaloSharpness'),
                    behindFactorPower: gl.getUniformLocation(shaderProgram, 'uBehindFactorPower')
                },
            };
            centralSphereBuffer = createSphereBuffers(gl, centralSphereRadius, 32, 32);
            satelliteConeBuffer = createConeBuffers(gl, satelliteConeRadius, satelliteConeHeight, satelliteConeSegments);
            canvas.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mouseup', handleMouseUp); 
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseout', handleMouseOut); 
            requestAnimationFrame(render);
        }

        // --- Shader Util (collapsed) ---
        function initShaderProgram(gl,vsSource,fsSource){const v=loadShader(gl,gl.VERTEX_SHADER,vsSource),f=loadShader(gl,gl.FRAGMENT_SHADER,fsSource);if(!v||!f)return null;const p=gl.createProgram();gl.attachShader(p,v);gl.attachShader(p,f);gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS)){alert("Unable to initialize the shader program: "+gl.getProgramInfoLog(p));gl.deleteProgram(p);gl.deleteShader(v);gl.deleteShader(f);return null}return p}
        function loadShader(gl,type,source){const s=gl.createShader(type);gl.shaderSource(s,source);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){alert(`An error occurred compiling the ${type===gl.VERTEX_SHADER?"VERTEX":"FRAGMENT"} shader: \n`+gl.getShaderInfoLog(s));gl.deleteShader(s);return null}return s}

        // --- Geometry Util (Sphere) (collapsed) ---
        function createSphereBuffers(gl,radius,latBands,lonBands){const v=[],n=[],idx=[];for(let a=0;a<=latBands;a++){const t=a*Math.PI/latBands,st=Math.sin(t),ct=Math.cos(t);for(let o=0;o<=lonBands;o++){const p=o*2*Math.PI/lonBands,sp=Math.sin(p),cp=Math.cos(p),x=cp*st,y=ct,z=sp*st;n.push(x,y,z);v.push(radius*x,radius*y,radius*z)}}for(let a=0;a<latBands;a++)for(let o=0;o<lonBands;o++){const f=a*(lonBands+1)+o,s=f+lonBands+1;idx.push(f,s,f+1);idx.push(s,s+1,f+1)}const pbuf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,pbuf);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(v),gl.STATIC_DRAW);const nbuf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,nbuf);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(n),gl.STATIC_DRAW);const ibuf=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibuf);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(idx),gl.STATIC_DRAW);return{position:pbuf,normal:nbuf,indices:ibuf,vertexCount:idx.length}}

        function createConeBuffers(gl, radius, height, radialSubdivisions) {
            const positions = [];
            const normals = [];
            const indices = [];
            const halfHeight = height / 2;

            for (let i = 0; i < radialSubdivisions; i++) {
                const angle = (i / radialSubdivisions) * Math.PI * 2;
                const cosAngle = Math.cos(angle);
                const sinAngle = Math.sin(angle);

                const nxRaw = height * cosAngle;
                const nyRaw = radius;
                const nzRaw = height * sinAngle;
                const length = Math.sqrt(nxRaw * nxRaw + nyRaw * nyRaw + nzRaw * nzRaw) || 1;
                const nx = nxRaw / length;
                const ny = nyRaw / length;
                const nz = nzRaw / length;

                positions.push(0, halfHeight, 0);
                normals.push(nx, ny, nz);

                positions.push(radius * cosAngle, -halfHeight, radius * sinAngle);
                normals.push(nx, ny, nz);
            }

            for (let i = 0; i < radialSubdivisions; i++) {
                const apexIndex = i * 2;
                const baseIndex = apexIndex + 1;
                const nextBaseIndex = ((i + 1) % radialSubdivisions) * 2 + 1;
                indices.push(apexIndex, baseIndex, nextBaseIndex);
            }

            const baseCenterIndex = positions.length / 3;
            positions.push(0, -halfHeight, 0);
            normals.push(0, -1, 0);

            const baseStartIndex = positions.length / 3;
            for (let i = 0; i < radialSubdivisions; i++) {
                const angle = (i / radialSubdivisions) * Math.PI * 2;
                const cosAngle = Math.cos(angle);
                const sinAngle = Math.sin(angle);
                positions.push(radius * cosAngle, -halfHeight, radius * sinAngle);
                normals.push(0, -1, 0);
            }

            for (let i = 0; i < radialSubdivisions; i++) {
                const current = baseStartIndex + i;
                const next = baseStartIndex + ((i + 1) % radialSubdivisions);
                indices.push(baseCenterIndex, current, next);
            }

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return { position: positionBuffer, normal: normalBuffer, indices: indexBuffer, vertexCount: indices.length };
        }

        // --- Mouse Event Handlers ---
        function handleMouseDown(event) {
            const rect = event.target.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const ray = getRayFromMouse(mouseX, mouseY);
            if (!ray) return; 
            const intersection = intersectRaySphere(ray.origin, ray.direction, vec3.fromValues(0,0,0), centralSphereRadius);
            if (intersection) {
                isDragging = true;
                updateSatelliteFromIntersection(intersection.point, true); 
            }
        }
        function handleMouseUp(event) { isDragging = false; }
        function handleMouseOut(event) { if (event.buttons === 0) isDragging = false; }
        function handleMouseMove(event) {
            if (!isDragging) return;
            const rect = event.target.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const ray = getRayFromMouse(mouseX, mouseY);
            if (!ray) return;
            const intersection = intersectRaySphere(ray.origin, ray.direction, vec3.fromValues(0,0,0), centralSphereRadius);
            if (intersection) {
                updateSatelliteFromIntersection(intersection.point, false); 
            }
        }
        
        function updateSatelliteFromIntersection(intersectionPoint, isMouseDown) {
            const directionToIntersection = vec3.create();
            vec3.normalize(directionToIntersection, intersectionPoint); 
            const currentProjAzimuth = Math.atan2(directionToIntersection[2], directionToIntersection[0]);
            let currentProjInclination = Math.acos(directionToIntersection[1]); 
            currentProjInclination = Math.max(1e-4, Math.min(Math.PI - 1e-4, currentProjInclination));

            if (isMouseDown) { 
                satelliteAzimuth = currentProjAzimuth;
                satelliteInclination = currentProjInclination;
                lastProjectedAzimuth = currentProjAzimuth;
                lastProjectedInclination = currentProjInclination;
                satelliteAzimuthalVelocity = 0; 
                satelliteInclinationVelocity = 0;
            } else { 
                let deltaProjAz = currentProjAzimuth - lastProjectedAzimuth;
                if (deltaProjAz > Math.PI) deltaProjAz -= 2 * Math.PI;
                if (deltaProjAz < -Math.PI) deltaProjAz += 2 * Math.PI;
                let deltaProjInc = currentProjInclination - lastProjectedInclination;
                const effectiveDeltaAz = deltaProjAz * dragMotionMultiplier;
                const effectiveDeltaInc = deltaProjInc * dragMotionMultiplier;
                satelliteAzimuth += effectiveDeltaAz;
                satelliteInclination += effectiveDeltaInc;
                satelliteInclination = Math.max(1e-4, Math.min(Math.PI - 1e-4, satelliteInclination));
                satelliteAzimuthalVelocity = effectiveDeltaAz * releaseVelocityScale; 
                satelliteInclinationVelocity = effectiveDeltaInc * releaseVelocityScale; 
                lastProjectedAzimuth = currentProjAzimuth;
                lastProjectedInclination = currentProjInclination;
            }
        }

        // --- Raycasting (collapsed) ---
        function getRayFromMouse(mX,mY){const c=gl.canvas,nX=mX/c.clientWidth*2-1,nY=1-mY/c.clientHeight*2,iP=mat4.create();if(!mat4.invert(iP,projectionMatrix))return null;let eC=vec4.fromValues(nX,nY,-1,1);vec4.transformMat4(eC,eC,iP);if(eC[3]!==0&&eC[3]!==1){eC[0]/=eC[3];eC[1]/=eC[3];eC[2]/=eC[3]}eC[2]=-1;eC[3]=0;const iV=mat4.create();if(!mat4.invert(iV,viewMatrix))return null;let wR4=vec4.create();vec4.transformMat4(wR4,eC,iV);const rD=vec3.fromValues(wR4[0],wR4[1],wR4[2]);vec3.normalize(rD,rD);const rO=vec3.clone(cameraPosition);return{origin:rO,direction:rD}}
        function intersectRaySphere(rO,rD,sC,sR){const oc=vec3.create();vec3.subtract(oc,rO,sC);const a=vec3.dot(rD,rD),b=2*vec3.dot(oc,rD),c=vec3.dot(oc,oc)-sR*sR,d=b*b-4*a*c;if(d<0)return null;else{const t1=(-b-Math.sqrt(d))/(2*a),t2=(-b+Math.sqrt(d))/(2*a);let t=-1;if(t1>=0&&t2>=0)t=Math.min(t1,t2);else if(t1>=0)t=t1;else if(t2>=0)t=t2;else return null;const iP=vec3.create();vec3.scaleAndAdd(iP,rO,rD,t);return{t:t,point:iP}}}

        // --- Render Loop ---
        function render(now) {
            if (!gl || !programInfo) return; 
            resizeCanvasToDisplaySize(gl.canvas); 
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            if (!isDragging) {
                satelliteAzimuth += satelliteAzimuthalVelocity;
                satelliteInclination += satelliteInclinationVelocity;
                satelliteAzimuthalVelocity *= inertiaDamping;
                satelliteInclinationVelocity *= inertiaDamping;
                if (satelliteInclination <= 1e-4) { satelliteInclination = 1e-4; satelliteInclinationVelocity *= -0.5; }
                if (satelliteInclination >= Math.PI - 1e-4) { satelliteInclination = Math.PI - 1e-4; satelliteInclinationVelocity *= -0.5; }
            }
            drawScene();
            requestAnimationFrame(render);
        }

        // --- Drawing ---
        function drawScene() {
            gl.clearColor(0.1, 0.1, 0.15, 1.0); gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            const fieldOfView = 45 * Math.PI / 180; const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1; const zFar = 100.0;
            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
            mat4.lookAt(viewMatrix, cameraPosition, cameraTarget, cameraUp);
            gl.useProgram(programInfo.program);

            const r = satelliteGuidanceRadius, incl = satelliteInclination, azim = satelliteAzimuth;
            const satelliteX = r * Math.sin(incl) * Math.cos(azim);
            const satelliteY = r * Math.cos(incl);
            const satelliteZ = r * Math.sin(incl) * Math.sin(azim);
            const satelliteWorldPosVec4 = vec4.fromValues(satelliteX, satelliteY, satelliteZ, 1.0);
            const satelliteViewPosVec4 = vec4.create();
            vec4.transformMat4(satelliteViewPosVec4, satelliteWorldPosVec4, viewMatrix);
            gl.uniform3f(programInfo.uniformLocations.lightPositionView, satelliteViewPosVec4[0], satelliteViewPosVec4[1], satelliteViewPosVec4[2]);

            // --- Draw Central Sphere ---
            mat4.identity(modelMatrix); 
            const modelViewMatrix = mat4.create(); mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
            const normalMatrix = mat4.create(); mat4.invert(normalMatrix, modelViewMatrix); mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);
            gl.uniform4fv(programInfo.uniformLocations.color, [1.0, 1.0, 1.0, 1.0]);
            gl.uniform1i(programInfo.uniformLocations.useLighting, 1); 
            // Set Halo Uniforms
            gl.uniform3fv(programInfo.uniformLocations.haloColor, haloColor);
            gl.uniform1f(programInfo.uniformLocations.haloIntensity, haloIntensity);
            gl.uniform1f(programInfo.uniformLocations.haloSharpness, haloSharpness);
            gl.uniform1f(programInfo.uniformLocations.behindFactorPower, behindFactorPower);
            bindAndDrawMesh(centralSphereBuffer);

            // --- Draw Satellite Cone ---
            mat4.identity(modelMatrix);
            const rotationMatrix = mat4.create();
            let hasRotation = false;
            const directionLength = Math.hypot(satelliteX, satelliteY, satelliteZ);
            if (directionLength > 1e-5) {
                let axisY = [-satelliteX / directionLength, -satelliteY / directionLength, -satelliteZ / directionLength];
                const axisYLength = Math.hypot(axisY[0], axisY[1], axisY[2]);
                if (axisYLength > 1e-5) {
                    axisY = [axisY[0] / axisYLength, axisY[1] / axisYLength, axisY[2] / axisYLength];
                }

                let referenceForward = [0, 0, 1];
                const axisDotRef = axisY[0] * referenceForward[0] + axisY[1] * referenceForward[1] + axisY[2] * referenceForward[2];
                if (Math.abs(axisDotRef) > 0.999) {
                    referenceForward = [1, 0, 0];
                }

                let right = [
                    axisY[1] * referenceForward[2] - axisY[2] * referenceForward[1],
                    axisY[2] * referenceForward[0] - axisY[0] * referenceForward[2],
                    axisY[0] * referenceForward[1] - axisY[1] * referenceForward[0]
                ];
                let rightLength = Math.hypot(right[0], right[1], right[2]);
                if (rightLength < 1e-5) {
                    right = [1, 0, 0];
                    rightLength = 1;
                }
                right = [right[0] / rightLength, right[1] / rightLength, right[2] / rightLength];

                let forward = [
                    right[1] * axisY[2] - right[2] * axisY[1],
                    right[2] * axisY[0] - right[0] * axisY[2],
                    right[0] * axisY[1] - right[1] * axisY[0]
                ];
                let forwardLength = Math.hypot(forward[0], forward[1], forward[2]);
                if (forwardLength < 1e-5) {
                    forward = [0, 0, 1];
                    forwardLength = 1;
                }
                forward = [forward[0] / forwardLength, forward[1] / forwardLength, forward[2] / forwardLength];

                // Re-orthogonalize to maintain an orthonormal basis
                right = [
                    axisY[1] * forward[2] - axisY[2] * forward[1],
                    axisY[2] * forward[0] - axisY[0] * forward[2],
                    axisY[0] * forward[1] - axisY[1] * forward[0]
                ];
                rightLength = Math.hypot(right[0], right[1], right[2]);
                if (rightLength < 1e-5) {
                    right = [1, 0, 0];
                    rightLength = 1;
                }
                right = [right[0] / rightLength, right[1] / rightLength, right[2] / rightLength];

                forward = [
                    right[1] * axisY[2] - right[2] * axisY[1],
                    right[2] * axisY[0] - right[0] * axisY[2],
                    right[0] * axisY[1] - right[1] * axisY[0]
                ];
                forwardLength = Math.hypot(forward[0], forward[1], forward[2]);
                if (forwardLength < 1e-5) {
                    forward = [0, 0, 1];
                    forwardLength = 1;
                }
                forward = [forward[0] / forwardLength, forward[1] / forwardLength, forward[2] / forwardLength];

                rotationMatrix[0] = right[0];
                rotationMatrix[1] = right[1];
                rotationMatrix[2] = right[2];
                rotationMatrix[3] = 0;
                rotationMatrix[4] = axisY[0];
                rotationMatrix[5] = axisY[1];
                rotationMatrix[6] = axisY[2];
                rotationMatrix[7] = 0;
                rotationMatrix[8] = forward[0];
                rotationMatrix[9] = forward[1];
                rotationMatrix[10] = forward[2];
                rotationMatrix[11] = 0;
                rotationMatrix[12] = 0;
                rotationMatrix[13] = 0;
                rotationMatrix[14] = 0;
                rotationMatrix[15] = 1;
                hasRotation = true;
            }
            mat4.translate(modelMatrix, modelMatrix, [satelliteX, satelliteY, satelliteZ]);
            if (hasRotation) {
                mat4.multiply(modelMatrix, modelMatrix, rotationMatrix);
            }
            const satelliteModelViewMatrix = mat4.create();
            mat4.multiply(satelliteModelViewMatrix, viewMatrix, modelMatrix);
            const satelliteNormalMatrix = mat4.create();
            mat4.invert(satelliteNormalMatrix, satelliteModelViewMatrix);
            mat4.transpose(satelliteNormalMatrix, satelliteNormalMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, satelliteModelViewMatrix); 
            gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, satelliteNormalMatrix); 
            gl.uniform4fv(programInfo.uniformLocations.color, [1.0, 1.0, 0.8, 1.0]);
            gl.uniform1i(programInfo.uniformLocations.useLighting, 0);
            bindAndDrawMesh(satelliteConeBuffer);
        }
        function bindAndDrawMesh(meshBuffers) {
            gl.bindBuffer(gl.ARRAY_BUFFER, meshBuffers.position);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.bindBuffer(gl.ARRAY_BUFFER, meshBuffers.normal);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshBuffers.indices);
            gl.drawElements(gl.TRIANGLES, meshBuffers.vertexCount, gl.UNSIGNED_SHORT, 0);
        }

        // --- Canvas Resize ---
        function resizeCanvasToDisplaySize(canvas) { 
            const displayWidth  = canvas.clientWidth; const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth; canvas.height = displayHeight; return true;
            } return false;
        }

        // --- Start ---
        window.onload = () => { 
            main();
            if (gl) { resizeCanvasToDisplaySize(gl.canvas); }
        };
    </script>
</body>
</html>
