<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Chat + Diagnostics</title>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
  <style>
    :root { --bg: #121212; --surface: #1e1e1e; --primary: #03dac6; --text: #e0e0e0; }
    body { font-family: sans-serif; background: var(--bg); color: var(--text); padding: 10px; display: flex; flex-direction: column; align-items: center; }
    .container { width: 100%; max-width: 600px; display: flex; flex-direction: column; gap: 15px; }
    .card { background: var(--surface); padding: 15px; border-radius: 8px; border: 1px solid #333; }
    h3 { margin: 0 0 10px 0; color: var(--primary); display:flex; justify-content:space-between; font-size: 1rem;}
    textarea { width: 100%; height: 60px; background: #000; color: #fff; border: 1px solid #444; border-radius: 4px; padding: 5px; font-family: monospace; font-size: 0.8rem; }
    button { background: var(--primary); color: #000; border: none; padding: 10px; border-radius: 4px; font-weight: bold; width: 100%; cursor: pointer; margin-top:5px;}
    .row { display: flex; gap: 10px; }
    #chat-log { height: 200px; overflow-y: auto; background: #000; padding: 10px; border: 1px solid #333; font-size: 0.8rem; font-family: monospace; }
    .msg { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
    .sys { color: #888; } .err { color: #ff5252; } .local { color: #81c784; } .remote { color: #64b5f6; }
    #qr-container { text-align: center; margin-top: 10px; }
    #reader { width: 100%; height: 300px; background: #000; margin-bottom: 10px; display: none; }
    .hidden { display: none !important; }
  </style>
</head>

<body>

  <div class="container">
    <div class="card">
      <h3>Status: <span id="status">Disconnected</span></h3>
    </div>

    <!-- LOCAL -->
    <div class="card">
      <h3>1. Your Info <button style="width:auto; padding:2px 8px; font-size:0.7rem" onclick="copyLocal()">Copy</button></h3>
      <textarea id="local-sdp" readonly onclick="this.select()"></textarea>
      
      <div id="qr-section">
        <div id="qr-container">
          <canvas id="qr-canvas"></canvas>
          <div id="qr-msg" class="sys">Initializing...</div>
        </div>
      </div>
    </div>

    <!-- REMOTE -->
    <div class="card">
      <h3>2. Peer Info</h3>
      <div id="reader"></div>
      <textarea id="remote-sdp" placeholder="Scan or Paste Peer SDP..." oninput="uiState()"></textarea>
      
      <div class="row">
        <button id="btn-scan" onclick="startScanner()">ðŸ“· Scan QR</button>
        <button id="btn-conn" onclick="connect()" class="hidden">ðŸ”— Connect</button>
        <button id="btn-stop" onclick="stopScanner()" class="hidden" style="background:#cf6679">Cancel</button>
      </div>
    </div>

    <!-- CHAT -->
    <div class="card">
      <h3>Debug Log / Chat</h3>
      <div id="chat-log"></div>
      <div class="row" style="margin-top:5px;">
        <input id="chat-in" type="text" placeholder="Type..." style="flex-grow:1; padding:8px;" onkeypress="if(event.key==='Enter') sendMsg()">
        <button style="width:auto;" onclick="sendMsg()">Send</button>
      </div>
    </div>
  </div>

  <script>
    // --- UTILS ---
    const log = (m, t='sys') => {
      const el = document.getElementById('chat-log');
      el.innerHTML += `<div class="msg ${t}">[${new Date().toLocaleTimeString().split(' ')[0]}] ${m}</div>`;
      el.scrollTop = el.scrollHeight;
      console.log(m);
    };

    async function compress(str) {
      const s = new Blob([str]).stream().pipeThrough(new CompressionStream('gzip'));
      const b = await new Response(s).blob();
      return new Promise(r => { const fr=new FileReader(); fr.onload=()=>r(fr.result.split(',')[1]); fr.readAsDataURL(b); });
    }

    async function decompress(b64) {
      try {
        const bin = atob(decodeURIComponent(b64).trim());
        const arr = new Uint8Array(bin.length);
        for(let i=0; i<bin.length; i++) arr[i] = bin.charCodeAt(i);
        const s = new Blob([arr]).stream().pipeThrough(new DecompressionStream('gzip'));
        return await new Response(s).text();
      } catch(e) { throw new Error("Decompress Failed"); }
    }

    // --- APP ---
    const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
    let pc, dc, scanner;
    
    // Elements
    const el = {
      local: document.getElementById('local-sdp'),
      remote: document.getElementById('remote-sdp'),
      btnScan: document.getElementById('btn-scan'),
      btnConn: document.getElementById('btn-conn'),
      btnStop: document.getElementById('btn-stop'),
      status: document.getElementById('status'),
      qrMsg: document.getElementById('qr-msg'),
      qrSec: document.getElementById('qr-section')
    };

    function initPC() {
      if(pc) pc.close();
      pc = new RTCPeerConnection(config);
      
      // DIAGNOSTICS: Log candidates to see if they are mDNS or Private
      pc.onicecandidate = e => {
        if(e.candidate) {
            let type = e.candidate.type; // host, srflx, or relay
            let addr = e.candidate.address || e.candidate.candidate;
            // Check for mDNS (often ends in .local)
            if(addr.includes('.local')) type += " (mDNS - Local Only)";
            log(`Gathered: ${type}`, 'local');
        } else {
            log("ICE Gathering Complete. Generating QR...", 'sys');
            const sdp = JSON.stringify(pc.localDescription);
            el.local.value = sdp;
            compress(sdp).then(b64 => {
              const url = window.location.origin + window.location.pathname + '#' + encodeURIComponent(b64);
              QRCode.toCanvas(document.getElementById('qr-canvas'), url, { width: 180, margin:1 }, (e)=>{
                if(!e) el.qrMsg.innerText = "Scan Me";
              });
            });
        }
      };

      pc.onconnectionstatechange = () => {
        el.status.innerText = pc.connectionState;
        log(`State Change: ${pc.connectionState}`, 'sys');
        if(pc.connectionState === 'failed') {
            log("âŒ Connection Failed. This is usually due to NAT/Firewall.", 'err');
            log("Tip: Are you on the same Wi-Fi? mDNS might be blocking you.", 'err');
        }
      };

      pc.ondatachannel = e => setupDC(e.channel);
    }

    function setupDC(channel) {
      dc = channel;
      dc.onopen = () => { log("âœ… DATA CHANNEL OPEN!", 'local'); el.status.style.color='#00ff00'; };
      dc.onmessage = e => log(`Peer: ${e.data}`, 'remote');
    }

    // --- LOGIC ---
    function uiState() {
      if(el.remote.value.length > 0) {
        el.btnScan.classList.add('hidden');
        el.btnConn.classList.remove('hidden');
      } else {
        el.btnScan.classList.remove('hidden');
        el.btnConn.classList.add('hidden');
      }
    }

    function startScanner() {
      el.qrSec.classList.add('hidden'); // Hide Local QR
      document.getElementById('reader').style.display = 'block';
      el.btnScan.classList.add('hidden');
      el.btnStop.classList.remove('hidden');
      
      scanner = new Html5Qrcode("reader");
      scanner.start({ facingMode: "environment" }, { fps: 10, qrbox: 250 }, 
        (txt) => {
           let b64 = txt.includes('#') ? txt.split('#').pop() : txt;
           decompress(b64).then(json => {
             // Self-scan Guard
             if(json === el.local.value) return log("âš ï¸ You scanned yourself!", 'err');
             
             el.remote.value = json;
             stopScanner();
             log("QR Scanned. Click Connect.", 'sys');
           }).catch(e => log("Bad QR Code", 'err'));
        }, 
        (err) => {}
      );
    }

    function stopScanner() {
      if(scanner) scanner.stop().then(() => {
        document.getElementById('reader').style.display = 'none';
        el.qrSec.classList.remove('hidden');
        el.btnStop.classList.add('hidden');
        scanner.clear();
        uiState();
      });
    }

    async function createOffer() {
      log("Creating Offer...", 'sys');
      initPC();
      dc = pc.createDataChannel("chat");
      setupDC(dc);
      await pc.setLocalDescription(await pc.createOffer());
    }

    async function connect() {
      const txt = el.remote.value.trim();
      if(!txt) return;

      try {
        const desc = JSON.parse(txt);
        
        // GLARE FIX: If we have a local offer but scan an offer, reset.
        if(desc.type === 'offer' && pc.signalingState === 'have-local-offer') {
            log("âš ï¸ Glare detected (Both are Callers). Resetting...", 'sys');
            initPC();
        }

        log(`Setting Remote ${desc.type}...`, 'sys');
        await pc.setRemoteDescription(desc);

        if(desc.type === 'offer') {
          log("Creating Answer...", 'sys');
          await pc.setLocalDescription(await pc.createAnswer());
        }
      } catch(e) {
        log("Connect Error: " + e.message, 'err');
      }
    }

    function sendMsg() {
      const i = document.getElementById('chat-in');
      if(dc && dc.readyState==='open') { dc.send(i.value); log(`Me: ${i.value}`, 'local'); i.value=''; }
    }

    function copyLocal() {
        el.local.select(); document.execCommand('copy');
    }

    // --- BOOT ---
    if(window.location.hash.length > 1) {
      log("ðŸ“¥ Loaded from URL Hash", 'sys');
      initPC();
      decompress(window.location.hash.substring(1)).then(json => {
        el.remote.value = json;
        uiState();
        log("Ready to Connect.", 'sys');
      });
    } else {
      createOffer();
    }
  </script>
</body>
</html>
