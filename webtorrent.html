<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust P2P Chat</title>
    <style>
        /* [Previous CSS remains mostly the same, condensed for brevity] */
        * { box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #0f0f12; color: #e0e0e0; max-width: 900px; margin: 0 auto; padding: 20px; }
        h2 { color: #4ade80; margin-bottom: 5px; }
        #status { padding: 10px; border-radius: 8px; margin-bottom: 15px; background: #222; border: 1px solid #333; }
        .status-ok { color: #4ade80; border-color: #4ade80; }
        .status-warn { color: #facc15; border-color: #facc15; }
        #video-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .video-wrapper { position: relative; background: #000; aspect-ratio: 4/3; border-radius: 8px; overflow: hidden; }
        video { width: 100%; height: 100%; object-fit: cover; }
        .label { position: absolute; bottom: 5px; left: 5px; background: rgba(0,0,0,0.6); padding: 2px 6px; font-size: 12px; border-radius: 4px; }
        #log { height: 200px; overflow-y: auto; background: #1a1a1e; padding: 10px; border: 1px solid #333; font-family: monospace; font-size: 0.85em; margin-bottom: 10px; }
        .log-sys { color: #888; } .log-err { color: #f87171; } .log-msg { color: #fff; }
        #controls { display: flex; gap: 10px; }
        input { flex: 1; padding: 10px; background: #222; border: 1px solid #444; color: #fff; border-radius: 4px; }
        button { padding: 10px 20px; cursor: pointer; background: #4ade80; border: none; border-radius: 4px; font-weight: bold; }
        button:disabled { background: #444; color: #888; cursor: not-allowed; }
        #local-preview { position: fixed; bottom: 20px; right: 20px; width: 120px; aspect-ratio: 4/3; background: #000; border: 2px solid #333; border-radius: 8px; z-index: 100; display: none; }
    </style>
</head>
<body>
    <h2>Secure P2P Mesh</h2>
    <div id="status">Initializing...</div>
    
    <div id="video-grid"></div>
    <div id="local-preview"><video id="local-video" autoplay muted playsinline></video></div>

    <div id="log"></div>

    <div id="controls">
        <input type="text" id="msg" placeholder="Waiting for peers..." disabled>
        <button id="camera-btn">Start Camera</button>
        <button id="send-btn" disabled>Send</button>
    </div>

    <script>
        // --- 1. CONFIGURATION & BEST PRACTICES ---
        const CONFIG = {
            // Redundant Trackers (Reliability)
            trackers: [
                'wss://tracker.webtorrent.dev',
                'wss://tracker.openwebtorrent.com',
                'wss://tracker.btorrent.xyz',
                'wss://tracker.files.fm:7073/announce',
                'wss://open.tube/tracker/socket'
            ],
            // ICE Servers (STUN/TURN) - In prod, ADD TURN SERVERS HERE
            rtc: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ],
                iceCandidatePoolSize: 10
            },
            // Bandwidth Limits (Bitrate Control)
            videoBitrate: 300, // kbps (Low to allow Mesh scaling)
            pingInterval: 2000,
            offerTtl: 60000
        };

        const ROOM_ID = (location.hash.slice(1) || 'default-room').toLowerCase();
        const MY_ID = Math.random().toString(36).substring(2, 15);
        
        // State
        const peers = {}; // id -> { pc, dc, lastPing }
        let localStream = null;
        let isCameraOn = false;
        
        // --- 2. UTILS & ROBUSTNESS ---
        
        const log = (msg, type='sys') => {
            const el = document.getElementById('log');
            el.innerHTML += `<div class="log-${type}">[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        };

        // SDP Munging to limit bandwidth (Crucial for P2P Mesh)
        function setMediaBitrate(sdp, bitrate) {
            const lines = sdp.split("\n");
            let line = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].indexOf("m=video") === 0) {
                    line = i;
                    break;
                }
            }
            if (line === -1) return sdp;
            
            // Find next m= line
            let nextLine = lines.length;
            for (let i = line + 1; i < lines.length; i++) {
                if (lines[i].indexOf("m=") === 0) {
                    nextLine = i;
                    break;
                }
            }
            
            // Insert b=AS line
            lines.splice(nextLine, 0, `b=AS:${bitrate}`);
            return lines.join("\n");
        }

        // --- 3. PEER CONNECTION FACTORY ---

        function createPeer(peerId, initiator = false) {
            const pc = new RTCPeerConnection(CONFIG.rtc);
            
            // Setup Data Channel (Our new Signaling Highway)
            let dc;
            if (initiator) {
                dc = pc.createDataChannel('chat', { negotiated: true, id: 0 });
            } else {
                dc = pc.createDataChannel('chat', { negotiated: true, id: 0 });
            }

            const peerObj = { pc, dc, id: peerId, lastPing: Date.now(), polite: !initiator };
            peers[peerId] = peerObj;

            // 3a. Robust DataChannel Handlers
            dc.onopen = () => {
                log(`Connected to ${peerId}`, 'ok');
                updateStatus();
                startHeartbeat(peerObj);
                
                // If we have a camera on, send it now via the established channel
                if (localStream) addTracksToConnection(pc, localStream);
            };
            
            dc.onclose = () => handleDisconnect(peerId);
            
            dc.onmessage = async (e) => {
                const data = JSON.parse(e.data);
                
                // IN-BAND SIGNALING (Reliability Upgrade)
                if (data.type === 'signal') {
                    handleInBandSignal(peerObj, data);
                    return;
                }
                
                if (data.type === 'ping') {
                    dc.send(JSON.stringify({ type: 'pong' }));
                    return;
                }
                if (data.type === 'pong') {
                    peerObj.lastPing = Date.now();
                    return;
                }
                
                if (data.type === 'chat') {
                    log(`${peerId.substr(0,4)}: ${data.text}`, 'msg');
                }
            };

            // 3b. Video Handling
            pc.ontrack = (e) => {
                const vidId = `vid-${peerId}`;
                let wrap = document.getElementById(vidId);
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.className = 'video-wrapper';
                    wrap.id = vidId;
                    wrap.innerHTML = `<video autoplay playsinline></video><div class="label">${peerId.substr(0,4)}</div>`;
                    document.getElementById('video-grid').appendChild(wrap);
                }
                wrap.querySelector('video').srcObject = e.streams[0];
            };

            // 3c. Negotiation Logic (Perfect Negotiation Pattern)
            pc.onnegotiationneeded = async () => {
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // Send signaling over DataChannel if open, otherwise wait for tracker
                    if (dc.readyState === 'open') {
                        dc.send(JSON.stringify({ 
                            type: 'signal', 
                            desc: { type: pc.localDescription.type, sdp: pc.localDescription.sdp } 
                        }));
                    }
                } catch (err) { console.error(err); }
            };

            // 3d. ICE Restart Logic
            pc.oniceconnectionstatechange = () => {
                if (pc.iceConnectionState === 'failed') {
                    log(`Connection failed with ${peerId}, attempting ICE restart...`, 'err');
                    pc.restartIce();
                }
            };

            return peerObj;
        }

        // --- 4. SIGNALING LOGIC (HYBRID) ---

        // Handle signaling that arrives via DataChannel (Fast, Reliable)
        async function handleInBandSignal(peer, data) {
            const { pc } = peer;
            try {
                if (data.desc) {
                    const { type, sdp } = data.desc;
                    // Apply bandwidth limits to incoming SDP
                    const limitedSdp = setMediaBitrate(sdp, CONFIG.videoBitrate);
                    
                    // Collision handling (Polite Peer)
                    const offerCollision = (type === 'offer') && 
                                         (pc.signalingState !== 'stable') && 
                                         !peer.polite;
                    
                    if (offerCollision) {
                        console.log("Ignoring colliding offer");
                        return;
                    }

                    await pc.setRemoteDescription({ type, sdp: limitedSdp });
                    
                    if (type === 'offer') {
                        await pc.setLocalDescription(await pc.createAnswer());
                        peer.dc.send(JSON.stringify({
                            type: 'signal',
                            desc: pc.localDescription
                        }));
                    }
                }
                if (data.candidate) {
                    await pc.addIceCandidate(data.candidate);
                }
            } catch (err) {
                console.error("Signal Error", err);
            }
        }

        // --- 5. TRACKER / WEBTORRENT EMULATION ---
        // (Simplified logic to connect to websocket trackers and find peers)
        
        async function initLink() {
            const hashBuffer = await crypto.subtle.digest('SHA-1', new TextEncoder().encode(ROOM_ID));
            const infoHashArray = Array.from(new Uint8Array(hashBuffer));
            const infoHash = infoHashArray.map(b => b.toString(36)).join('').slice(0, 20); // Base36 for Webtorrent trackers

            log(`Room Hash: ${infoHash}`, 'sys');

            CONFIG.trackers.forEach(url => {
                const ws = new WebSocket(url);
                ws.onopen = () => {
                    setInterval(() => {
                        ws.send(JSON.stringify({
                            action: 'announce',
                            info_hash: infoHash,
                            peer_id: MY_ID,
                            numwant: 10,
                            offers: [] // In a full implementation, we'd send pooled offers here
                        }));
                    }, 9000); // Keep-alive announce
                    
                    // Initial Announce with an offer
                    sendTrackerOffer(ws, infoHash);
                };

                ws.onmessage = async (e) => {
                    const msg = JSON.parse(e.data);
                    if (msg.peer_id === MY_ID) return;
                    
                    // Received an Offer
                    if (msg.offer && !peers[msg.peer_id]) {
                        log(`Incoming connection from ${msg.peer_id}`, 'sys');
                        const peer = createPeer(msg.peer_id, false); // Not initiator
                        await peer.pc.setRemoteDescription(msg.offer);
                        const answer = await peer.pc.createAnswer();
                        await peer.pc.setLocalDescription(answer);
                        
                        ws.send(JSON.stringify({
                            action: 'announce',
                            info_hash: infoHash,
                            to_peer_id: msg.peer_id,
                            peer_id: MY_ID,
                            offer_id: msg.offer_id,
                            answer: answer
                        }));
                    }

                    // Received an Answer
                    if (msg.answer && pendingOffers[msg.offer_id]) {
                        const peerData = pendingOffers[msg.offer_id];
                        // Promote to full peer
                        peers[msg.peer_id] = peerData.peerObj;
                        peerData.peerObj.id = msg.peer_id; // Update ID
                        await peerData.peerObj.pc.setRemoteDescription(msg.answer);
                        delete pendingOffers[msg.offer_id];
                        log(`Connected to ${msg.peer_id}`, 'ok');
                    }
                };
            });
        }

        // Simple Offer Pool Logic
        const pendingOffers = {}; 
        async function sendTrackerOffer(ws, infoHash) {
            const offerId = Math.random().toString(36).slice(2);
            // Create a temporary peer for this offer
            const peerObj = createPeer('pending', true); 
            const offer = await peerObj.pc.createOffer();
            await peerObj.pc.setLocalDescription(offer);

            // Wait for ICE to gather locally before sending (Vanilla WebRTC trick)
            await new Promise(r => setTimeout(r, 1000)); 

            pendingOffers[offerId] = { peerObj, timestamp: Date.now() };

            ws.send(JSON.stringify({
                action: 'announce',
                info_hash: infoHash,
                peer_id: MY_ID,
                offers: [{ offer_id: offerId, offer: peerObj.pc.localDescription }]
            }));
        }

        // --- 6. MEDIA LOGIC ---

        function addTracksToConnection(pc, stream) {
            stream.getTracks().forEach(track => {
                // Check if track already exists to avoid duplication
                const senders = pc.getSenders();
                const hasTrack = senders.some(s => s.track && s.track.kind === track.kind);
                if (!hasTrack) {
                    pc.addTrack(track, stream);
                } else {
                    // Replace track if exists (re-enabling camera)
                    const sender = senders.find(s => s.track && s.track.kind === track.kind);
                    sender.replaceTrack(track);
                }
            });
        }

        document.getElementById('camera-btn').onclick = async () => {
            if (isCameraOn) {
                // Stop Camera
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
                document.getElementById('local-preview').style.display = 'none';
                document.getElementById('camera-btn').textContent = "Start Camera";
                isCameraOn = false;
                
                // Notify peers (Remove tracks or send black frames - simplistic removal here)
                Object.values(peers).forEach(p => {
                    p.pc.getSenders().forEach(s => p.pc.removeTrack(s));
                });
            } else {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    document.getElementById('local-video').srcObject = localStream;
                    document.getElementById('local-preview').style.display = 'block';
                    document.getElementById('camera-btn').textContent = "Stop Camera";
                    isCameraOn = true;

                    // Add to all existing peers
                    Object.values(peers).forEach(p => {
                        addTracksToConnection(p.pc, localStream);
                    });
                } catch(e) { log('Camera fail: ' + e.message, 'err'); }
            }
        };

        // --- 7. CLEANUP & HEARTBEAT ---

        function startHeartbeat(peer) {
            setInterval(() => {
                if (peer.dc.readyState === 'open') {
                    peer.dc.send(JSON.stringify({ type: 'ping' }));
                    
                    // Check timeout (10 seconds)
                    if (Date.now() - peer.lastPing > 10000) {
                        log(`Peer ${peer.id} timed out`, 'err');
                        handleDisconnect(peer.id);
                    }
                }
            }, CONFIG.pingInterval);
        }

        function handleDisconnect(id) {
            if (peers[id]) {
                peers[id].pc.close();
                delete peers[id];
                const v = document.getElementById(`vid-${id}`);
                if (v) v.remove();
                updateStatus();
            }
        }

        function updateStatus() {
            const count = Object.keys(peers).length;
            const el = document.getElementById('status');
            el.innerHTML = count > 0 ? `Connected to ${count} peer(s)` : 'Waiting for peers...';
            el.className = count > 0 ? 'status-ok' : '';
            
            document.getElementById('msg').disabled = count === 0;
            document.getElementById('send-btn').disabled = count === 0;
        }

        // --- 8. CHAT ---
        const sendMsg = () => {
            const inp = document.getElementById('msg');
            const txt = inp.value.trim();
            if (!txt) return;
            Object.values(peers).forEach(p => {
                if(p.dc.readyState === 'open') p.dc.send(JSON.stringify({ type: 'chat', text: txt }));
            });
            log(`You: ${txt}`, 'msg');
            inp.value = '';
        };
        document.getElementById('send-btn').onclick = sendMsg;
        document.getElementById('msg').onkeydown = (e) => e.key === 'Enter' && sendMsg();

        // Start
        initLink();

    </script>
</body>
</html>
