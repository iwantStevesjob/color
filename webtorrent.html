<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTorrent WebRTC MVP</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0f0f12;
            color: #e0e0e0;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #log {
            background: #1a1a1d;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            border: 1px solid #333;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .success {
            color: #4ade80;
        }

        .error {
            color: #f87171;
        }

        .info {
            color: #94a3b8;
        }

        .debug {
            color: #555;
        }

        input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px;
            flex: 1;
            border-radius: 4px;
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
        }

        #chat-controls {
            display: flex;
            gap: 8px;
        }
    </style>
</head>

<body>
    <h2>WebTorrent WebRTC Mesh</h2>
    <div id="status">Connecting...</div>
    <div id="log"></div>
    <div id="chat-controls">
        <input type="text" id="msg" placeholder="Type message..." disabled>
        <button id="send" disabled>Send</button>
    </div>

    <script>
        // CONFIG
        const TRACKERS = [
            'wss://tracker.openwebtorrent.com',
            'wss://tracker.btorrent.xyz',
            'wss://tracker.webtorrent.io'
        ];
        const INFO_HASH_HEX = 'C6D0563C8B7262ACECC4540C647C965709971932'; // SHA1("webrtc-chat-v1")
        const PEER_ID = '-WB0001-' + Math.random().toString(36).substr(2, 12).padEnd(12, '0');

        // STATE
        const activeChannels = new Set();
        const seenPeers = new Set();
        const pendingOffers = {}; // offer_id -> { pc, dc }

        // UTILS
        const logDiv = document.getElementById('log');
        function log(msg, type = 'info') {
            const l = document.createElement('div');
            l.className = type;
            l.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logDiv.appendChild(l);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function hexToBinary(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            return str;
        }
        const INFO_HASH_BINARY = hexToBinary(INFO_HASH_HEX);

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
            ]
        };

        // TRACKER CONNECTION
        TRACKERS.forEach(url => {
            const ws = new WebSocket(url);
            ws.binaryType = 'arraybuffer';
            ws.onopen = () => {
                log(`Connected to ${url}`, 'success');
                announce(ws);
                setInterval(() => announce(ws), 30000); // Re-announce
            };
            ws.onmessage = (e) => {
                try {
                    if (typeof e.data === 'string') handleMessage(ws, JSON.parse(e.data));
                } catch (err) { }
            };
            ws.onerror = () => log(`Tracker error ${url}`, 'error');
        });

        function announce(ws, opts = {}) {
            if (ws.readyState !== WebSocket.OPEN) return;
            const msg = {
                action: 'announce',
                info_hash: INFO_HASH_BINARY,
                peer_id: PEER_ID,
                numwant: 50,
                uploaded: 0, downloaded: 0, left: 0,
                event: opts.event
            };
            if (opts.answer) {
                msg.answer = opts.answer;
                msg.to_peer_id = opts.to_peer_id;
                msg.offer_id = opts.offer_id;
                ws.send(JSON.stringify(msg));
            } else if (opts.offers) {
                msg.offers = opts.offers;
                ws.send(JSON.stringify(msg));
            } else {
                // If just normal announce, include NEW offers to find peers
                generateOffers(3).then(offers => {
                    msg.offers = offers;
                    ws.send(JSON.stringify(msg));
                });
            }
        }

        async function generateOffers(n) {
            const offers = [];
            for (let i = 0; i < n; i++) {
                const pc = new RTCPeerConnection(rtcConfig);
                const dc = pc.createDataChannel('chat'); // We create channel as initiator
                const offerId = Math.random().toString(36).substr(2, 20);

                pendingOffers[offerId] = { pc, dc };

                // Timeout for this offer
                setTimeout(() => {
                    if (pendingOffers[offerId]) {
                        pendingOffers[offerId].pc.close();
                        delete pendingOffers[offerId];
                    }
                }, 45000);

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await waitForIce(pc);

                offers.push({ offer: pc.localDescription, offer_id: offerId });
            }
            return offers;
        }

        async function handleMessage(ws, data) {
            if (data.info_hash !== INFO_HASH_BINARY) return;

            // INCOMING OFFER
            if (data.offer && data.offer_id) {
                if (seenPeers.has(data.peer_id)) return; // Already connected?

                log(`Offer from ${data.peer_id.substr(0, 8)}`, 'info');
                const pc = new RTCPeerConnection(rtcConfig);

                // As receiver, we wait for data channel
                pc.ondatachannel = (e) => setupChannel(e.channel, data.peer_id);

                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await waitForIce(pc);

                announce(ws, {
                    answer: pc.localDescription,
                    to_peer_id: data.peer_id,
                    offer_id: data.offer_id
                });
            }

            // INCOMING ANSWER
            if (data.answer && data.offer_id) {
                const pending = pendingOffers[data.offer_id];
                if (pending) {
                    log(`Answer from ${data.peer_id.substr(0, 8)}`, 'success');
                    const { pc, dc } = pending;
                    setupChannel(dc, data.peer_id);
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    } catch (e) {
                        log('Failed to set remote desc', 'error');
                        pc.close();
                    }
                    delete pendingOffers[data.offer_id];
                }
            }
        }

        function setupChannel(dc, peerId) {
            dc.onopen = () => {
                log(`Channel OPEN: ${peerId.substr(0, 8)}`, 'success');
                activeChannels.add(dc);
                seenPeers.add(peerId);
                updateUI();
            };
            dc.onclose = () => {
                log(`Channel CLOSED: ${peerId.substr(0, 8)}`, 'info');
                activeChannels.delete(dc);
                seenPeers.delete(peerId);
                updateUI();
            };
            dc.onmessage = (e) => {
                const msgLines = document.createElement('div');
                msgLines.textContent = `[${peerId.substr(0, 8)}] ${e.data}`;
                msgLines.style.color = '#fff';
                logDiv.appendChild(msgLines);
                logDiv.scrollTop = logDiv.scrollHeight;
            };
        }

        function waitForIce(pc) {
            return new Promise(resolve => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const check = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', check);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 3000);
                }
            });
        }

        function updateUI() {
            const count = activeChannels.size;
            document.getElementById('status').textContent = `Connected Peers: ${count}`;
            document.getElementById('msg').disabled = count === 0;
            document.getElementById('send').disabled = count === 0;
        }

        document.getElementById('send').onclick = () => {
            const input = document.getElementById('msg');
            const text = input.value;
            if (!text) return;

            activeChannels.forEach(dc => {
                if (dc.readyState === 'open') dc.send(text);
            });

            const localMsg = document.createElement('div');
            localMsg.textContent = `[Me] ${text}`;
            localMsg.style.color = '#aaf';
            logDiv.appendChild(localMsg);
            logDiv.scrollTop = logDiv.scrollHeight;
            input.value = '';
        };

        document.getElementById('msg').onkeypress = (e) => {
            if (e.key === 'Enter') document.getElementById('send').click();
        };

    </script>
</body>

</html>
