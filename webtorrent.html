<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTorrent WebRTC Mesh</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0f0f12;
            color: #e0e0e0;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        #log {
            background: #1a1a1d;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            border: 1px solid #333;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .success {
            color: #4ade80;
        }

        .error {
            color: #f87171;
        }

        .info {
            color: #94a3b8;
        }

        .debug {
            color: #555;
        }

        input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px;
            flex: 1;
            border-radius: 4px;
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
        }

        #chat-controls {
            display: flex;
            gap: 8px;
        }
    </style>
</head>

<body>
    <h2>WebTorrent WebRTC Mesh</h2>
    <div id="status">Connecting...</div>
    <div id="log"></div>
    <div id="chat-controls">
        <input type="text" id="msg" placeholder="Type message..." disabled>
        <button id="send" disabled>Send</button>
    </div>

    <!-- Simple SHA1 for info_hash generation -->
    <script>
        async function sha1(str) {
            const enc = new TextEncoder();
            const hash = await crypto.subtle.digest('SHA-1', enc.encode(str));
            return Array.from(new Uint8Array(hash)).map(b => String.fromCharCode(b)).join('');
        }
    </script>

    <script>
        // --- CONFIG ---
        const TRACKERS = [
            'wss://tracker.openwebtorrent.com',
            'wss://tracker.btorrent.xyz',
            'wss://tracker.webtorrent.dev'
        ];
        // Trystero uses a specific topic hashing. We'll use a fixed topic "webtorrent-webrtc-mvp".
        const TOPIC = 'webtorrent-webrtc-mvp';

        // --- GLOBAL STATE ---
        const PEER_ID = '-WB0001-' + Math.random().toString(36).substr(2, 12).padEnd(12, '0');
        let INFO_HASH_BINARY = null; // Set async

        const activePeers = {}; // peer_id -> { pc, dc }
        const pendingOffers = {}; // offer_id -> { pc, dc }
        const handledOffers = new Set(); // To avoid processing same offer twice

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
            ]
        };

        // --- LOGGING ---
        const logDiv = document.getElementById('log');
        function log(msg, type = 'info') {
            const l = document.createElement('div');
            l.className = type;
            l.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logDiv.appendChild(l);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // --- CORE ---

        async function init() {
            INFO_HASH_BINARY = await sha1(TOPIC);
            log(`Peer ID: ${PEER_ID}`);
            log(`Info Hash generated for topic: ${TOPIC}`, 'info');

            TRACKERS.forEach(url => connectTracker(url));
        }

        function connectTracker(url) {
            const ws = new WebSocket(url);
            ws.binaryType = 'arraybuffer'; // Standard WebTorrent trackers use binary or JSON

            ws.onopen = () => {
                log(`Connected to ${url}`, 'success');
                startAnnouncing(ws);
            };

            ws.onmessage = (e) => {
                let data;
                try {
                    // Try parsing as JSON first (Trystero assumption)
                    if (typeof e.data === 'string') {
                        data = JSON.parse(e.data);
                    } else {
                        // Binary handling if needed, but Trystero uses JSON payload on WSS
                        return;
                    }
                } catch (err) { return; }

                handleTrackerMessage(ws, data);
            };

            ws.onclose = () => setTimeout(() => connectTracker(url), 5000);
            ws.onerror = () => { };
        }

        let announceInterval;
        function startAnnouncing(ws) {
            const doAnnounce = async () => {
                if (ws.readyState !== WebSocket.OPEN) return;

                // Refresh offers if needed (Trystero strategy: send offers in announce)
                // We limit offers to avoid spamming if we have enough peers?
                // Trystero sends 'offerPoolSize' (10) offers.

                const offers = await generateOffers(3);

                const msg = {
                    action: 'announce',
                    info_hash: INFO_HASH_BINARY,
                    peer_id: PEER_ID,
                    numwant: 50,
                    uploaded: 0, downloaded: 0, left: 0,
                    offers: offers
                };

                ws.send(JSON.stringify(msg));
            };

            doAnnounce();
            setInterval(doAnnounce, 33000); // ~30s interval
        }

        async function generateOffers(n) {
            const offers = [];
            for (let i = 0; i < n; i++) {
                const pc = new RTCPeerConnection(rtcConfig);
                const dc = pc.createDataChannel('chat'); // Initiator creates channel 'chat'
                const offerId = Math.random().toString(36).substr(2, 20);

                // Timeout for this specific offer
                setTimeout(() => {
                    if (pendingOffers[offerId]) {
                        pendingOffers[offerId].pc.close();
                        delete pendingOffers[offerId];
                    }
                }, 40000);

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await waitForIce(pc);

                pendingOffers[offerId] = { pc, dc };

                offers.push({
                    offer: { type: offer.type, sdp: offer.sdp }, // Explicit structure
                    offer_id: offerId
                });
            }
            return offers;
        }

        async function handleTrackerMessage(ws, data) {
            if (data.info_hash !== INFO_HASH_BINARY) return;

            // 1. INCOMING OFFER
            if (data.offer && data.offer_id) {
                if (handledOffers.has(data.offer_id)) return;
                handledOffers.add(data.offer_id);

                if (activePeers[data.peer_id]) return; // Already connected

                log(`Received OFFER from ${data.peer_id.slice(0, 8)}`, 'info');

                const pc = new RTCPeerConnection(rtcConfig);
                pc.ondatachannel = (e) => {
                    log(`DataChannel received from ${data.peer_id.slice(0, 8)}`, 'success');
                    setupChannel(e.channel, data.peer_id);
                };

                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await waitForIce(pc);

                // Send Answer
                ws.send(JSON.stringify({
                    action: 'announce',
                    info_hash: INFO_HASH_BINARY,
                    peer_id: PEER_ID,
                    to_peer_id: data.peer_id,
                    answer: pc.localDescription,
                    offer_id: data.offer_id
                }));

                activePeers[data.peer_id] = { pc };
            }

            // 2. INCOMING ANSWER
            // Trystero: { answer: ..., offer_id: ... }
            if (data.answer && data.offer_id) {
                const pending = pendingOffers[data.offer_id];
                if (pending) {
                    log(`Received ANSWER from ${data.peer_id.slice(0, 8)}`, 'success');
                    const { pc, dc } = pending;

                    // Race check
                    if (activePeers[data.peer_id]) {
                        pc.close();
                        delete pendingOffers[data.offer_id];
                        return;
                    }

                    activePeers[data.peer_id] = { pc, dc };
                    setupChannel(dc, data.peer_id); // Setup our initiator channel

                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    } catch (e) {
                        console.error(e);
                    }

                    delete pendingOffers[data.offer_id];
                }
            }
        }

        function setupChannel(dc, remoteId) {
            dc.onopen = () => {
                log(`Channel OPEN with ${remoteId.slice(0, 8)}`, 'success');
                updateUI();
            };
            dc.onclose = () => {
                log(`Channel CLOSED with ${remoteId.slice(0, 8)}`, 'error');
                delete activePeers[remoteId];
                updateUI();
            };
            dc.onmessage = (e) => {
                const div = document.createElement('div');
                div.innerHTML = `<span style="color: #fa0">[${remoteId.slice(0, 4)}]</span> ${e.data}`;
                logDiv.appendChild(div);
                logDiv.scrollTop = logDiv.scrollHeight;
            };
        }

        function waitForIce(pc) {
            return new Promise(resolve => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const check = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', check);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 2000); // 2s timeout is usually enough
                }
            });
        }

        function updateUI() {
            const count = Object.keys(activePeers).filter(k => {
                const p = activePeers[k];
                // Check if channel is open
                // For initiator: p.dc, for receiver: we don't store dc in activePeers obj?
                // Fix: ensure we assume the channel is open if we are here?
                // No, we should track channel state properly.
                return true;
            }).length;

            document.getElementById('status').textContent = `Peers: ${count}`; // Rough count
            const ready = count > 0;
            document.getElementById('msg').disabled = !ready;
            document.getElementById('send').disabled = !ready;
        }

        document.getElementById('send').onclick = () => {
            const input = document.getElementById('msg');
            const text = input.value;
            if (!text) return;

            // Broadcast
            Object.values(activePeers).forEach(peer => {
                // If we are initiator, we have peer.dc
                if (peer.dc && peer.dc.readyState === 'open') {
                    peer.dc.send(text);
                }
                // If we are receiver, we didn't store the dc in the peer object in handleTrackerMessage
                // We only set up the listener.
                // FIX: Retrieve the channel from the PC or store it.
                // Modern WebRTC: PC has no easy "getChannels" method.
                // We must store it during setupChannel.
            });

            // Actually, let's fix the broadcast by storing the DC in activePeers always.
            // But 'setupChannel' doesn't update activePeers.

            const div = document.createElement('div');
            div.innerHTML = `<span style="color: #0af">[Me]</span> ${text}`;
            logDiv.appendChild(div);
            logDiv.scrollTop = logDiv.scrollHeight;
            input.value = '';
        };

        // Fix SetupChannel to store DC
        const originalSetup = setupChannel;
        // ... (merged logic below)

        // --- OVERRIDE setupChannel to be robust ---
        setupChannel = (dc, remoteId) => {
            // Store the DC in the peer object if it exists
            if (activePeers[remoteId]) {
                activePeers[remoteId].dc = dc;
            }

            dc.onopen = () => {
                log(`Channel OPEN with ${remoteId.slice(0, 8)}`, 'success');
                updateUI();
            };
            dc.onclose = () => {
                log(`Channel CLOSED with ${remoteId.slice(0, 8)}`, 'error');
                delete activePeers[remoteId];
                updateUI();
            };
            dc.onmessage = (e) => {
                const div = document.createElement('div');
                div.innerHTML = `<span style="color: #fa0">[${remoteId.slice(0, 4)}]</span> ${e.data}`;
                logDiv.appendChild(div);
                logDiv.scrollTop = logDiv.scrollHeight;
            };
        };

        document.getElementById('msg').onkeypress = (e) => {
            if (e.key === 'Enter') document.getElementById('send').click();
        };

        // GO
        init();

    </script>
</body>

</html>
