<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative P2P Notes</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        #notes-container {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 10px;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            font-size: 16px;
            line-height: 1.3;
        }
        #notes-display {
            width: 100%;
            height: calc(100% - 30px);
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            outline: none;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #notes-display img {
            max-width: 100%;
            height: auto;
        }
        #status {
            height: 20px;
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="notes-container">
        <div id="notes-display" contenteditable="true"></div>
        <div id="status">Status: Initializing...</div>
    </div>

    <script>
        const display = document.getElementById('notes-display');
        const statusElement = document.getElementById('status');
        let peer, conn, connections = [];
        let lastSyncedContent = '';
        let localVersion = new VersionVector();
        let clientId = generateUniqueId();

        class TextOperation {
            constructor(ops) {
                this.ops = ops;
            }

            static insert(pos, text) {
                return new TextOperation([{ insert: { pos, text } }]);
            }

            static delete(pos, length) {
                return new TextOperation([{ delete: { pos, length } }]);
            }

            apply(text) {
                let result = text;
                for (let op of this.ops) {
                    if (op.insert) {
                        result = result.slice(0, op.insert.pos) + op.insert.text + result.slice(op.insert.pos);
                    } else if (op.delete) {
                        result = result.slice(0, op.delete.pos) + result.slice(op.delete.pos + op.delete.length);
                    }
                }
                return result;
            }
        }

        class VersionVector {
            constructor() {
                this.vector = new Map();
            }

            increment(clientId) {
                this.vector.set(clientId, (this.vector.get(clientId) || 0) + 1);
            }

            merge(other) {
                for (let [clientId, version] of other.vector.entries()) {
                    if (!this.vector.has(clientId) || this.vector.get(clientId) < version) {
                        this.vector.set(clientId, version);
                    }
                }
            }

            isNewer(other) {
                for (let [clientId, version] of this.vector.entries()) {
                    if (!other.vector.has(clientId) || other.vector.get(clientId) < version) {
                        return true;
                    }
                }
                return false;
            }
        }

        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function initNotes() {
            display.innerHTML = localStorage.getItem('notesContent') || '';
            lastSyncedContent = display.innerHTML;
        }

        function mergeContent(baseContent, localChanges, remoteChanges) {
            let mergedContent = baseContent;
            mergedContent = localChanges.apply(mergedContent);
            mergedContent = remoteChanges.apply(mergedContent);
            return mergedContent;
        }

        function getOperationsSinceLastSync(oldContent, newContent) {
            // This is a simplified diff algorithm. In a real-world scenario,
            // you'd want to use a more sophisticated diff algorithm.
            if (oldContent === newContent) return new TextOperation([]);
            
            let ops = [];
            let i = 0;
            while (i < oldContent.length && i < newContent.length && oldContent[i] === newContent[i]) i++;
            
            if (i < oldContent.length) {
                ops.push({ delete: { pos: i, length: oldContent.length - i } });
            }
            
            if (i < newContent.length) {
                ops.push({ insert: { pos: i, text: newContent.slice(i) } });
            }
            
            return new TextOperation(ops);
        }

        function handleIncomingData(data) {
            if (data.version && data.operations) {
                if (data.version.isNewer(localVersion)) {
                    const remoteChanges = new TextOperation(data.operations);
                    const localChanges = getOperationsSinceLastSync(lastSyncedContent, display.innerHTML);
                    
                    const mergedContent = mergeContent(lastSyncedContent, localChanges, remoteChanges);
                    
                    display.innerHTML = mergedContent;
                    lastSyncedContent = mergedContent;
                    localVersion.merge(data.version);
                    
                    localStorage.setItem('notesContent', mergedContent);
                    updateStatus('Changes merged');
                } else {
                    updateStatus('Received outdated changes, discarded');
                }
            }
        }

        function broadcastData() {
            const content = display.innerHTML;
            if (content !== lastSyncedContent) {
                const operations = getOperationsSinceLastSync(lastSyncedContent, content);
                localVersion.increment(clientId);
                const dataWithVersion = {
                    operations: operations.ops,
                    version: localVersion
                };
                connections.forEach(conn => {
                    if (conn.open) {
                        conn.send(dataWithVersion);
                    }
                });
                lastSyncedContent = content;
                localStorage.setItem('notesContent', content);
                updateStatus('Changes sent');
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function initPeerJS() {
            const hash = window.location.hash;

            if (!hash) {
                // Desktop (Server) Code
                peer = new Peer();
                peer.on('open', (id) => {
                    console.log(`Desktop peer ID: ${id}`);
                    window.location.hash = id;
                    updateStatus('Connected as desktop');
                });

                peer.on('connection', (connection) => {
                    connections.push(connection);
                    connection.on('data', handleIncomingData);
                    connection.on('open', () => {
                        updateStatus('Client connected');
                        // Send the current content to the newly connected peer
                        broadcastData();
                    });
                    connection.on('close', () => {
                        connections = connections.filter(conn => conn !== connection);
                        updateStatus('Client disconnected');
                    });
                });
            } else {
                // Mobile (Client) Code
                const remotePeerId = hash.slice(1);
                peer = new Peer();
                
                peer.on('open', (id) => {
                    console.log(`Mobile peer ID: ${id}`);
                    connectToPeer(remotePeerId);
                });
            }

            peer.on('error', (err) => {
                console.error('PeerJS Error:', err);
                updateStatus('Connection error');
            });
        }

        function connectToPeer(peerId) {
            conn = peer.connect(peerId);
            conn.on('open', () => {
                console.log('Connected to desktop');
                updateStatus('Connected to desktop');
                broadcastData(); // Send initial content
            });
            conn.on('data', handleIncomingData);
            conn.on('close', () => {
                console.log('Connection closed, attempting to reconnect...');
                updateStatus('Disconnected, reconnecting...');
                setTimeout(() => connectToPeer(peerId), 3000);
            });
        }

        function updateStatus(message) {
            statusElement.textContent = `Status: ${message}`;
        }

        window.addEventListener('load', () => {
            initNotes();
            initPeerJS();
        });

        display.addEventListener('input', debounce(() => {
            broadcastData();
        }, 300));

        window.addEventListener('online', () => {
            updateStatus('Online, reconnecting...');
            initPeerJS();
        });

        window.addEventListener('offline', () => {
            updateStatus('Offline');
        });
    </script>
</body>
</html>
