
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive HSV Color Wheel</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: white; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, circle;
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            camera.position.z = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setClearColor(0xffffff, 0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geometry = new THREE.CircleGeometry(1, 64);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float uTime;

                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }

                    void main() {
                        vec2 center = vec2(0.5, 0.5);
                        vec2 pos = vUv - center;
                        float angle = atan(pos.y, pos.x);
                        float radius = length(pos) * 2.0;

                        float hue = (angle / (2.0 * 3.14159) + 0.5 + uTime) % 1.0;
                        float saturation = radius;
                        float value = 1.0;

                        vec3 rgb = hsv2rgb(vec3(hue, saturation, value));

                        if (radius > 1.0) discard;
                        gl_FragColor = vec4(rgb, 1.0);
                    }
                `
            });

            circle = new THREE.Mesh(geometry, material);
            scene.add(circle);

            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onMouseDown(event) {
            isMouseDown = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            circle.material.uniforms.uTime.value += deltaMove.x * 0.001;

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isMouseDown = false;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            let width, height;
            if (aspect > 1) {
                width = 1;
                height = 1 / aspect;
            } else {
                width = aspect;
                height = 1;
            }
            camera.left = -width;
            camera.right = width;
            camera.top = height;
            camera.bottom = -height;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>