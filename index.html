<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
    <!-- CSS Remains Exactly as provided -->
    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --ui-bg: rgba(255, 255, 255, 0.1);
            --ui-border: rgba(255, 255, 255, 0.2);
            --nav-color: white;
            --tracker-bg: rgba(0, 0, 0, 0.75);
            --nav-height: 90px;
            --sub-nav-height: 150px;
            --sliver-height: 10px;
        }

        body.light-mode {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --ui-bg: rgba(0, 0, 0, 0.1);
            --ui-border: rgba(0, 0, 0, 0.2);
            --nav-color: black;
            --tracker-bg: transparent;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.1s linear;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        #flash-overlay.active {
            opacity: 1;
            transition: none;
        }

        #login-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.5s ease, visibility 0s linear 0.5s;
            color: inherit;
        }

        #login-card.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.5s ease;
        }

        #color-hex {
            font-size: 5rem;
            font-weight: 900;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            line-height: 1;
        }

        #room-status {
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            margin: 15px 0 25px 0;
            opacity: 0.7;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-height: 1.2em;
            font-weight: bold;
        }

        #login-btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 12px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-decoration: none;
        }

        #login-btn:hover {
            background: currentColor;
            opacity: 0.8;
        }

        #login-btn:hover span {
            filter: invert(1);
        }

        #login-btn.hidden {
            display: none;
        }

        #hover-trigger {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--sliver-height);
            z-index: 300;
            display: none;
        }

        #top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--nav-height);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            z-index: 150;
            opacity: 0;
            pointer-events: none;
        }

        #top-nav.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-item {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            opacity: 0.5;
            transition: 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--nav-color);
            border-bottom: 2px solid transparent;
            padding-bottom: 2px;
        }

        .nav-item:hover,
        .nav-item.active {
            opacity: 1;
        }

        .nav-item.active {
            border-bottom-color: var(--nav-color);
        }

        #sub-nav-layer {
            position: fixed;
            top: var(--nav-height);
            left: 0;
            width: 100%;
            height: var(--sub-nav-height);
            z-index: 140;
            pointer-events: none;
        }

        .sub-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px 40px 0 40px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            opacity: 0;
            transition: opacity 0s;
        }

        .sub-header.active {
            opacity: 1;
            pointer-events: auto;
        }

        .page-title {
            font-size: 3rem;
            font-weight: 900;
            margin: 0 0 15px 0;
            letter-spacing: -1px;
            color: var(--text-color);
        }

        .tabs-row {
            display: flex;
            gap: 2px;
            width: 100%;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs-row::-webkit-scrollbar {
            display: none;
        }

        .sub-tab {
            padding: 12px 24px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s ease;
            user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .sub-tab:hover {
            color: white;
            background: rgba(0, 0, 0, 0.7);
        }

        .sub-tab.active {
            background: white;
            color: black;
            cursor: default;
        }

        #dashboard-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            will-change: transform;
        }

        #dashboard-panel.active {
            transform: translateY(var(--sliver-height));
        }

        #dashboard-panel.active.revealed {
            transform: translateY(var(--nav-height));
        }

        #dashboard-panel.active.step-down {
            transform: translateY(calc(var(--nav-height) + var(--sub-nav-height)));
        }

        #dashboard-panel.active.peek-mode {
            transform: translateY(calc(100% - 50px));
        }

        .content-view {
            flex: 1;
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .content-view.active {
            display: flex;
        }

        .settings-pane,
        .apps-pane {
            display: none;
            padding: 40px;
            color: #333;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        .settings-pane.active,
        .apps-pane.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #tools {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 10px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 205;
        }

        #tools.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #tools button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
            font-weight: bold;
        }

        #debug-btn,
        #freeze-btn {
            position: absolute;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            z-index: 180;
        }

        #debug-btn {
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Menlo', monospace;
            font-size: 0.8rem;
        }

        #debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #debug-btn.active {
            background: rgba(255, 0, 0, 0.5);
            border-color: red;
            color: white;
        }

        #freeze-btn {
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        #settings-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 30px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            pointer-events: auto;
        }

        #debug-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 10px;
            z-index: 2000;
            color: #0f0;
            font-family: 'Menlo', monospace;
            font-size: 12px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
        }

        #debug-panel.visible {
            display: block;
        }

        #debug-rooms {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .debug-room-item {
            padding: 4px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .debug-room-item .count {
            color: #fff;
            font-weight: bold;
        }

        .debug-room-item.active {
            color: #00e676;
        }

        #reset-btn {
            margin-top: 10px;
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
        }

        #reset-btn:hover {
            background: #900;
        }

        .sphere-tooltip {
            position: absolute;
            display: none;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-Family: monospace;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(15px, 15px);
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
        }

        .sphere-tooltip .hex {
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            margin-bottom: 2px;
            display: block;
        }

        .sphere-tooltip .meta {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sphere-tooltip .meta.online {
            color: #00e676;
            font-weight: bold;
        }

        #chat-header {
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-family: -apple-system, system-ui, sans-serif;
            flex-shrink: 0;
            color: #1a1a1a;
            cursor: ns-resize;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 10px;
            transition: background 0.2s;
        }

        .status:hover {
            background: #eee;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .dot.on {
            background: #00e676;
            box-shadow: 0 0 5px #00e676;
        }

        #user-badge {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #999;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #fff;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow-anchor: none;
        }

        #display {
            min-height: 100%;
            outline: none;
            padding: 40px 60px;
            font-size: 16px;
            line-height: 24px;
            position: relative;
        }

        .editor-line {
            min-height: 24px;
            display: block;
            padding-left: 5px;
            border-left: 4px solid transparent;
            white-space: pre-wrap;
            transition: border-left-color 0.4s ease;
        }


        .editor-line:hover,
        .editor-line.group-hover {
            border-left-color: var(--owner-color, transparent);
        }

        .locked-line {
            position: relative;
        }

        .locked-line::before {
            content: attr(data-lock-owner);
            position: absolute;
            left: 0;
            top: 0;
            transform: translateX(-100%);
            height: 100%;
            background-color: var(--lock-color);
            color: transparent;
            font-family: sans-serif;
            font-size: 10px;
            white-space: nowrap;
            width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px 0 0 2px;
            pointer-events: auto;
            transition: width 0.3s, opacity 0.1s;
            z-index: 10;
        }

        .locked-line:hover::before {
            width: 20px;
            opacity: 1;
            color: transparent;
        }

        .locked-line::before:hover {
            width: 60px !important;
            padding: 0 6px;
            color: #fff !important;
            z-index: 999;
        }

        #minimap {
            position: absolute;
            right: 5px;
            top: 60px;
            bottom: 0;
            width: 12px;
            z-index: 201;
            pointer-events: none;
        }

        .scroll-dot {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: top 0.1s ease-out;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        #tracker {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 25px;
            background: var(--tracker-bg);
            border: 1px solid var(--ui-border);
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 10;
            pointer-events: none;
        }

        body.light-mode #tracker {
            display: none;
        }

        .cone-data {
            display: flex;
            gap: 8px;
            font-size: 11px;
            font-family: 'Menlo', monospace;
            color: rgba(255, 255, 255, 0.6);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
            pointer-events: auto;
            cursor: default;
        }

        .cone-data:last-child {
            border-right: none;
            padding-right: 0;
        }

        .cone-title {
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
        }

        .coord-val {
            color: white;
            min-width: 38px;
            cursor: ns-resize;
        }

        @media (max-width: 768px) {
            .sub-header {
                padding-right: 0 !important;
            }

            #tracker {
                flex-direction: column !important;
                height: auto !important;
                padding: 15px !important;
                border-radius: 20px !important;
                gap: 10px !important;
                align-items: center !important;
            }

            .cone-data {
                border-right: none !important;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                padding-right: 0 !important;
                padding-bottom: 8px;
                width: 100%;
                justify-content: space-between;
            }

            .cone-data:last-child {
                border-bottom: none;
            }
        }

        .dummy-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333;
            font-weight: 900;
            font-size: 3rem;
            letter-spacing: -1px;
        }
    </style>
</head>

<body class="light-mode">
    <canvas id="gpu-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="hover-trigger"></div>

    <nav id="top-nav">
        <div class="nav-item active" data-target="home">Home</div>
        <div class="nav-item" data-target="apps">BLOCKS</div>
        <div class="nav-item" data-target="connect">CONNECT</div>
        <div id="settings-btn">
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor" stroke="none">
                <path
                    d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.58-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.488.488 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z" />
            </svg>
        </div>
    </nav>

    <div id="login-card">
        <div id="color-hex">#FFFFFF</div>
        <div id="room-status">Initializing...</div>
        <button id="login-btn"><span>LOGIN</span></button>
    </div>

    <button id="debug-btn">DEBUG OFF</button>
    <div id="debug-panel">
        <h3>System Tools</h3>
        <div
            style="background: #330000; padding: 10px; border: 1px solid #ff4444; margin-bottom: 15px; border-radius: 4px;">
            <h4 style="margin: 0 0 5px 0; color: #ff4444;">ðŸ”’ Master Security</h4>
            <div id="security-status" style="font-size: 11px; margin-bottom: 8px; color: #aaa;">STATUS: <b>UNSECURED</b>
            </div>
            <input type="password" id="master-pass" placeholder="Type Password to Lock/Unlock"
                style="width: 100%; background: #000; border: 1px solid #555; color: white; padding: 5px; margin-bottom: 5px;">
            <button id="btn-security-apply"
                style="width: 100%; background: #444; border: 1px solid #666; color: white; cursor: pointer;">APPLY
                PASSWORD</button>
        </div>
        <button id="reset-btn">WIPE ALL DATA</button>
        <h4>Discovered Rooms</h4>
        <div id="debug-rooms"></div>
    </div>

    <div id="sub-nav-layer">
        <div id="header-apps" class="sub-header">
            <h1 class="page-title">APPS</h1>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="discover" data-group="apps">DISCOVER</div>
                <div class="sub-tab" data-tab="installed" data-group="apps">INSTALLED</div>
                <div class="sub-tab" data-tab="updates" data-group="apps">UPDATES</div>
            </div>
        </div>
        <div id="header-settings" class="sub-header">
            <h1 class="page-title">SETTINGS</h1>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="general" data-group="settings">GENERAL</div>
                <div class="sub-tab" data-tab="connections" data-group="settings">CONNECTIONS</div>
                <div class="sub-tab" data-tab="signatures" data-group="settings">SIGNATURES</div>
                <div class="sub-tab" data-tab="raw" data-group="settings">RAW DATA</div>
            </div>
        </div>
    </div>

    <div id="dashboard-panel">
        <div id="view-home" class="content-view active">
            <div id="chat-header">
                <div><span id="user-badge" title="Your Color"></span></div>
                <div class="status" id="status-toggle"><span class="dot"></span><span
                        id="peer-count">Disconnected</span></div>
            </div>
            <div id="chat-container">
                <div id="display" contenteditable="true" spellcheck="false"></div>
            </div>
            <div id="minimap"></div>
        </div>
        <div id="view-apps" class="content-view">
            <div id="tab-discover" class="apps-pane active">
                <h2>Discover Apps</h2>
                <div class="dummy-content">APPS STORE</div>
            </div>
            <div id="tab-installed" class="apps-pane">
                <h2>Installed</h2>
            </div>
            <div id="tab-updates" class="apps-pane">
                <h2>Updates</h2>
            </div>
        </div>
        <div id="view-settings" class="content-view">
            <div id="tab-general" class="settings-pane active">
                <h2>General Settings</h2>
            </div>
            <div id="tab-connections" class="settings-pane">
                <h2>Network Connections</h2>
            </div>
            <div id="tab-signatures" class="settings-pane">
                <h2>Cryptographic Signatures</h2>
            </div>
            <div id="tab-raw" class="settings-pane">
                <h2>Raw Data Inspector</h2>
            </div>
        </div>
    </div>

    <div id="tools">
        <button id="btn-bold">B</button>
        <button id="btn-italic">I</button>
        <button id="btn-link">ðŸ”—</button>
    </div>

    <div id="freeze-btn"><svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none"
            stroke-width="2">
            <path d="M9 18h6" />
            <path d="M10 22h4" />
            <path
                d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" />
        </svg></div>
    <div id="tracker">
        <div class="cone-data" id="data-0"></div>
        <div class="cone-data" id="data-1"></div>
        <div class="cone-data" id="data-2"></div>
    </div>

    <script type="module">
        const TRACKERS = ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebtorrent.com', 'wss://tracker.btorrent.xyz'];
        const OFFER_POOL_SIZE = 10;
        const OFFER_TTL = 57_333;
        const ANNOUNCE_INTERVAL = 33_333;
        const ICE_TIMEOUT = 5000;
        const RTC_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }, { urls: 'stun:stun2.l.google.com:19302' }, { urls: 'stun:stun.cloudflare.com:3478' }] };
        const charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';
        const genId = n => Array(n).fill().map(() => charSet[Math.floor(Math.random() * charSet.length)]).join('');
        const encoder = new TextEncoder();
        async function sha1Hash(str) { const hashBuffer = await crypto.subtle.digest('SHA-1', encoder.encode(str)); return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(36)).join('').slice(0, 20); }
        const selfId = genId(20);

        function waitForIce(pc) { return Promise.race([new Promise(resolve => { const checkState = () => { if (pc.iceGatheringState === 'complete') { pc.removeEventListener('icegatheringstatechange', checkState); resolve(); } }; pc.addEventListener('icegatheringstatechange', checkState); checkState(); }), new Promise(resolve => setTimeout(resolve, ICE_TIMEOUT))]).then(() => ({ type: pc.localDescription.type, sdp: pc.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, '') })); }

        function createPeerConnection(isInitiator, onDataChannel, connectedPeersRef = null, peerLeaveCallbacksRef = null) {
            const pc = new RTCPeerConnection(RTC_CONFIG);
            let dc = null;
            if (isInitiator) { dc = pc.createDataChannel('data'); dc.binaryType = 'arraybuffer'; } else { pc.ondatachannel = e => { dc = e.channel; dc.binaryType = 'arraybuffer'; onDataChannel?.(dc); }; }
            pc.onconnectionstatechange = () => { if (pc.connectionState === 'closed' && connectedPeersRef) for (const [peerId, peer] of Object.entries(connectedPeersRef)) if (peer.pc === pc) { delete connectedPeersRef[peerId]; peerLeaveCallbacksRef?.forEach(cb => cb(peerId)); break; } };
            return { pc, dc };
        }
        async function createOffer(connectedPeersRef = null, peerLeaveCallbacksRef = null) { const { pc, dc } = createPeerConnection(true, null, connectedPeersRef, peerLeaveCallbacksRef); const offerId = genId(20); await pc.setLocalDescription(await pc.createOffer()); const offer = await waitForIce(pc); return { pc, dc, offer, offerId, created: Date.now() }; }

        function joinRoom(config, roomId) {
            const connectedPeers = {}, pendingOffers = {}, handledOffers = new Set(), trackerSockets = {}, peerJoinCallbacks = [], peerLeaveCallbacks = [], actionHandlers = {}, announceIntervals = [];
            let offerPool = [], infoHash = null, isLeaving = false, readyResolve;
            const readyPromise = new Promise(resolve => { readyResolve = resolve; });

            async function fillOfferPool() { const needed = OFFER_POOL_SIZE - offerPool.length; if (needed > 0) offerPool.push(...await Promise.all(Array(needed).fill().map(() => createOffer(connectedPeers, peerLeaveCallbacks)))); }
            function getOffersFromPool(n) { const now = Date.now(); offerPool = offerPool.filter(o => now - o.created <= OFFER_TTL); const taken = offerPool.splice(0, n); fillOfferPool(); return taken; }
            function setupDataChannel(dc, peerId) {
                const handleOpen = () => peerJoinCallbacks.forEach(cb => cb(peerId));
                if (dc.readyState === 'open') handleOpen(); else dc.onopen = handleOpen;
                dc.onclose = () => { delete connectedPeers[peerId]; peerLeaveCallbacks.forEach(cb => cb(peerId)); };
                dc.onmessage = e => { try { const msg = JSON.parse(e.data); if (msg.action && actionHandlers[msg.action]) actionHandlers[msg.action].forEach(cb => cb(msg.data, peerId)); } catch (err) { } };
            }
            function sendToAllPeers(action, data, targetPeerId = null) {
                const message = JSON.stringify({ action, data });
                for (const [peerId, peer] of Object.entries(connectedPeers)) { if (targetPeerId && peerId !== targetPeerId) continue; if (peer.dc && peer.dc.readyState === 'open') try { peer.dc.send(message); } catch (e) { } }
            }
            function connectToTracker(url) {
                if (isLeaving) return;
                const ws = new WebSocket(url); trackerSockets[url] = ws;
                ws.onopen = () => startAnnouncing(ws, url);
                ws.onmessage = e => { try { const data = JSON.parse(e.data); if (data) handleTrackerMessage(ws, data); } catch (err) { } };
                ws.onclose = () => { delete trackerSockets[url]; if (!isLeaving) setTimeout(() => connectToTracker(url), 5000); };
            }
            async function startAnnouncing(ws, url) {
                await readyPromise;
                const announce = async () => {
                    if (ws.readyState !== WebSocket.OPEN || isLeaving || !infoHash) return;
                    const offers = getOffersFromPool(3);
                    if (offers.length === 0) return;
                    for (const o of offers) { pendingOffers[o.offerId] = { pc: o.pc, dc: o.dc, created: o.created }; setTimeout(() => { if (pendingOffers[o.offerId]) { pendingOffers[o.offerId].pc.close(); delete pendingOffers[o.offerId]; } }, OFFER_TTL); }
                    ws.send(JSON.stringify({ action: 'announce', info_hash: infoHash, peer_id: selfId, numwant: OFFER_POOL_SIZE, offers: offers.map(o => ({ offer_id: o.offerId, offer: { type: o.offer.type, sdp: o.offer.sdp } })) }));
                };
                await announce(); announceIntervals.push(setInterval(announce, ANNOUNCE_INTERVAL));
            }
            async function handleTrackerMessage(ws, data) {
                await readyPromise;
                if (data.info_hash !== infoHash || data.peer_id === selfId) return;
                if (data.offer && data.offer_id) {
                    if (handledOffers.has(data.offer_id) || connectedPeers[data.peer_id]) return;
                    handledOffers.add(data.offer_id);
                    if (Object.values(pendingOffers).some(p => p.peerId === data.peer_id) && selfId > data.peer_id) return;
                    try {
                        const peerEntry = { pc: null, dc: null }; connectedPeers[data.peer_id] = peerEntry;
                        const { pc, dc } = createPeerConnection(false, channel => { if (connectedPeers[data.peer_id]) connectedPeers[data.peer_id].dc = channel; else connectedPeers[data.peer_id] = { pc: pc, dc: channel }; setupDataChannel(channel, data.peer_id); }, connectedPeers, peerLeaveCallbacks);
                        peerEntry.pc = pc; await pc.setRemoteDescription(new RTCSessionDescription(data.offer)); await pc.setLocalDescription(await pc.createAnswer());
                        ws.send(JSON.stringify({ action: 'announce', info_hash: infoHash, peer_id: selfId, to_peer_id: data.peer_id, offer_id: data.offer_id, answer: await waitForIce(pc) }));
                    } catch (err) { delete connectedPeers[data.peer_id]; }
                }
                if (data.answer && data.offer_id) {
                    const pending = pendingOffers[data.offer_id];
                    if (!pending || connectedPeers[data.peer_id]) return;
                    try {
                        connectedPeers[data.peer_id] = { pc: pending.pc, dc: pending.dc }; setupDataChannel(pending.dc, data.peer_id);
                        await pending.pc.setRemoteDescription(new RTCSessionDescription(data.answer)); delete pendingOffers[data.offer_id];
                    } catch (err) { pending.pc.close(); delete pendingOffers[data.offer_id]; delete connectedPeers[data.peer_id]; }
                }
            }
            TRACKERS.forEach(url => connectToTracker(url));
            (async () => { infoHash = await sha1Hash(config.appId + roomId); await fillOfferPool(); readyResolve(); setInterval(fillOfferPool, OFFER_TTL); })();
            return {
                makeAction(name) { if (!actionHandlers[name]) actionHandlers[name] = []; return [(data, target) => sendToAllPeers(name, data, target), cb => actionHandlers[name].push(cb)]; },
                onPeerJoin(cb) { peerJoinCallbacks.push(cb); }, onPeerLeave(cb) { peerLeaveCallbacks.push(cb); }, getPeers() { return connectedPeers; },
                leave() { isLeaving = true; announceIntervals.forEach(clearInterval); Object.values(trackerSockets).forEach(ws => ws.close()); Object.values(connectedPeers).forEach(p => p.pc.close()); Object.values(pendingOffers).forEach(p => p.pc.close()); offerPool.forEach(o => o.pc.close()); }
            };
        }

        // =================================================================================
        // ARCHITECTURE LAYERS: Identity -> TrustedMesh -> StateStore -> UI
        // =================================================================================

        class Identity {
            constructor() {
                this.sigKeyPair = null; this.aesKey = null; this.peerKeys = {};
                this.locked = true; this.ready = false; this.encryptedBlob = null; this.currentPassword = null;
                this.DEFAULT_PASS = "FFFFFF";
            }
            async init() {
                if (this.ready) return;
                const db = await this.openDB(); const tx = db.transaction(["keys"], "readwrite"); const store = tx.objectStore("keys");
                const wrappedReq = store.get("wrapped_keys");
                await new Promise(r => tx.oncomplete = r);
                if (wrappedReq.result) {
                    this.encryptedBlob = wrappedReq.result;
                    if (await this.unlockWithPassword(this.DEFAULT_PASS, true)) this.updateUI("DEFAULT");
                    else this.updateUI("LOCKED");
                } else await this.generateNewKeys();
            }
            async generateNewKeys() {
                const tempSig = await window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-521" }, true, ["sign", "verify"]);
                const tempAes = await window.crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
                const sigJWK = await window.crypto.subtle.exportKey("jwk", tempSig.privateKey);
                const aesJWK = await window.crypto.subtle.exportKey("jwk", tempAes);
                const pubJWK = await window.crypto.subtle.exportKey("jwk", tempSig.publicKey);
                await this.saveWrappedKeys(this.DEFAULT_PASS, { aes: aesJWK, sig: sigJWK }, pubJWK);
                await this.loadKeysToMemory(sigJWK, aesJWK, pubJWK);
                this.currentPassword = this.DEFAULT_PASS; this.locked = false; this.ready = true; this.updateUI("DEFAULT");
            }
            async saveWrappedKeys(password, keysJwkObj, pubKeyJwk) {
                const salt = window.crypto.getRandomValues(new Uint8Array(16));
                const wrapKey = await this.deriveKeyFromPass(password, salt);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encryptedData = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, wrapKey, new TextEncoder().encode(JSON.stringify(keysJwkObj)));
                this.encryptedBlob = { salt, iv, data: encryptedData, pubKey: pubKeyJwk };
                const db = await this.openDB(); const tx = db.transaction(["keys"], "readwrite"); tx.objectStore("keys").put(this.encryptedBlob, "wrapped_keys"); await new Promise(r => tx.oncomplete = r);
            }
            async unlockWithPassword(password, silent = false) {
                if (!this.encryptedBlob) return false;
                try {
                    const wrapKey = await this.deriveKeyFromPass(password, this.encryptedBlob.salt);
                    const decryptedBytes = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: this.encryptedBlob.iv }, wrapKey, this.encryptedBlob.data);
                    const keysObj = JSON.parse(new TextDecoder().decode(decryptedBytes));
                    await this.loadKeysToMemory(keysObj.sig, keysObj.aes, this.encryptedBlob.pubKey);
                    this.currentPassword = password; this.locked = false; this.ready = true;
                    if (!silent) { this.updateUI(password === this.DEFAULT_PASS ? "DEFAULT" : "SECURE"); if (window.app) window.app.connectAndPreview(window.location.hash || '#ffffff'); }
                    return true;
                } catch (e) { if (!silent) alert("Wrong Password"); return false; }
            }
            async loadKeysToMemory(sigJwk, aesJwk, pubJwk) {
                this.aesKey = await window.crypto.subtle.importKey("jwk", aesJwk, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
                this.sigKeyPair = {
                    privateKey: await window.crypto.subtle.importKey("jwk", sigJwk, { name: "ECDSA", namedCurve: "P-521" }, false, ["sign"]),
                    publicKey: await window.crypto.subtle.importKey("jwk", pubJwk, { name: "ECDSA", namedCurve: "P-521" }, true, ["verify"])
                };
            }
            async updatePassword(newPassword) {
                if (this.locked || !newPassword) return;
                try {
                    await this.unlockWithPassword(this.currentPassword, true); // re-verify
                    // export keys from memory is not possible (not extractable), so we rely on logic that we HAVE them. 
                    // Actually, we must decrypt the BLOB again to get the JWKs to re-encrypt.
                    const oldWrapKey = await this.deriveKeyFromPass(this.currentPassword, this.encryptedBlob.salt);
                    const bytes = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: this.encryptedBlob.iv }, oldWrapKey, this.encryptedBlob.data);
                    const keysObj = JSON.parse(new TextDecoder().decode(bytes));
                    await this.saveWrappedKeys(newPassword, keysObj, this.encryptedBlob.pubKey);
                    this.currentPassword = newPassword; this.updateUI("SECURE");
                } catch (e) { alert("Update failed"); }
            }
            async deriveKeyFromPass(password, salt) {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
                return window.crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
            }
            async openDB() { return new Promise((resolve, reject) => { const req = indexedDB.open("sys_security", 2); req.onupgradeneeded = e => { if (!e.target.result.objectStoreNames.contains("keys")) e.target.result.createObjectStore("keys"); }; req.onsuccess = e => resolve(e.target.result); }); }
            updateUI(status) {
                const el = document.getElementById('security-status'), btn = document.getElementById('btn-security-apply'), input = document.getElementById('master-pass');
                if (status === "LOCKED") { el.innerHTML = "STATUS: <b style='color:red'>LOCKED</b>"; btn.innerText = "UNLOCK"; input.value = ""; }
                else if (status === "DEFAULT") { el.innerHTML = "STATUS: <b style='color:orange'>UNSECURED (DEFAULT)</b>"; btn.innerText = "UPDATE PASSWORD"; input.value = this.DEFAULT_PASS; }
                else { el.innerHTML = "STATUS: <b style='color:#00e676'>SECURED</b>"; btn.innerText = "UPDATE PASSWORD"; input.value = ""; input.placeholder = "Type new password..."; }
            }
            async getPublicKeyData() { if (!this.ready || this.locked) return null; return await window.crypto.subtle.exportKey("jwk", this.sigKeyPair.publicKey); }
            async storePeerKey(peerId, jwkData) { try { const key = await window.crypto.subtle.importKey("jwk", jwkData, { name: "ECDSA", namedCurve: "P-521" }, true, ["verify"]); this.peerKeys[peerId] = key; return true; } catch (e) { return false; } }
            async sign(dataString) { if (!this.ready || this.locked) return null; const s = await window.crypto.subtle.sign({ name: "ECDSA", hash: "SHA-512" }, this.sigKeyPair.privateKey, new TextEncoder().encode(dataString)); return btoa(String.fromCharCode(...new Uint8Array(s))); }
            async verify(peerId, dataString, signatureBase64) { if (!this.peerKeys[peerId]) return false; try { return await window.crypto.subtle.verify({ name: "ECDSA", hash: "SHA-512" }, this.peerKeys[peerId], Uint8Array.from(atob(signatureBase64), c => c.charCodeAt(0)), new TextEncoder().encode(dataString)); } catch (e) { return false; } }
            async encryptContent(text) { if (!this.ready || this.locked) throw new Error("Keystore Locked"); const iv = window.crypto.getRandomValues(new Uint8Array(12)); const c = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, this.aesKey, new TextEncoder().encode(text)); const p = new Uint8Array(iv.length + c.byteLength); p.set(iv, 0); p.set(new Uint8Array(c), 12); return p.buffer; }
            async decryptContent(packedBuffer) { if (!this.ready || this.locked) return "ðŸ”’ LOCKED"; try { const p = new Uint8Array(packedBuffer), iv = p.slice(0, 12), c = p.slice(12); const d = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, this.aesKey, c); return new TextDecoder().decode(d); } catch (e) { return "--- CORRUPT ---"; } }
        }

        class ColorDB {
            constructor() { this.name = 'color'; }
            async _open(hex = null) { return new Promise((res, rej) => { const req = indexedDB.open(this.name); req.onupgradeneeded = () => { }; req.onsuccess = e => { const db = e.target.result; if (hex && !db.objectStoreNames.contains(hex)) { const v = db.version + 1; db.close(); const upg = indexedDB.open(this.name, v); upg.onupgradeneeded = evt => { const d = evt.target.result; if (!d.objectStoreNames.contains(hex)) d.createObjectStore(hex).createIndex('owner', 'owner', { unique: false }); }; upg.onsuccess = evt => res(evt.target.result); } else res(db); }; }); }
            async saveLine(hex, index, content, ownerHex, signature) {
                if (!window.app?.identity?.ready) await window.app?.identity?.init();
                const encryptedContent = await window.app.identity.encryptContent(content);
                const db = await this._open(hex);
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readwrite'), store = tx.objectStore(hex);
                    store.put(parseInt(index), "cursor");
                    if (!content || content.trim() === '') store.delete(parseInt(index));
                    else store.put({ content: encryptedContent, owner: ownerHex, updated: Date.now(), signature: signature }, parseInt(index));
                    tx.oncomplete = () => res(true); tx.onerror = () => res(false);
                });
            }
            async getCursor(hex) { const db = await this._open(hex); if (!db.objectStoreNames.contains(hex)) return 0; return new Promise(res => { const req = db.transaction([hex], 'readonly').objectStore(hex).get("cursor"); req.onsuccess = () => res(req.result || 0); }); }
            async _processRow(row) { if (row?.content instanceof ArrayBuffer) { if (!window.app?.identity?.ready) await window.app?.identity?.init(); row.content = await window.app.identity.decryptContent(row.content); } return row; }
            async getRange(hex, min, max) { const db = await this._open(hex); if (!db.objectStoreNames.contains(hex)) return {}; return new Promise(res => { const req = db.transaction([hex], 'readonly').objectStore(hex).openCursor(IDBKeyRange.bound(min, max)); const result = {}; req.onsuccess = async e => { const cursor = e.target.result; if (cursor) { result[cursor.key] = await this._processRow(cursor.value); cursor.continue(); } else res(result); }; }); }
            async getSpecific(hex, keys) { const db = await this._open(hex); if (!db.objectStoreNames.contains(hex)) return {}; return new Promise(res => { const tx = db.transaction([hex], 'readonly').objectStore(hex); const results = {}; let pending = keys.length; if (!pending) res({}); keys.forEach(k => { const idx = parseInt(k.replace(hex, ''), 10); if (isNaN(idx)) { pending--; return; } tx.get(idx).onsuccess = async e => { if (e.target.result) results[idx] = await this._processRow(e.target.result); if (--pending === 0) res(results); }; }); }); }
            async getAllRooms() { const db = await this._open(); return Array.from(db.objectStoreNames).map(hex => ({ hex })); }
            async saveSignature(hex, signature) { const db = await this._open(hex); const tx = db.transaction([hex], 'readwrite'); tx.objectStore(hex).put({ ...signature, created: Date.now() }, 'signature'); }
            init() { return this._open(); }
        }
        window.ColorDB = ColorDB;

        class TrustedMesh {
            constructor(roomId, identity) {
                this.room = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69' }, roomId);
                this.identity = identity;
                this.handlers = new Map();

                // Actions
                const [sendFrag, onFrag] = this.room.makeAction('fragment');
                const [sendLock, onLock] = this.room.makeAction('lock');
                const [sendReq, onReq] = this.room.makeAction('req');
                const [sendId, onId] = this.room.makeAction('identity');
                this.rawSendFrag = sendFrag; this.rawSendLock = sendLock; this.rawSendReq = sendReq; this.rawSendId = sendId;

                // 1. Identity Handshake
                this.room.onPeerJoin(async (pid) => {
                    const jwk = await this.identity.getPublicKeyData();
                    this.rawSendId({ color: window.app.user.color, pubKey: jwk }, pid);
                    this.emit('peer-join', pid);
                });
                onId((data, pid) => {
                    if (data?.pubKey) this.identity.storePeerKey(pid, data.pubKey);
                    this.emit('peer-identity', data, pid);
                });

                // 2. Verified Data Pipeline
                onFrag(async (fragMap, pid) => {
                    if (!this.identity.peerKeys[pid]) return; // Drop unknown peers
                    const verifiedData = {};
                    for (const [key, item] of Object.entries(fragMap)) {
                        // VERIFY SIGNATURE
                        if (item.signature && await this.identity.verify(pid, item.content || "", item.signature)) {
                            verifiedData[key] = item;
                        } else {
                            console.warn(`[TrustedMesh] Dropped invalid sig from ${pid} on line ${key}`);
                        }
                    }
                    if (Object.keys(verifiedData).length > 0) this.emit('fragment', verifiedData, pid);
                });

                // 3. Passthrough actions
                onLock((d, p) => this.emit('lock', d, p));
                onReq((d, p) => this.emit('req', d, p));
                this.room.onPeerLeave(p => this.emit('peer-leave', p));
            }

            // AUTO-SIGNING SENDER
            async broadcastFragment(fragMap) {
                const signedMap = {};
                for (const [k, v] of Object.entries(fragMap)) {
                    const sig = await this.identity.sign(v.content || "");
                    signedMap[k] = { ...v, signature: sig };
                }
                this.rawSendFrag(signedMap);
            }

            broadcastLock(data) { this.rawSendLock(data); }
            requestSync(keys) { this.rawSendReq(keys); }
            getPeers() { return this.room.getPeers(); }
            leave() { this.room.leave(); }
            on(e, cb) { if (!this.handlers.has(e)) this.handlers.set(e, []); this.handlers.get(e).push(cb); }
            emit(e, ...args) { this.handlers.get(e)?.forEach(cb => cb(...args)); }
        }

        class StateStore {
            constructor(db, mesh, myColor) {
                this.db = db; this.mesh = mesh; this.myColor = myColor;
                this.lines = new Map();
                this.dbName = null;

                // Bind Network Events
                this.mesh.on('fragment', (data, pid) => this.mergeRemote(data, pid));
            }
            setRoom(hex) { this.dbName = hex; }
            async mergeRemote(fragMap, pid) {
                const roomHex = this.dbName;
                const indices = Object.keys(fragMap).map(k => parseInt(k)).sort((a, b) => a - b);
                // Update Local DB and UI
                for (const idx of indices) {
                    const item = fragMap[idx];
                    // LWW (Simple version: we just accept verified remote for now)
                    // In a real robust LWW we would check timestamps against local
                    const newContent = item.content;
                    const newOwner = item.owner || roomHex;

                    // Save to DB (Verified by Mesh already)
                    await this.db.saveLine(roomHex, idx, newContent, newOwner, item.signature);

                    // Notify UI
                    window.app.renderUpdate(idx, newContent, newOwner);
                }
            }
            async updateLine(index, content) {
                const owner = this.myColor.replace('#', '');
                // 1. Sign
                const sig = await window.app.identity.sign(content || "");
                // 2. Save DB
                await this.db.saveLine(this.dbName, index, content, owner, sig);
                // 3. Broadcast
                this.mesh.broadcastFragment({ [index]: { content, owner, updated: Date.now(), signature: sig } }); // mesh handles wrapping signature? No, mesh helper expects object.
                // Actually TrustedMesh helper 'broadcastFragment' recalculates signature. 
                // Optimization: Pass the signature we just made to avoid double-signing?
                // For simplicity/cleanliness, let TrustedMesh do its job of signing outgoing data.
                // We just pass raw data to TrustedMesh.
                // WAIT: DB needs signature too. 
            }
        }

        class EditorApp {
            constructor() {
                this.identity = new Identity();
                this.db = new ColorDB();
                this.mesh = null;
                this.ui = Object.fromEntries(['display', 'chat-container', 'minimap', 'peer-count', 'tools', 'room-status', 'login-btn', 'user-badge', 'login-card', 'dashboard-panel', 'hover-trigger', 'top-nav', 'sub-nav-layer'].map(id => [id.replace(/-./g, x => x[1].toUpperCase()), document.getElementById(id)]));
                this.ui.dot = document.querySelector('.dot');

                let savedColor = localStorage.getItem('lastSphereColor') || '#ffffff';
                this.user = { id: 'user_' + savedColor.replace('#', ''), color: savedColor };

                this.visitedRooms = [];
                this.activeLocks = {};
                this.peerColors = {};
                this.initDone = false;
                this.currentLineId = null;
                this.isFresh = true;
                this.saveTimeout = null;

                // Init Systems
                Promise.all([this.identity.init(), this.db.init()]).then(async () => {
                    const rooms = await this.db.getAllRooms();
                    this.visitedRooms = rooms.map(r => 'color-' + r.hex);
                    if (!window.location.hash || window.location.hash.length < 2) this.runSequencedScan();
                    else this.tryAutoConnectFromHash();
                    this.initDone = true;
                });

                this.bindEvents();
                this.setupGlobalExposure();
            }

            // --- HELPERS ---
            makeId(index) { return this.roomId.replace('color-', '') + index; }

            parseId(id) {
                if (!id) return null;
                const roomHex = this.roomId.replace('color-', '');
                if (id.startsWith(roomHex)) {
                    const idx = parseInt(id.slice(roomHex.length), 10);
                    if (!isNaN(idx)) return { index: idx, owner: roomHex };
                }
                return null;
            }

            reconstructLine(id, content, ownerHex) {
                const myHex = this.user.color.replace('#', '');
                const effectiveOwner = ownerHex || this.roomId.replace('color-', '');
                const isEmpty = !content || content === '<br>' || content.trim() === '';
                const amOwner = (effectiveOwner === myHex);
                const isEditable = (isEmpty || amOwner) ? 'true' : 'false';
                return `<div id="${id}" class="editor-line" contenteditable="${isEditable}">${content || '<br>'}</div>`;
            }

            createRow(index) {
                return this.reconstructLine(this.makeId(index), null, null);
            }

            createLines(count) {
                let html = '';
                for (let i = 0; i < count; i++) {
                    html += this.createRow(i);
                }
                return html;
            }

            // --- MISSING METHODS RESTORED ---
            tryAutoConnectFromHash() {
                if (window.location.hash.length > 1) this.connectAndPreview(window.location.hash, true);
            }

            getFragments(visibleOnly = false) {
                const d = {};
                const top = this.ui.chatContainer.scrollTop - 500;
                const bot = top + this.ui.chatContainer.clientHeight + 1000;
                const roomHex = this.roomId.replace('color-', '');

                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id && (!visibleOnly || (el.offsetTop + el.offsetHeight > top && el.offsetTop < bot))) {
                        const meta = this.parseId(el.id);
                        if (meta) {
                            d[meta.index] = {
                                content: el.innerHTML,
                                owner: el.getAttribute('data-lock-owner') || roomHex
                            };
                        }
                    }
                });
                return d;
            }

            // --- CORE UI LOGIC ---
            enterRoomUI() {
                if (window.state) { window.state.landing.active = false; window.state.landing.showHandle = false; }
                if (this.ui.dashboardPanel.classList.contains('active')) return;

                const roomHex = this.roomId.replace('color-', '');

                if (this.ui.loginBtn.textContent === "LOGIN") {
                    this.user.color = '#' + roomHex;
                    this.ui.userBadge.style.backgroundColor = this.user.color;
                    localStorage.setItem('lastSphereColor', this.user.color);
                    this.user.id = 'user_' + this.user.color.replace('#', '');
                }

                this.ui.loginBtn.classList.add('hidden');
                this.ui.loginCard.classList.remove('visible');
                this.ui.dashboardPanel.classList.add('active');

                this.triggerSave(null);
                this.ui.hoverTrigger.style.display = 'block';

                if (window.state && window.state.interactionSignature) {
                    this.db.saveSignature(roomHex, window.state.interactionSignature);
                }

                if (!this.visitedRooms.includes(this.roomId)) {
                    this.visitedRooms.push(this.roomId);
                    this.db._open(roomHex);
                }

                setTimeout(() => {
                    document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                }, 300);

                window.location.hash = roomHex;

                if (!this.ui.display.querySelector('.editor-line')) {
                    this.ui.display.innerHTML = this.createLines(101);
                    this.isFresh = true;
                    this.focusLine(50);
                } else {
                    this.db.getCursor(roomHex).then(idx => {
                        this.focusLine(idx);
                    });
                }
            }

            async connectAndPreview(hex, fromUrl = false) {
                const cleanHex = hex.replace('#', '').toLowerCase();
                this.roomId = 'color-' + cleanHex;
                this.user.color = localStorage.getItem('lastSphereColor') || '#ffffff';
                this.ui.userBadge.style.backgroundColor = this.user.color;
                this.user.id = 'user_' + this.user.color.replace('#', '');

                if (this.mesh) { this.mesh.leave(); this.mesh = null; }

                this.ui.loginBtn.classList.remove('hidden');
                const db = await this.db._open();
                const exists = db.objectStoreNames.contains(cleanHex);

                if (exists) {
                    this.ui.roomStatus.innerText = "Loading...";
                    const centerIndex = await this.db.getCursor(cleanHex);
                    const data = await this.db.getRange(cleanHex, centerIndex - 50, centerIndex + 50);
                    await this.renderFromLocalDB(data, centerIndex);
                    this.ui.roomStatus.innerText = "READY";
                    this.joinNetwork();
                    if (fromUrl && window.state?.landing) {
                        window.state.landing.shouldAutoEnter = true;
                        if (window.state.landing.progress >= 1 && window.enterRoomUI) window.enterRoomUI();
                    }
                } else {
                    this.ui.roomStatus.innerText = "Checking Network...";
                    this.joinNetwork();
                    setTimeout(() => {
                        if (!this.ui.display.querySelector('.editor-line')) {
                            this.renderInitialState({}, 0);
                            if (this.ui.loginBtn.textContent !== "JOIN") this.ui.roomStatus.innerText = "COLOR AVAILABLE";
                        }
                    }, 3000);
                }
            }

            async renderFromLocalDB(data, centerIndex) {
                this.renderInitialState(data, centerIndex);
                this.isFresh = false;
            }

            joinNetwork() {
                this.mesh = new TrustedMesh(this.roomId, this.identity);

                this.mesh.on('peer-join', (pid) => {
                    this.updateStatus();
                    if (this.currentLineId) this.mesh.broadcastLock({ lineId: this.currentLineId, userColor: this.user.color });
                    const frags = this.getFragments(true);
                    if (Object.keys(frags).length) this.mesh.broadcastFragment(frags);
                });

                this.mesh.on('peer-leave', () => { this.updateStatus(); this.reapplyVisualLocks(); });
                this.mesh.on('peer-identity', (data, pid) => { this.peerColors[pid] = data?.color || '#ffffff'; });

                this.mesh.on('lock', (data, pid) => {
                    this.activeLocks[pid] = { lineId: data.lineId, ts: Date.now(), color: data.userColor };
                    this.reapplyVisualLocks();
                });

                this.mesh.on('fragment', (verifiedData, pid) => {
                    const roomHex = this.roomId.replace('color-', '');
                    for (const [idx, item] of Object.entries(verifiedData)) {
                        this.renderUpdate(parseInt(idx), item.content, item.owner || roomHex);
                        this.db.saveLine(roomHex, idx, item.content, item.owner, item.signature);
                    }
                });

                this.mesh.on('req', async (keys, pid) => {
                    const roomHex = this.roomId.replace('color-', '');
                    if (keys && Array.isArray(keys)) {
                        const payload = await this.db.getSpecific(roomHex, keys);
                        if (Object.keys(payload).length) this.mesh.broadcastFragment(payload);
                    } else {
                        const frags = this.getFragments(false);
                        if (Object.keys(frags).length) this.mesh.broadcastFragment(frags);
                    }
                });

                setInterval(() => this.updateStatus(), 1000);
                setTimeout(() => { if (this.mesh) this.mesh.requestSync(null); }, 1000);
            }

            renderUpdate(index, newContent, newOwner) {
                const roomHex = this.roomId.replace('color-', '');
                const domId = roomHex + index;
                let el = document.getElementById(domId);

                if (document.activeElement === el) return;

                if (!el) {
                    const temp = document.createElement('div');
                    temp.innerHTML = this.reconstructLine(domId, newContent, newOwner);
                    const newEl = temp.firstElementChild;
                    const children = Array.from(this.ui.display.children);
                    let ref = null;
                    for (let j = 0; j < children.length; j++) {
                        const cMeta = this.parseId(children[j].id);
                        if (cMeta && cMeta.index > index) { ref = children[j]; break; }
                    }
                    this.ui.display.insertBefore(newEl, ref);
                    el = newEl;
                }

                if (el) {
                    if (el.innerHTML !== newContent) el.innerHTML = this.sanitize(newContent || '<br>');
                    const myHex = this.user.color.replace('#', '');
                    const isEmpty = !newContent || newContent.trim() === '' || newContent === '<br>';
                    const amOwner = (newOwner === myHex);
                    el.contentEditable = (isEmpty || amOwner) ? 'true' : 'false';
                }
            }

            async triggerSave(lineId) {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                const meta = this.parseId(lineId);
                if (!meta) return;
                const el = document.getElementById(lineId);
                const content = el.innerText.trim().length > 0 ? el.innerHTML : null;
                const owner = this.user.color.replace('#', '');

                const sig = await this.identity.sign(content || "");
                await this.db.saveLine(this.roomId.replace('color-', ''), meta.index, content, owner, sig);
                if (this.mesh) this.mesh.broadcastFragment({ [meta.index]: { content, owner } });
            }

            bindEvents() {
                this.ui.display.addEventListener('input', (e) => {
                    this.isFresh = false; clearTimeout(this.saveTimeout);
                    let line = e.target.closest('.editor-line');
                    if (!line) {
                        const sel = window.getSelection();
                        if (sel.rangeCount > 0) { const node = sel.anchorNode; line = (node.nodeType === 3 ? node.parentNode : node).closest('.editor-line'); }
                    }
                    if (!line && this.currentLineId) line = document.getElementById(this.currentLineId);

                    if (line) {
                        this.currentLineId = line.id;
                        this.saveTimeout = setTimeout(() => this.triggerSave(line.id), 500);
                    }
                });

                this.ui.chatContainer.addEventListener('scroll', () => this.checkBuffers());
                const resizeObserver = new ResizeObserver(() => { requestAnimationFrame(() => this.renderMinimap()); });
                resizeObserver.observe(this.ui.chatContainer);
                document.getElementById('status-toggle').addEventListener('click', () => this.togglePeek());

                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const targetId = item.getAttribute('data-target');
                        if (targetId === 'connect') {
                            this.togglePeek();
                            if (this.peeking) {
                                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active')); item.classList.add('active');
                                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            } else {
                                this.ui.dashboardPanel.classList.remove('peek-mode');
                                document.querySelector('.nav-item[data-target="home"]')?.click();
                            }
                            return;
                        }
                        if (this.peeking) this.togglePeek();
                        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active')); item.classList.add('active');
                        document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                        document.getElementById('view-' + targetId)?.classList.add('active');
                        if (targetId === 'home') {
                            this.ui.dashboardPanel.classList.remove('step-down'); this.ui.dashboardPanel.classList.add('revealed');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                        } else {
                            this.ui.dashboardPanel.classList.add('step-down');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            document.getElementById('header-' + targetId)?.classList.add('active');
                        }
                    });
                });

                document.getElementById('settings-btn').addEventListener('click', () => {
                    document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                    document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                    document.getElementById('view-settings').classList.add('active');
                    this.ui.dashboardPanel.classList.add('step-down');
                    document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                    document.getElementById('header-settings').classList.add('active');
                });
                document.querySelectorAll('.sub-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const group = tab.getAttribute('data-group'), target = tab.getAttribute('data-tab');
                        document.querySelectorAll(`.sub-tab[data-group="${group}"]`).forEach(t => t.classList.remove('active')); tab.classList.add('active');
                        document.querySelector(`.content-view.active`)?.querySelectorAll('.settings-pane, .apps-pane').forEach(p => p.classList.remove('active'));
                        document.querySelector(`.content-view.active #tab-${target}`)?.classList.add('active');
                    });
                });

                window.addEventListener('mousemove', e => {
                    if (!this.ui.dashboardPanel.classList.contains('active') || this.ui.dashboardPanel.classList.contains('revealed') || this.ui.dashboardPanel.classList.contains('step-down') || this.ui.dashboardPanel.classList.contains('peek-mode')) {
                        if (!this.peeking) this.ui.dashboardPanel.style.transform = ''; return;
                    }
                    if (e.clientY < 33) {
                        if (e.clientY <= 33) { this.ui.dashboardPanel.classList.add('revealed'); this.ui.topNav.classList.add('visible'); this.ui.dashboardPanel.style.transform = ''; }
                    }
                });

                let ts = 0, isDrag = false;
                window.addEventListener('touchstart', e => { ts = e.touches[0].clientY; if (this.ui.dashboardPanel.classList.contains('active') && (ts < 150 || this.peeking)) isDrag = true; }, { passive: true });
                window.addEventListener('touchmove', e => {
                    if (!isDrag) return;
                    const currentY = e.touches[0].clientY;
                    const delta = currentY - ts;
                    const navHeight = 90;
                    const maxDrag = window.innerHeight - 50;

                    if (delta > 0 && !this.peeking) {
                        this.ui.dashboardPanel.style.transform = `translateY(${delta}px)`;
                        if (delta > navHeight) {
                            const range = maxDrag - navHeight;
                            const prog = Math.min(1, (delta - navHeight) / range);
                            if (window.state && window.state.peeking) { window.state.peeking.active = true; window.state.peeking.value = prog; }
                        }
                    }

                    if (delta < 0 && this.peeking) {
                        const realY = maxDrag + delta;
                        this.ui.dashboardPanel.style.transform = `translateY(${realY}px)`;
                        const range = maxDrag - navHeight;
                        const prog = Math.max(0, (realY - navHeight) / range);
                        if (window.state && window.state.peeking) { window.state.peeking.active = true; window.state.peeking.value = prog; }
                    }
                }, { passive: true });
                window.addEventListener('touchend', e => {
                    if (!isDrag) return; isDrag = false; this.ui.dashboardPanel.style.transform = '';
                    if (this.peeking && e.changedTouches[0].clientY < window.innerHeight * 0.7) { this.peeking = false; this.ui.dashboardPanel.classList.remove('peek-mode'); this.updatePeekState(0); }
                    else if (!this.peeking && e.changedTouches[0].clientY > window.innerHeight * 0.3) { this.peeking = true; this.ui.dashboardPanel.classList.add('peek-mode'); this.updatePeekState(1); }
                });

                document.addEventListener('selectionchange', () => {
                    const s = window.getSelection(); if (!s.rangeCount) return;
                    const line = (s.anchorNode.nodeType === 3 ? s.anchorNode.parentNode : s.anchorNode).closest('.editor-line');
                    if (line && line.id) {
                        this.currentLineId = line.id; document.querySelectorAll('.my-line').forEach(e => e.classList.remove('my-line')); line.classList.add('my-line');
                        this.ui.tools.classList.toggle('visible', s.toString().length > 0);
                        if (this.mesh) this.mesh.broadcastLock({ lineId: line.id, userColor: this.user.color });
                    }
                });

                document.getElementById('display').addEventListener('keydown', (e) => {
                    // 1. Backspace Protection (Your original code)
                    if (e.key === 'Backspace') {
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const anchor = sel.anchorNode;
                            const currentLine = (anchor.nodeType === 3 ? anchor.parentNode : anchor).closest('.editor-line');
                            if (currentLine) {
                                const isAtStart = range.collapsed && range.startOffset === 0 &&
                                    (anchor === currentLine || anchor === currentLine.firstChild);
                                if (isAtStart) {
                                    const prevLine = currentLine.previousElementSibling;
                                    if (prevLine && prevLine.isContentEditable === false) {
                                        e.preventDefault();
                                        return;
                                    }
                                }
                            }
                        }
                    }

                    // 2. Enter Logic (Modified to fix Double-Enter bug)
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const br = document.createElement('br');

                            // 1. Delete any selected text
                            range.deleteContents();

                            // 2. Insert the BR
                            range.insertNode(br);

                            // 3. Move the cursor range to immediately after the inserted BR
                            range.setStartAfter(br);
                            range.setEndAfter(br);

                            // 4. THE FIX: Check nextSibling but ignore empty text nodes
                            // When inserting in a text node, the DOM splits, leaving an empty text node after the BR.
                            let next = br.nextSibling;
                            if (next && next.nodeType === 3 && next.length === 0) {
                                next = next.nextSibling;
                            }

                            // If there is no real content after the break, add the phantom BR
                            // so the browser renders the new line and holds the cursor open
                            if (!next) {
                                br.parentNode.appendChild(document.createElement('br'));
                            }

                            // 5. Update selection
                            sel.removeAllRanges();
                            sel.addRange(range);

                            // 6. Force Input Event for saving
                            e.target.dispatchEvent(new Event('input', { bubbles: true }));

                            // 7. Scroll into view (keeps cursor visible if at bottom of screen)
                            const anchor = sel.anchorNode;
                            const element = anchor.nodeType === 1 ? anchor : anchor.parentElement;
                            if (element) {
                                element.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                            }
                        }
                    }
                });
                ['bold', 'italic'].forEach(c => document.getElementById('btn-' + c).onclick = () => document.execCommand(c));
                document.getElementById('btn-link').onclick = () => { const u = prompt("URL:"); if (u) document.execCommand('createLink', false, u); };
            }

            updateStatus() {
                if (!this.mesh) return
                const peers = Object.values(this.mesh.getPeers()).filter(p => p.dc?.readyState === 'open').length;
                if (peers > 0) {
                    this.ui.loginBtn.innerHTML = "<span>JOIN</span>"; this.ui.loginBtn.classList.remove('hidden');
                    this.ui.roomStatus.innerText = `${peers} PEER${peers > 1 ? 'S' : ''} ONLINE`;
                    this.ui.peerCount.innerText = `${peers} visitor${peers > 1 ? 's' : ''}`; this.ui.dot.classList.add('on');
                } else {
                    this.ui.roomStatus.innerText = "COLOR AVAILABLE"; this.ui.peerCount.innerText = "Offline";
                    this.ui.loginBtn.innerHTML = "<span>LOGIN</span>"; this.ui.dot.classList.remove('on');
                }
            }
            togglePeek() {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                this.peeking = !this.peeking;
                this.ui.dashboardPanel.classList.toggle('peek-mode', this.peeking);
                this.updatePeekState(this.peeking ? 1 : 0);
            }
            updatePeekState(val) { if (window.state?.peeking) { window.state.peeking.active = val > 0; window.state.peeking.value = val; } }

            logout() {
                if (window.resetSphereView) window.resetSphereView();
                this.ui.dashboardPanel.classList.remove('active', 'revealed', 'step-down', 'peek-mode'); this.ui.dashboardPanel.style.transform = '';
                this.peeking = false; this.updatePeekState(0);
                this.ui.loginCard.classList.remove('visible'); this.ui.topNav.classList.remove('visible');
                this.ui.hoverTrigger.style.display = 'none'; this.ui.loginBtn.classList.remove('hidden');
                document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
                if (this.mesh) { this.mesh.leave(); this.mesh = null; }
                this.ui.display.innerHTML = ''; this.ui.minimap.innerHTML = ''; this.activeLocks = {};
                if (window.updateVisitedFromDB) window.updateVisitedFromDB();
            }

            renderInitialState(data, centerIndex) {
                let html = ''; const roomHex = this.roomId.replace('color-', '');
                for (let i = centerIndex - 50; i <= centerIndex + 50; i++) html += this.reconstructLine(roomHex + i, data[i]?.content, data[i]?.owner);
                this.ui.display.innerHTML = html; this.focusLine(centerIndex);
            }

            focusLine(index) {
                requestAnimationFrame(() => {
                    const domId = this.roomId.replace('color-', '') + index;
                    const el = document.getElementById(domId);
                    if (el) {
                        el.scrollIntoView({ block: 'center' });
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(el);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        this.ui.display.focus();
                        this.currentLineId = domId;
                    }
                });
            }

            checkBuffers() {
                if (this.bufferCheckPending) return;
                this.bufferCheckPending = true;
                requestAnimationFrame(async () => {
                    const c = this.ui.chatContainer;
                    const { scrollTop: st, scrollHeight: sh, clientHeight: ch } = c;
                    const children = this.ui.display.children;
                    if (children.length === 0) { this.bufferCheckPending = false; return; }
                    const firstMeta = this.parseId(children[0].id);
                    const lastMeta = this.parseId(children[children.length - 1].id);
                    if (!firstMeta || !lastMeta) { this.bufferCheckPending = false; return; }
                    const firstIndex = firstMeta.index, lastIndex = lastMeta.index;
                    const roomHex = this.roomId.replace('color-', '');

                    if (st < 100) {
                        const oldHeight = sh;
                        const start = firstIndex - 10, end = firstIndex - 1;
                        const dbData = await this.db.getRange(roomHex, start, end);
                        let html = '', missing = [];
                        for (let i = start; i <= end; i++) {
                            const row = dbData[i];
                            html += this.reconstructLine(roomHex + i, row?.content, row?.owner);
                            if (!row) missing.push(roomHex + i);
                        }
                        this.ui.display.insertAdjacentHTML('afterbegin', html);
                        if (c.scrollHeight > 0) c.scrollTop = st + (c.scrollHeight - oldHeight);
                        if (this.mesh && missing.length) this.mesh.requestSync(missing);
                    }
                    if (sh - st - ch < 100) {
                        const start = lastIndex + 1, end = lastIndex + 10;
                        const dbData = await this.db.getRange(roomHex, start, end);
                        let html = '', missing = [];
                        for (let i = start; i <= end; i++) {
                            const row = dbData[i];
                            html += this.reconstructLine(roomHex + i, row?.content, row?.owner);
                            if (!row) missing.push(roomHex + i);
                        }
                        this.ui.display.insertAdjacentHTML('beforeend', html);
                        if (this.mesh && missing.length) this.mesh.requestSync(missing);
                    }
                    if (children.length > 250) {
                        if (st > sh / 2) { for (let i = 0; i < 50; i++) children[0].remove(); } else { for (let i = 0; i < 50; i++) children[children.length - 1].remove(); }
                    }
                    this.bufferCheckPending = false;
                });
            }

            sanitize(str) { return DOMPurify.sanitize(str, { ALLOWED_TAGS: ['b', 'i', 'u', 'a', 'br', 'div', 'span'], ALLOWED_ATTR: ['href', 'style', 'class', 'target'] }); }
            reapplyVisualLocks() {
                document.querySelectorAll('.locked-line').forEach(el => { el.classList.remove('locked-line'); el.style.removeProperty('--lock-color'); el.removeAttribute('data-lock-owner'); });
                const now = Date.now();
                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000) continue;
                    const el = document.getElementById(lock.lineId);
                    if (el) { el.classList.add('locked-line'); el.style.setProperty('--lock-color', lock.color); el.contentEditable = "false"; el.setAttribute('data-lock-owner', lock.color); }
                }
                this.renderMinimap();
            }
            renderMinimap() {
                const h = this.ui.chatContainer.scrollHeight, now = Date.now();
                this.ui.minimap.innerHTML = Object.entries(this.activeLocks).filter(([pid, lock]) => now - lock.ts <= 60000).map(([_, lock]) => {
                    const el = document.getElementById(lock.lineId);
                    return el ? `<div class="scroll-dot" style="background:${lock.color};top:${(el.offsetTop / h) * 100}%"></div>` : '';
                }).join('');
            }
            setupGlobalExposure() { window.connectAndPreview = (h, u) => this.connectAndPreview(h, u); window.enterRoomUI = () => this.enterRoomUI(); }
            async runSequencedScan() { for (const rId of this.visitedRooms) { try { const r = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69' }, rId); await new Promise(res => setTimeout(() => { window.postMessage({ type: 'handle-ready', hex: rId.replace('color-', '#'), count: Object.keys(r.getPeers()).length }, '*'); r.leave(); res(); }, 1000)); } catch (e) { } } }
        }

        window.app = new EditorApp();
        document.getElementById('btn-security-apply').addEventListener('click', async () => {
            const pass = document.getElementById('master-pass').value;
            if (window.app.identity.locked) await window.app.identity.unlockWithPassword(pass);
            else if (confirm("Update master password?")) await window.app.identity.updatePassword(pass);
        });
    </script>
    <!-- WebGPU Logic Remains Exactly as provided -->
    <script type="module">
        let storageScope = window.localStorage; document.getElementById('login-btn').addEventListener('click', async () => { if (document.getElementById('login-btn').innerText === 'LOGIN') { try { storageScope.setItem("lastSphereColor", document.getElementById('color-hex').innerText); } catch (e) { } } if (window.enterRoomUI) window.enterRoomUI(); });
        const Vec3 = { create: () => [0, 0, 0], add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s], dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2], cross: (a, b) => [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]], len: v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]), normalize: v => { const l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); return l > 0 ? [v[0] / l, v[1] / l, v[2] / l] : [0, 0, 0] }, dist: (a, b) => Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) };
        const Mat4 = { perspective: (f, a, n, fr) => { const nf = 1 / (n - fr), f_t = 1 / Math.tan(f / 2); return [f_t / a, 0, 0, 0, 0, f_t, 0, 0, 0, 0, (fr + n) * nf, -1, 0, 0, 2 * fr * n * nf, 0] }, lookAt: (e, c, u) => { const z = Vec3.normalize(Vec3.sub(e, c)), x = Vec3.normalize(Vec3.cross(u, z)), y = Vec3.cross(z, x); return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -Vec3.dot(x, e), -Vec3.dot(y, e), -Vec3.dot(z, e), 1] }, multiply: (a, b) => [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]], rotationX: r => [1, 0, 0, 0, 0, Math.cos(r), Math.sin(r), 0, 0, -Math.sin(r), Math.cos(r), 0, 0, 0, 0, 1], translation: v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1], scale: v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1], rotationAxis: (a, r) => { const c = Math.cos(r), s = Math.sin(r), t = 1 - c, x = a[0], y = a[1], z = a[2]; return [t * x * x + c, t * x * y + z * s, t * x * z - y * s, 0, t * x * y - z * s, t * y * y + c, t * y * z + x * s, 0, t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0, 0, 0, 0, 1] }, identity: () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
        const state = { canvas: null, device: null, context: null, pipelines: { sphere: null, cone: null }, buffers: {}, bindGroups: { sphere: null, cones: [] }, cameraPos: [0, 0, 4], sphere: { rotation: Mat4.identity(), indexCount: 0 }, cones: [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }], historyHandles: [], hasRotated: false, mouse: { x: 0, y: 0, down: false }, draggedConeIndex: -1, valueScrub: { active: false, coneIndex: -1, coordIndex: 0, startY: 0 }, lastTime: 0, clickData: { startX: 0, startY: 0, startTime: 0 }, landing: { active: false, progress: 0, rotationAxis: [1, 0, 0], rotationAngle: 0, baseRotation: Mat4.identity(), coneStartPositions: [], handleStartPos: [0, 0, 0], showHandle: false, startDist: 4.0, targetDist: 1.25, shouldAutoEnter: false }, dragStart: { active: false, mouseDir: [0, 0, 1], sphereRotation: null, conePositions: [], lastTrackPos: null }, inertia: { active: false, axis: [1, 0, 0], val: 0 }, handle: { active: false, pos: [0, 0, 0], color: [1, 1, 1] }, msaaTexture: null, depthTexture: null, sampleCount: 4, presentationFormat: null, debugMode: false, uiCache: [], vpMatrix: Mat4.identity(), returning: null, uniforms: { sphere: new Float32Array(80), cone: new Float32Array(20) }, peeking: { active: false, value: 0 }, interaction: { mode: 'none', hasTouchedSphere: false }, pathPoints: [], pathStartPos: null, interactionSignature: { type: 'click', path: [] } };
        window.state = state;
        function rgbToHex(r, g, b) { return '#' + [r, g, b].map(x => Math.round(Math.min(1, Math.max(0, x)) * 255).toString(16).padStart(2, '0')).join(''); }
        function hexToRgbNormalized(hex) { const bigint = parseInt(hex.replace(/^#/, '').replace(/^([a-f\d])([a-f\d])([a-f\d])$/i, '$1$1$2$2$3$3'), 16); return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255]; }
        const gradientShaderWGSL = `struct Uniforms { mvp: mat4x4<f32>, model: mat4x4<f32>, normalMatrix: mat4x4<f32>, viewPos: vec3<f32>, l1: vec3<f32>, c1: vec3<f32>, l2: vec3<f32>, c2: vec3<f32>, l3: vec3<f32>, c3: vec3<f32>, debug: f32, }; @group(0) @binding(0) var<uniform> u: Uniforms; struct VI { @location(0) p: vec3<f32>, @location(1) n: vec3<f32> }; struct VO { @builtin(position) P: vec4<f32>, @location(0) vP: vec3<f32>, @location(1) vN: vec3<f32> }; @vertex fn vs_main(i: VI) -> VO { var o: VO; o.P = u.mvp * vec4<f32>(i.p, 1.0); o.vP = (u.model * vec4<f32>(i.p, 1.0)).xyz; o.vN = (u.normalMatrix * vec4<f32>(i.n, 0.0)).xyz; return o; } fn Contrast(x: vec3<f32>) -> vec3<f32> { return x * x * (3.0 - 2.0 * x); } fn getI(lp: vec3<f32>, N: vec3<f32>, fp: vec3<f32>) -> f32 { let distSq = dot(lp - fp, lp - fp); let L = normalize(lp - fp); let wrap = max(dot(N, L) + 1.0, 0.0) / 2.0; let spread = pow(wrap, 1.25); return spread * (1.0 / (1.0 + distSq * 0.05)); } @fragment fn fs_main(i: VO) -> @location(0) vec4<f32> { let N = normalize(i.vN); let raw_d1 = getI(u.l1, N, i.vP); let raw_d2 = getI(u.l2, N, i.vP); let raw_d3 = getI(u.l3, N, i.vP); let d1 = raw_d1 * max(u.c1.r, max(u.c1.g, u.c1.b)); let d2 = raw_d2 * max(u.c2.r, max(u.c2.g, u.c2.b)); let d3 = raw_d3 * max(u.c3.r, max(u.c3.g, u.c3.b)); var l = (u.c1 * d1) + (u.c2 * d2) + (u.c3 * d3); let ep = 0.001; l = l + ((u.c1 + u.c2) * 2.0 * d1 * d2 / (d1 + d2 + ep)); l = l + ((u.c2 + u.c3) * 2.0 * d2 * d3 / (d2 + d3 + ep)); l = l + ((u.c3 + u.c1) * 2.0 * d3 * d1 / (d3 + d1 + ep)); let min_i = min(d1, min(d2, d3)); let max_i = max(d1, max(d2, d3)); let mask_base = smoothstep(0.15, 0.40, min_i); let variance = max_i - min_i; let roundness = exp(-variance * 10.0); let final_mask = mask_base * roundness; l = mix(l, vec3(1.0), final_mask); l = l * 1.2; let contrasty = Contrast(clamp(l, vec3(0.0), vec3(1.0))); return vec4<f32>(contrasty, 1.0); }`;
        const solidShaderWGSL = `struct U{mvp:mat4x4<f32>,c:vec4<f32>};@group(0) @binding(0) var<uniform> u:U;@vertex fn vs_main(@location(0) p:vec3<f32>)->@builtin(position) vec4<f32>{return u.mvp*vec4<f32>(p,1.0);}@fragment fn fs_main()->@location(0) vec4<f32>{return u.c;}`;
        const defaultCones = [{ color: [1, 0, 0], pos: [0, .98, .69], active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], active: true }];
        function findPositionFromColor(targetHex) { const t = hexToRgbNormalized(targetHex); let bd = Infinity, bp = null; for (let la = 0; la <= 30; la++) for (let lo = 0; lo <= 30; lo++) { const th = la * Math.PI / 30, ph = lo * 2 * Math.PI / 30, pos = [Math.cos(ph) * Math.sin(th), Math.cos(th), Math.sin(ph) * Math.sin(th)]; const c = getSurfaceColor(pos, pos, defaultCones), d = Math.sqrt((c[0] - t[0]) ** 2 + (c[1] - t[1]) ** 2 + (c[2] - t[2]) ** 2); if (d < bd) { bd = d; bp = pos; } if (d < 0.05) return bp; } return bp; }
        async function init() {
            if (window.self !== window.top) document.getElementById('debug-btn').style.display = 'none';
            state.canvas = document.getElementById('gpu-canvas'); if (!navigator.gpu) return alert("WebGPU not supported!"); const adapter = await navigator.gpu.requestAdapter(); state.device = await adapter.requestDevice(); state.context = state.canvas.getContext('webgpu'); state.presentationFormat = navigator.gpu.getPreferredCanvasFormat(); state.context.configure({ device: state.device, format: state.presentationFormat, alphaMode: 'premultiplied' });

            await createAssets();
            state.historyHandles = [];
            const rooms = await (new window.ColorDB()).getAllRooms();

            window.addEventListener('resize', onResize); onResize();

            state.canvas.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp); state.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e.touches[0]) }, { passive: false }); state.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e.touches[0]) }, { passive: false }); state.canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e.changedTouches[0]) }); document.getElementById('freeze-btn').addEventListener('click', toggleFreeze);
            document.getElementById('debug-btn').onclick = function () { state.debugMode = !state.debugMode; this.classList.toggle('active', state.debugMode); this.innerText = state.debugMode ? "DEBUG ON" : "DEBUG OFF"; document.getElementById('debug-panel').classList.toggle('visible', state.debugMode); };
            document.getElementById('reset-btn').onclick = async () => { if (confirm("Permanently wipe all local data?")) { localStorage.clear(); try { const dbs = await window.indexedDB.databases(); for (const db of dbs) { await window.indexedDB.deleteDatabase(db.name); } } catch (e) { } window.location.reload(); } };
            state.cones.forEach((c, i) => { const el = document.getElementById(`data-${i}`); if (!el) return; el.innerHTML = `<span class="cone-title" id="title-${i}">${c.name}</span> <span style="color:#666">X</span> <span class="coord-val" id="x-${i}">0.00</span> <span style="color:#666">Y</span> <span class="coord-val" id="y-${i}">0.00</span> <span style="color:#666">Z</span> <span class="coord-val" id="z-${i}">0.00</span>`; const title = document.getElementById(`title-${i}`); title.addEventListener('click', (e) => { if (!document.body.classList.contains('light-mode')) { e.stopPropagation(); state.cones[i].active = !state.cones[i].active; } });['x', 'y', 'z'].forEach((ax, idx) => document.getElementById(`${ax}-${i}`).addEventListener('mousedown', (e) => { if (!document.body.classList.contains('light-mode')) { e.preventDefault(); e.stopPropagation(); state.valueScrub = { active: true, coneIndex: i, coordIndex: idx, startY: e.clientY }; } })); state.uiCache[i] = { title, x: document.getElementById(`x-${i}`), y: document.getElementById(`y-${i}`), z: document.getElementById(`z-${i}`), lastPos: [null, null, null], lastActive: null }; });
            setupColorTooltip(); if (window.location.hash && window.location.hash.length > 1) { const matchPos = findPositionFromColor(window.location.hash); if (matchPos) triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(window.location.hash), true); }
            requestAnimationFrame(loop);
        }
        async function createAssets() { const dev = state.device, sphereGeo = createSphere(1.0, 128, 128), coneGeo = createCone(0.1, 0.3, 64); state.buffers.sphereVertex = createBuffer(dev, sphereGeo.p, GPUBufferUsage.VERTEX); state.buffers.sphereNormal = createBuffer(dev, sphereGeo.n, GPUBufferUsage.VERTEX); state.buffers.sphereIndex = createBuffer(dev, sphereGeo.i, GPUBufferUsage.INDEX); state.sphere.indexCount = sphereGeo.i.length; state.buffers.coneVertex = createBuffer(dev, coneGeo.p, GPUBufferUsage.VERTEX); state.buffers.coneIndex = createBuffer(dev, coneGeo.i, GPUBufferUsage.INDEX); state.coneIndexCount = coneGeo.i.length; state.buffers.sphereUniform = dev.createBuffer({ size: 320, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); state.buffers.coneUniform = dev.createBuffer({ size: 65536, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); const sm = dev.createShaderModule({ code: gradientShaderWGSL }), cm = dev.createShaderModule({ code: solidShaderWGSL }); state.pipelines.sphere = dev.createRenderPipeline({ layout: 'auto', vertex: { module: sm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }, { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }] }, fragment: { module: sm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } }); state.pipelines.cone = dev.createRenderPipeline({ layout: 'auto', vertex: { module: cm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }] }, fragment: { module: cm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } }); state.bindGroups.sphere = dev.createBindGroup({ layout: state.pipelines.sphere.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.sphereUniform } }] }); state.getBindGroupForHandle = (idx) => dev.createBindGroup({ layout: state.pipelines.cone.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.coneUniform, offset: idx * 256, size: 80 } }] }); state.bindGroups.cones = [0, 1, 2, 3].map(i => state.getBindGroupForHandle(i)); }
        function createBuffer(dev, data, usage) { const buf = dev.createBuffer({ size: data.byteLength, usage: usage | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); (data instanceof Float32Array ? new Float32Array(buf.getMappedRange()) : new Uint16Array(buf.getMappedRange())).set(data); buf.unmap(); return buf; }
        function createSphere(r, latB, longB) { const p = [], n = [], idx = []; for (let la = 0; la <= latB; la++) for (let lo = 0; lo <= longB; lo++) { const th = la * Math.PI / latB, ph = lo * 2 * Math.PI / longB, x = Math.cos(ph) * Math.sin(th), y = Math.cos(th), z = Math.sin(ph) * Math.sin(th); n.push(x, y, z); p.push(r * x, r * y, r * z); } for (let la = 0; la < latB; la++) for (let lo = 0; lo < longB; lo++) { const f = (la * (longB + 1)) + lo, s = f + longB + 1; idx.push(f, f + 1, s, s, f + 1, s + 1); } return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function createCone(r, h, s) { const p = [0, h, 0], n = [0, 1, 0], idx = []; for (let i = 0; i <= s; i++) { const th = i * 2 * Math.PI / s, x = r * Math.cos(th), z = r * Math.sin(th); p.push(x, 0, z); const nv = Vec3.normalize([x, .5, z]); n.push(nv[0], nv[1], nv[2]); } p.push(0, 0, 0); n.push(0, -1, 0); const bc = p.length / 3 - 1; for (let i = 1; i <= s; i++) idx.push(0, i, i + 1, bc, i + 1, i); return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function pathToVertices(pathPoints, sphereRotation) { if (pathPoints.length < 2) return null; const WIDTH = 0.015; const PROTRUDE = 1.02; const path = pathPoints.map(p => { const wp = transformPos(p, sphereRotation); return Vec3.scale(Vec3.normalize(wp), PROTRUDE); }); const tangents = []; for (let i = 0; i < path.length; i++) { let dir; if (i === 0) { dir = Vec3.sub(path[1], path[0]); } else if (i === path.length - 1) { dir = Vec3.sub(path[i], path[i - 1]); } else { dir = Vec3.sub(path[i + 1], path[i - 1]); } const radial = Vec3.normalize(path[i]); let tangent = Vec3.cross(dir, radial); const tLen = Vec3.len(tangent); if (tLen < 0.001) { tangent = Vec3.cross(dir, [0, 1, 0]); if (Vec3.len(tangent) < 0.001) tangent = Vec3.cross(dir, [1, 0, 0]); } tangents.push(Vec3.scale(Vec3.normalize(tangent), WIDTH)); } const vertices = []; for (let i = 1; i < path.length; i++) { const p0 = path[i - 1], p1 = path[i]; const t0 = tangents[i - 1], t1 = tangents[i]; const v0p = Vec3.add(p0, t0), v0m = Vec3.sub(p0, t0); const v1p = Vec3.add(p1, t1), v1m = Vec3.sub(p1, t1); vertices.push(...v1p, ...v1m, ...v0m); vertices.push(...v1p, ...v0m, ...v0p); } return new Float32Array(vertices); }
        function onResize() { if (!state.device) return; const w = state.canvas.clientWidth; const h = state.canvas.clientHeight; state.canvas.width = w; state.canvas.height = h; if (state.msaaTexture) state.msaaTexture.destroy(); if (state.depthTexture) state.depthTexture.destroy(); state.msaaTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: state.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT }); state.depthTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: 'depth24plus', usage: GPUTextureUsage.RENDER_ATTACHMENT }); const aspect = w / h; const newZ = aspect < 1 ? 3.5 / aspect : 4; if (!state.landing.active && (!state.returning || !state.returning.active)) { state.cameraPos = [0, 0, newZ]; } if (state.returning) state.returning.targetDist = newZ; }
        function getMouseRay(x, y) { const aspect = state.canvas.width / state.canvas.height, ndcX = (x / state.canvas.width) * 2 - 1, ndcY = -(y / state.canvas.height) * 2 + 1; const dir = Vec3.normalize([ndcX * aspect * Math.tan(Math.PI / 8), ndcY * Math.tan(Math.PI / 8), -1]); return { o: state.cameraPos, d: dir }; }
        function getTargetPos(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)); return Vec3.dot(p, p) <= 1 ? Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))) : Vec3.scale(Vec3.normalize(p), 1); }
        function calculateConePosition(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)), dist = Math.sqrt(Vec3.dot(p, p)), R = 1.2; if (dist <= R) return Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(R * R - Vec3.dot(p, p)))); const axis = Vec3.cross(Vec3.normalize(r.o), r.d); return Vec3.scale(transformPos(Vec3.normalize(r.o), Mat4.rotationAxis(Vec3.normalize(Vec3.len(axis) < .001 ? [1, 0, 0] : axis), Math.acos(R / Vec3.len(r.o)) + (dist - R))), R); }
        function transformPos(p, m) { return [m[0] * p[0] + m[4] * p[1] + m[8] * p[2] + m[12], m[1] * p[0] + m[5] * p[1] + m[9] * p[2] + m[13], m[2] * p[0] + m[6] * p[1] + m[10] * p[2] + m[14]]; }
        function projectToScreen(worldPos) { const m = state.vpMatrix, x = worldPos[0], y = worldPos[1], z = worldPos[2], clipX = x * m[0] + y * m[4] + z * m[8] + m[12], clipY = x * m[1] + y * m[5] + z * m[9] + m[13], clipW = x * m[3] + y * m[7] + z * m[11] + m[15]; if (clipW <= 0) return null; return { x: (clipX / clipW + 1) * state.canvas.width / 2, y: (1 - clipY / clipW) * state.canvas.height / 2 }; }
        function onMouseDown(e) { if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav')) return; if (state.valueScrub.active) return; const rect = state.canvas.getBoundingClientRect(); state.mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top, down: true }; state.clickData = { startX: state.mouse.x, startY: state.mouse.y, startTime: Date.now() }; state.interactionSignature = { type: 'click', path: [] }; state.pathPoints = []; state.pathStartPos = null; if (document.body.classList.contains('light-mode')) { state.inertia.val = 0; let clickedExisting = false; for (let h of state.historyHandles) { const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation)); if (sp && Math.sqrt((state.mouse.x - sp.x) ** 2 + (state.mouse.y - sp.y) ** 2) < 20) { clickedExisting = true; break; } } const p = getTargetPos(state.mouse.x, state.mouse.y); const r = getMouseRay(state.mouse.x, state.mouse.y); const hit = Vec3.dot(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))), Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)))) <= 1; if (hit) { state.interaction = { mode: 'zoom', hasTouchedSphere: true, startZ: state.cameraPos[2], startMouse: { x: state.mouse.x, y: state.mouse.y } }; const m = state.sphere.rotation; const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]); const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100]; state.pathPoints = [rounded]; state.interactionSignature.path = [rounded]; startDragLogic(p, clickedExisting); } else { state.interaction = { mode: 'waiting', hasTouchedSphere: false }; state.handle.active = false; state.dragStart.active = false; } state.hasRotated = true; } }
        function startDragLogic(p, clickedExisting) { state.dragStart = { active: true, mouseDir: Vec3.normalize(p), sphereRotation: [...state.sphere.rotation], conePositions: state.cones.map(c => [...c.pos]), lastTrackPos: p }; if (!clickedExisting) { state.handle = { active: true, pos: p, color: getSurfaceColor(p, Vec3.normalize(p)) }; } }
        function onMouseMove(e) { const r = state.canvas.getBoundingClientRect(); state.mouse.x = e.clientX - r.left; state.mouse.y = e.clientY - r.top; if (state.mouse.down && state.interaction && state.interaction.mode === 'waiting') { const ray = getMouseRay(state.mouse.x, state.mouse.y); const closest = Vec3.add(ray.o, Vec3.scale(ray.d, Vec3.dot(Vec3.sub([0, 0, 0], ray.o), ray.d))); const onSphere = Vec3.dot(closest, closest) <= 1; if (onSphere) { const p = getTargetPos(state.mouse.x, state.mouse.y); state.interaction.mode = 'normal'; state.interaction.hasTouchedSphere = true; state.interactionSignature.type = 'drag'; const m = state.sphere.rotation; const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]); const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100]; state.pathPoints = [rounded]; state.interactionSignature.path = [rounded]; startDragLogic(p, false); } } if (state.mouse.down && state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active) { const m = state.sphere.rotation; const localCenterPos = [m[2], m[6], m[10]]; const lastPoint = state.pathPoints[state.pathPoints.length - 1]; if (!lastPoint || Vec3.dist(localCenterPos, lastPoint) > 0.01) { const normalized = Vec3.normalize(localCenterPos); const rounded = [Math.round(normalized[0] * 100) / 100, Math.round(normalized[1] * 100) / 100, Math.round(normalized[2] * 100) / 100]; state.pathPoints.push(rounded); state.interactionSignature.type = 'drag'; state.interactionSignature.path.push(rounded); } if (state.pathPoints.length > 500) state.pathPoints.shift(); if (state.interactionSignature.path.length > 500) state.interactionSignature.path.shift(); } }
        function onMouseUp(e) { if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav')) return; state.mouse.down = false; state.handle.active = false; const wasDragging = state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active && state.interactionSignature.type === 'drag'; state.interaction = { mode: 'none', hasTouchedSphere: false }; if (state.valueScrub.active) { state.valueScrub.active = false; return; } if (document.body.classList.contains('light-mode')) { const rect = state.canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; if (wasDragging) { const col = getSurfaceColor([0, 0, 1], [0, 0, 1], state.cones); const hex = rgbToHex(col[0], col[1], col[2]); state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [0, 0, 1], showHandle: false, targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))), shouldAutoEnter: false, fromUrl: false, hex: hex, notified: false, rotationAxis: [1, 0, 0], rotationAngle: 0 }; state.handle.color = [...col]; state.hasRotated = true; document.getElementById('color-hex').innerText = hex.toUpperCase(); const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white'; document.getElementById('login-card').style.color = textColor; document.getElementById('top-nav').style.setProperty('--nav-color', textColor); if (window.connectAndPreview) window.connectAndPreview(hex, false); setTimeout(() => { state.pathPoints = []; state.pathStartPos = null; }, 500); return; } if (Math.sqrt((mx - state.clickData.startX) ** 2 + (my - state.clickData.startY) ** 2) < 5 && Date.now() - state.clickData.startTime < 250) { for (let h of state.historyHandles) { const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation)); if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) { try { localStorage.setItem("lastSphereColor", h.hex); } catch (e) { } triggerLanding(h.pos, transformPos(h.pos, state.sphere.rotation), h.color, true); return; } } const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))); if (Vec3.dot(p, p) <= 1) { const hp = Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))); triggerLanding(Vec3.normalize(hp), hp, getSurfaceColor(hp, Vec3.normalize(hp)), false); } } } state.pathPoints = []; state.pathStartPos = null; }
        function triggerLanding(norm, pos, col, fromUrl = false) { state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [...pos], showHandle: !fromUrl, targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))), shouldAutoEnter: false, fromUrl: fromUrl }; const startWorldPos = transformPos(pos, state.landing.baseRotation); state.landing.offset = [0, 0]; state.handle.color = [...col]; state.hasRotated = true; const hex = rgbToHex(col[0], col[1], col[2]); window.parent.postMessage(hex, '*'); document.getElementById('color-hex').innerText = hex.toUpperCase(); const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white'; document.getElementById('login-card').style.color = textColor; document.getElementById('top-nav').style.setProperty('--nav-color', textColor); const cam = Vec3.normalize(state.cameraPos), axis = Vec3.cross(norm, cam), dot = Vec3.dot(norm, cam); state.landing.rotationAxis = Vec3.len(axis) < .001 ? [1, 0, 0] : Vec3.normalize(axis); state.landing.rotationAngle = Vec3.len(axis) < .001 ? (dot > 0 ? 0 : Math.PI) : Math.acos(Math.min(1, Math.max(-1, dot))); if (window.connectAndPreview) window.connectAndPreview(hex, fromUrl); setTimeout(() => { const btn = document.getElementById('freeze-btn'); btn.style.opacity = '0'; setTimeout(() => { btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>'; btn.style.opacity = '1'; }, 200); }, 1000); }
        function getResponsiveZ() { const aspect = state.canvas.width / state.canvas.height; return aspect < 1 ? 3.5 / aspect : 4; }
        function toggleFreeze() {
            // Check if we are in "Zoomed In" mode (either fully logged in OR just looking at the login card)
            const isZoomed = document.getElementById('dashboard-panel').classList.contains('active') ||
                document.getElementById('login-card').classList.contains('visible');

            if (isZoomed) {
                if (window.app && window.app.logout) window.app.logout();
                return;
            }

            const f = document.getElementById('flash-overlay'), isFrozen = document.body.classList.toggle('light-mode');
            state.landing = { active: false, showHandle: false };
            document.getElementById('login-card').classList.remove('visible');
            document.getElementById('dashboard-panel').classList.remove('active');
            state.cameraPos = [0, 0, getResponsiveZ()];
            f.style.backgroundColor = isFrozen ? 'white' : 'black';
            document.body.style.backgroundColor = '';
            f.classList.remove('active');
            void f.offsetWidth;
            f.classList.add('active');
            setTimeout(() => f.classList.remove('active'), 0);
            const btn = document.getElementById('freeze-btn');
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
            btn.style.opacity = '1';
        }
        function getSurfaceColor(p, n, cones = state.cones) { const getI = (i) => { if (!cones[i].active) return 0; const diff = Vec3.sub(cones[i].pos, p); const distSq = Vec3.dot(diff, diff); const L = Vec3.normalize(diff); const wrap = Math.max(Vec3.dot(n, L) + 1.0, 0.0) / 2.0; const spread = Math.pow(wrap, 1.25); return spread * (1.0 / (1.0 + distSq * 0.05)); }; const d = [getI(0), getI(1), getI(2)]; const c = cones.map(x => x.color); let l = Vec3.add(Vec3.add(Vec3.scale(c[0], d[0]), Vec3.scale(c[1], d[1])), Vec3.scale(c[2], d[2])); const boost = (i, j) => { const sumD = d[i] + d[j] + 0.001; const factor = (2.0 * d[i] * d[j] / sumD); return Vec3.scale(Vec3.add(c[i], c[j]), factor); }; l = Vec3.add(l, boost(0, 1)); l = Vec3.add(l, boost(1, 2)); l = Vec3.add(l, boost(2, 0)); const minD = Math.min(d[0], Math.min(d[1], d[2])); const maxD = Math.max(d[0], Math.max(d[1], d[2])); let t = (minD - 0.15) / (0.40 - 0.15); t = Math.max(0.0, Math.min(1.0, t)); const maskBase = t * t * (3.0 - 2.0 * t); const variance = maxD - minD; const roundness = Math.exp(-variance * 10.0); const finalMask = maskBase * roundness; const whiteTarget = [1.0, 1.0, 1.0]; l = [l[0] * (1.0 - finalMask) + whiteTarget[0] * finalMask, l[1] * (1.0 - finalMask) + whiteTarget[1] * finalMask, l[2] * (1.0 - finalMask) + whiteTarget[2] * finalMask]; l = l.map(x => x * 1.2); return l.map(x => { const val = Math.min(Math.max(x, 0), 1); return val * val * (3.0 - 2.0 * val); }); }
        function setupColorTooltip() { const t = document.createElement('div'); t.className = 'sphere-tooltip'; document.body.appendChild(t); window.addEventListener('mousemove', e => { if (!document.body.classList.contains('light-mode') || e.target.closest('#dashboard-panel') || e.target.closest('#login-card') || e.target.closest('#top-nav')) { t.style.display = 'none'; return; } const rect = state.canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top; if (state.landing.showHandle && state.handle.pos) { const handleScreen = projectToScreen(state.handle.pos); if (handleScreen && Math.sqrt((mx - handleScreen.x) ** 2 + (my - handleScreen.y) ** 2) < 50) { t.style.display = 'none'; return; } } for (let h of state.historyHandles) { const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation)); if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) { t.innerHTML = `<span class="hex">${h.hex.toUpperCase()}</span><span class="${h.peerCount > 0 ? "meta online" : "meta"}">${h.peerCount > 0 ? `${h.peerCount} PEER${h.peerCount > 1 ? 'S' : ''} ONLINE` : "OFFLINE"}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${h.hex}`; return; } } const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))); if (Vec3.dot(p, p) > 1) { t.style.display = 'none'; return; } const hex = rgbToHex(...getSurfaceColor(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p)))), Vec3.normalize(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p))))))).toUpperCase(); t.innerHTML = `<span class="hex">${hex}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${hex}`; }); }
        window.resetSphereView = function () { const m = state.sphere.rotation, trace = m[0] + m[5] + m[10]; let angle = Math.acos(Math.max(-1, Math.min(1, (trace - 1) / 2))), axis = [1, 0, 0], diff = [m[6] - m[9], m[8] - m[2], m[1] - m[4]], sl = Math.sqrt(diff[0] ** 2 + diff[1] ** 2 + diff[2] ** 2); if (sl > 0.001) axis = [diff[0] / sl, diff[1] / sl, diff[2] / sl]; state.returning = { active: true, progress: 0, baseRotation: m, rotationAxis: axis, rotationAngle: -angle, startDist: Vec3.len(state.cameraPos), targetDist: getResponsiveZ(), coneStartPositions: state.cones.map(c => [...c.pos]) }; state.landing.active = false; state.landing.showHandle = false; };
        function loop(ts) { const dt = Math.min((ts - state.lastTime) / 1000, 0.1); state.lastTime = ts; if (document.body.classList.contains('light-mode') && state.hasRotated) { document.body.style.backgroundColor = rgbToHex(...getSurfaceColor([0, 0, 1], [0, 0, 1])); } if (state.valueScrub.active && Math.abs(state.valueScrub.startY - state.mouse.y) > 5) { state.cones[state.valueScrub.coneIndex].pos[state.valueScrub.coordIndex] += Math.sign(state.valueScrub.startY - state.mouse.y) * Math.pow((Math.abs(state.valueScrub.startY - state.mouse.y) - 5) / 500, 3) * .05; } let manualCameraZ = null; if (state.mouse.down && state.interaction && state.interaction.mode === 'zoom') { let pathLength = 0; for (let i = 1; i < state.pathPoints.length; i++) { pathLength += Vec3.dist(state.pathPoints[i], state.pathPoints[i - 1]); } const zoomProgress = Math.min(1, pathLength / Math.PI); const startZ = state.interaction.startZ; const targetZ = 1.25; manualCameraZ = startZ - (startZ - targetZ) * zoomProgress; state.cameraPos = [0, 0, manualCameraZ]; } if (state.landing.active) { state.landing.progress = Math.min(state.landing.progress + dt * .5, 1); const t = state.landing.progress; if (t >= 1 && !state.landing.notified) { window.parent.postMessage({ type: 'zoom-complete', color: state.landing.hex }, '*'); state.landing.notified = true; } if (t >= 1) { const card = document.getElementById('login-card'); if (window.self === window.top && !card.classList.contains('visible')) { card.classList.add('visible'); card.style.opacity = ''; } if (state.landing.shouldAutoEnter) { if (window.enterRoomUI && window.self === window.top) window.enterRoomUI(); state.landing.shouldAutoEnter = false; } } const rot = Mat4.rotationAxis(state.landing.rotationAxis, state.landing.rotationAngle * t * t); if (state.landing.showHandle) { state.handle.pos = transformPos(state.landing.handleStartPos, rot); if (t >= 1) state.landing.showHandle = false; } state.sphere.rotation = Mat4.multiply(rot, state.landing.baseRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.landing.coneStartPositions[i], rot)); state.cameraPos = Vec3.scale(Vec3.normalize([0, 0, 4]), state.landing.startDist + (state.landing.targetDist - state.landing.startDist) * t * t * t); } if (state.returning && state.returning.active) { state.returning.progress = Math.min(state.returning.progress + dt * 1.5, 1); const t = state.returning.progress, ease = 1 - Math.pow(1 - t, 3), rot = Mat4.rotationAxis(state.returning.rotationAxis, state.returning.rotationAngle * ease); state.sphere.rotation = Mat4.multiply(rot, state.returning.baseRotation); state.cameraPos = [0, 0, state.returning.startDist + (state.returning.targetDist - state.returning.startDist) * ease]; state.cones.forEach((c, i) => c.pos = transformPos(state.returning.coneStartPositions[i], rot)); if (t >= 1) { state.returning.active = false; state.hasRotated = false; state.sphere.rotation = Mat4.identity(); state.cones = defaultCones.map(c => ({ ...c, pos: [...c.pos], color: [...c.color] })); state.cameraPos = [0, 0, getResponsiveZ()]; document.body.style.backgroundColor = ''; document.getElementById('color-hex').innerText = "#FFFFFF"; document.getElementById('login-card').style.color = ''; document.getElementById('top-nav').style.removeProperty('--nav-color'); document.getElementById('login-card').style.opacity = ''; document.getElementById('login-card').style.transition = ''; } } let renderBackgroundLayer = false; let bgCameraPos = [0, 0, 0]; if (manualCameraZ === null && state.peeking && (state.peeking.active || state.peeking.value > 0)) { const zoomedInZ = state.landing.targetDist || 1.25; const zoomedOutZ = state.landing.startDist || 4.0; const t = state.peeking.value; const ease = t * t * (3 - 2 * t); const currentZ = zoomedInZ + (zoomedOutZ - zoomedInZ) * ease; state.cameraPos = [0, 0, currentZ]; if (t > 0.01) { renderBackgroundLayer = true; bgCameraPos = [0, 0, zoomedInZ]; } } state.vpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(state.cameraPos, [0, 0, 0], [0, 1, 0])); if (!document.body.classList.contains('light-mode')) { state.cones.forEach((c, i) => { const cache = state.uiCache[i]; if (!cache) return; if (cache.lastActive !== c.active) { cache.title.style.color = c.active ? c.cssColor : 'grey'; cache.lastActive = c.active; } ['x', 'y', 'z'].forEach((ax, idx) => { if (Math.abs(c.pos[idx] - cache.lastPos[idx]) > 0.005) { cache[ax].innerText = c.pos[idx].toFixed(2); cache.lastPos[idx] = c.pos[idx]; } }); }); if (state.mouse.down) { const tp = getTargetPos(state.mouse.x, state.mouse.y); if (state.draggedConeIndex === -1 && tp) state.cones.forEach((c, i) => { if (c.active && Vec3.dist(c.pos, tp) < 0.8) state.draggedConeIndex = i; }); if (state.draggedConeIndex !== -1) { const np = calculateConePosition(state.mouse.x, state.mouse.y), c = state.cones[state.draggedConeIndex]; c.vel = Vec3.scale(Vec3.sub(np, c.pos), 1 / dt); c.pos = np; } } else state.draggedConeIndex = -1; state.cones.forEach(c => { if (state.draggedConeIndex === -1 || state.cones[state.draggedConeIndex] !== c) { if (Vec3.len(c.vel) > .001) { c.pos = Vec3.scale(Vec3.normalize(Vec3.add(c.pos, Vec3.scale(c.vel, dt))), 1.2); c.vel = Vec3.scale(c.vel, .95); } else c.pos = Vec3.scale(Vec3.normalize(c.pos), 1.2); } }); } else if (state.mouse.down && state.dragStart.active) { state.landing.active = false; state.landing.showHandle = false; document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active'); const tp = getTargetPos(state.mouse.x, state.mouse.y); if (tp) { state.handle.pos = tp; if (state.dragStart.lastTrackPos) { const axis = Vec3.cross(state.dragStart.lastTrackPos, tp); state.inertia = { active: false, axis: Vec3.len(axis) > 1e-5 ? Vec3.normalize(axis) : [1, 0, 0], val: Vec3.len(axis) }; } state.dragStart.lastTrackPos = tp; const a = Vec3.cross(state.dragStart.mouseDir, Vec3.normalize(tp)); if (Vec3.len(a) > .001) { const r = Mat4.rotationAxis(Vec3.normalize(a), Math.acos(Math.min(1, Math.max(-1, Vec3.dot(state.dragStart.mouseDir, Vec3.normalize(tp)))))); state.sphere.rotation = Mat4.multiply(r, state.dragStart.sphereRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.dragStart.conePositions[i], r)); } } } else { state.dragStart.active = false; state.handle.active = false; if (state.inertia.val > 0.0001) { const r = Mat4.rotationAxis(state.inertia.axis, state.inertia.val); state.sphere.rotation = Mat4.multiply(r, state.sphere.rotation); state.cones.forEach(c => c.pos = transformPos(c.pos, r)); state.inertia.val *= 0.95; } } if (state.device && state.pipelines.sphere && state.msaaTexture) { const drawSphere = (encoder, viewProjMatrix, loadOp, depthOp) => { state.uniforms.sphere.set(Mat4.multiply(viewProjMatrix, state.sphere.rotation), 0); state.uniforms.sphere.set(state.sphere.rotation, 16); state.uniforms.sphere.set(state.sphere.rotation, 32); state.uniforms.sphere.set(state.cameraPos, 48);[0, 1, 2].forEach(i => { state.uniforms.sphere.set(state.cones[i].pos, 52 + i * 8); state.uniforms.sphere.set(state.cones[i].active ? state.cones[i].color : [0, 0, 0], 56 + i * 8); }); state.uniforms.sphere[76] = state.debugMode ? 1.0 : 0.0; state.device.queue.writeBuffer(state.buffers.sphereUniform, 0, state.uniforms.sphere); const pass = encoder.beginRenderPass({ colorAttachments: [{ view: state.msaaTexture.createView(), resolveTarget: state.context.getCurrentTexture().createView(), clearValue: document.body.classList.contains('light-mode') ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, g: 0, b: 0, a: 1 }, loadOp: loadOp, storeOp: 'store' }], depthStencilAttachment: { view: state.depthTexture.createView(), depthClearValue: 1, depthLoadOp: 'clear', depthStoreOp: depthOp } }); pass.setPipeline(state.pipelines.sphere); pass.setBindGroup(0, state.bindGroups.sphere); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setVertexBuffer(1, state.buffers.sphereNormal); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16'); pass.drawIndexed(state.sphere.indexCount); return pass; }; const drawCones = (pass) => { pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, document.body.classList.contains('light-mode') ? state.buffers.sphereVertex : state.buffers.coneVertex); pass.setIndexBuffer(document.body.classList.contains('light-mode') ? state.buffers.sphereIndex : state.buffers.coneIndex, 'uint16'); if (!document.body.classList.contains('light-mode')) { state.cones.forEach((c, i) => { if (c.active) { let m; if (Vec3.len(Vec3.cross([0, 1, 0], c.pos)) > .001) { const y = Vec3.normalize(c.pos), x = Vec3.normalize(Vec3.cross(Vec3.len(Vec3.cross([0, 1, 0], y)) < .01 ? [0, 0, 1] : [0, 1, 0], y)), z = Vec3.cross(x, y); m = [x[0], x[1], x[2], 0, y[0], y[1], y[2], 0, z[0], z[1], z[2], 0, c.pos[0], c.pos[1], c.pos[2], 1]; } else m = Mat4.multiply(Mat4.translation(c.pos), c.pos[1] < 0 ? Mat4.rotationX(Math.PI) : Mat4.identity()); state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(m, Mat4.scale([.5, .5, .5]))), 0); state.uniforms.cone.set([...c.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, i * 256, state.uniforms.cone); pass.setBindGroup(0, state.bindGroups.cones[i]); pass.drawIndexed(state.coneIndexCount); } }); } else { let bindIdx = 4; if (state.handle.active || state.landing.showHandle) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(state.handle.pos), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...state.handle.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, 3 * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(3)); pass.drawIndexed(state.sphere.indexCount); } state.historyHandles.forEach(h => { const wp = transformPos(h.pos, state.sphere.rotation); if (wp[2] > -0.5) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(wp), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...h.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.drawIndexed(state.sphere.indexCount); bindIdx++; } }); if (state.pathPoints.length > 1 && (state.dragStart.active || state.landing.active)) { const pathVerts = pathToVertices(state.pathPoints, state.sphere.rotation); if (pathVerts && pathVerts.length > 0) { if (!state.buffers.pathVertex || state.buffers.pathVertex.size < pathVerts.byteLength) { if (state.buffers.pathVertex) state.buffers.pathVertex.destroy(); state.buffers.pathVertex = state.device.createBuffer({ size: Math.max(pathVerts.byteLength, 1024 * 12), usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST }); } state.device.queue.writeBuffer(state.buffers.pathVertex, 0, pathVerts); state.uniforms.cone.set(state.vpMatrix, 0); state.uniforms.cone.set([1, 1, 1, 1], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setPipeline(state.pipelines.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.setVertexBuffer(0, state.buffers.pathVertex); pass.draw(pathVerts.length / 3); } } } }; if (renderBackgroundLayer) { const bgEncoder = state.device.createCommandEncoder(); const bgVpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(bgCameraPos, [0, 0, 0], [0, 1, 0])); const bgPass = drawSphere(bgEncoder, bgVpMatrix, 'clear', 'discard'); bgPass.end(); state.device.queue.submit([bgEncoder.finish()]); const fgEncoder = state.device.createCommandEncoder(); const fgPass = drawSphere(fgEncoder, state.vpMatrix, 'load', 'discard'); drawCones(fgPass); fgPass.end(); state.device.queue.submit([fgEncoder.finish()]); } else { const encoder = state.device.createCommandEncoder(); const pass = drawSphere(encoder, state.vpMatrix, 'clear', 'discard'); drawCones(pass); pass.end(); state.device.queue.submit([encoder.finish()]); } } requestAnimationFrame(loop); }
        init();
        window.updateVisitedFromDB = async function () { const rooms = await (new window.ColorDB()).getAllRooms(); state.historyHandles = []; if (rooms?.length) { rooms.forEach(r => { const p = findPositionFromColor('#' + r.hex); if (p) state.historyHandles.push({ pos: Vec3.normalize(p), color: hexToRgbNormalized('#' + r.hex), hex: '#' + r.hex, peerCount: 0 }); }); } };
        window.addEventListener("message", (e) => { if (e.data === "getSphereColor") e.source.postMessage(storageScope.getItem("lastSphereColor") || "#ff0000", e.origin); if (e.data?.type === 'handle-ready') { const hex = e.data.hex, pos = findPositionFromColor(hex); if (pos && !state.historyHandles.some(h => h.hex === hex)) { state.historyHandles.push({ pos: Vec3.normalize(pos), color: hexToRgbNormalized(hex), hex, peerCount: e.data.count }); const d = document.createElement('div'); d.className = 'debug-room-item ' + (e.data.count > 0 ? 'active' : ''); d.innerHTML = `<span>${hex}</span> <span class="count">${e.data.count} peer(s)</span>`; document.getElementById('debug-rooms').appendChild(d); } } });
        async function initStorageAccess() { if (window.self === window.top) return; const triggerZoomToColor = (hexColor) => { const matchPos = findPositionFromColor(hexColor); if (matchPos) { if (!document.body.classList.contains('light-mode')) { document.body.classList.add('light-mode'); } triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(hexColor), true); const checkLandingComplete = () => { if (state.landing.progress >= 1) { window.parent.postMessage({ type: 'zoom-done', color: hexColor }, "*"); } else if (state.landing.active) { requestAnimationFrame(checkLandingComplete); } }; requestAnimationFrame(checkLandingComplete); } }; const access = async (h) => { try { if (h?.localStorage) storageScope = h.localStorage; const c = storageScope.getItem("lastSphereColor"); if (c) { window.parent.postMessage(c, "*"); if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove(); document.body.style.backgroundColor = c; triggerZoomToColor(c); } else { window.parent.postMessage({ type: 'no-color' }, "*"); if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove(); } } catch (e) { } }; try { if (await document.hasStorageAccess()) try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { access(null); } else { const o = document.createElement('div'); o.id = 'saa-overlay'; Object.assign(o.style, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: '#fff', zIndex: 10000, display: 'flex', justifyContent: 'center', alignItems: 'center' }); const b = document.createElement("button"); b.innerText = "LOGIN"; Object.assign(b.style, { padding: "12px 24px", fontSize: "16px", cursor: "pointer", background: "#000", color: "#fff", border: "none", borderRadius: "8px" }); o.appendChild(b); document.body.appendChild(o); b.onclick = async () => { try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { o.innerHTML = "Access Denied"; } }; } } catch (e) { } }
        initStorageAccess();
    </script>
</body>

</html>
