<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color</title>

    <style>
        /* --- CORE STYLES --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            transition: background-color 0.1s linear;
            user-select: none;
        }

        body.light-mode {
            background-color: #f0f0f0;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        #flash-overlay.active {
            opacity: 1;
            transition: none;
        }

        /* --- LOGIN CARD --- */
        #login-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
            color: white;
        }

        #login-card.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #color-hex {
            font-size: 5rem;
            font-weight: 900;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            line-height: 1;
        }

        #room-status {
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            margin: 15px 0 25px 0;
            opacity: 0.7;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-height: 1.2em;
            font-weight: bold;
        }

        #login-btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 12px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-decoration: none;
        }

        #login-btn:hover {
            background: currentColor;
            opacity: 0.8;
        }

        #login-btn:hover span {
            filter: invert(1);
        }

        #login-btn.hidden {
            display: none;
        }

        /* --- UI OVERLAYS --- */
        #hover-trigger {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 3vh;
            z-index: 300;
            display: none;
        }

        #top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 12vh;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            z-index: 150;
            transition: opacity 0.5s ease;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.4), transparent);
            opacity: 0;
            pointer-events: none;
        }

        #top-nav.active {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-item {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            opacity: 0.8;
            transition: 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--nav-color, white);
        }

        .nav-item:hover {
            opacity: 1;
            transform: translateY(2px);
        }

        /* --- DASHBOARD --- */
        #dashboard-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100vw;
            height: 98vh;
            background-color: white;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -20px 50px rgba(0, 0, 0, 0.2);
            padding: 0;
        }

        #dashboard-panel.active {
            transform: translateY(0);
        }

        #dashboard-panel.active.revealed {
            transform: translateY(12vh);
        }

        /* --- DEBUG & TOOLS --- */
        #debug-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 10px;
            z-index: 2000;
            color: #0f0;
            font-family: 'Menlo', monospace;
            font-size: 12px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
        }

        #debug-panel.visible {
            display: block;
        }

        #debug-rooms {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .debug-room-item {
            padding: 4px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .debug-room-item .count {
            color: #fff;
            font-weight: bold;
        }

        .debug-room-item.active {
            color: #00e676;
        }

        #debug-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Menlo', monospace;
            font-size: 0.8rem;
            z-index: 10;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        #debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        body.light-mode #debug-btn {
            color: black;
            border-color: rgba(0, 0, 0, 0.2);
            background: rgba(0, 0, 0, 0.1);
        }

        #debug-btn.active {
            background: rgba(255, 0, 0, 0.5);
            border-color: red;
            color: white;
        }

        #reset-btn {
            margin-top: 10px;
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
        }

        #reset-btn:hover {
            background: #900;
        }

        /* TOOLTIP */
        .sphere-tooltip {
            position: absolute;
            display: none;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-Family: monospace;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(15px, 15px);
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
        }

        .sphere-tooltip .hex {
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            margin-bottom: 2px;
            display: block;
        }

        .sphere-tooltip .meta {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sphere-tooltip .meta.online {
            color: #00e676;
            font-weight: bold;
        }

        /* CHAT UI */
        #chat-header {
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-family: -apple-system, system-ui, sans-serif;
            flex-shrink: 0;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .dot.on {
            background: #00e676;
            box-shadow: 0 0 5px #00e676;
        }

        #user-badge {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #999;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #fff;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
        }

        #display {
            min-height: 100%;
            outline: none;
            padding: 40px 60px;
            font-size: 16px;
            line-height: 24px;
            position: relative;
        }

        .editor-line {
            min-height: 24px;
            display: block;
            padding-left: 5px;
            border-left: 4px solid transparent;
            white-space: pre-wrap;
            transition: border-left-color 0.4s ease;
        }

        .editor-line:hover,
        .editor-line.group-hover {
            border-left-color: var(--owner-color, transparent);
        }

        .locked-line {
            background-color: rgba(0, 0, 0, 0);
            border-left-width: 3px !important;
            border-left-color: var(--lock-color) !important;
        }

        .locked-tag {
            position: absolute;
            left: 0;
            top: 0;
            transform: translateX(-100%);
            height: 100%;
            background-color: var(--lock-color);
            color: transparent;
            font-family: sans-serif;
            font-size: 10px;
            white-space: nowrap;
            width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px 0 0 2px;
            pointer-events: auto;
            transition: width 0.3s, opacity 0.1s;
        }

        .locked-line:hover .locked-tag {
            width: 20px;
            opacity: 1;
            color: transparent;
        }

        .locked-line .locked-tag:hover {
            width: 60px !important;
            padding: 0 6px;
            color: #fff !important;
            z-index: 999;
            color: 0.4s ease-in;
        }

        #minimap {
            position: absolute;
            right: 5px;
            top: 60px;
            bottom: 0;
            width: 12px;
            z-index: 201;
            pointer-events: none;
        }

        .scroll-dot {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: top 0.1s ease-out;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        #tools {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 10px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 205;
        }

        #tools.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #tools button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
            font-weight: bold;
        }

        #freeze-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 10;
        }

        body.light-mode #freeze-btn {
            background: rgba(0, 0, 0, 0.1);
            color: #000;
            border-color: rgba(0, 0, 0, 0.2);
        }

        #tracker {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 10;
            pointer-events: none;
        }

        body.light-mode #tracker {
            display: none;
        }

        .cone-data {
            display: flex;
            gap: 8px;
            font-size: 11px;
            font-family: 'Menlo', monospace;
            color: rgba(255, 255, 255, 0.6);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
            pointer-events: auto;
            cursor: default;
        }

        .cone-data:last-child {
            border-right: none;
            padding-right: 0;
        }

        .cone-title {
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
        }

        .coord-val {
            color: white;
            min-width: 38px;
            cursor: ns-resize;
        }
    </style>
</head>

<body class="light-mode">
    <canvas id="gpu-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="hover-trigger"></div>

    <nav id="top-nav">
        <div class="nav-item">Settings</div>
        <div class="nav-item">Home</div>
        <div class="nav-item logout" id="logout-btn">Logout âœ•</div>
    </nav>

    <div id="login-card">
        <div id="color-hex">#FFFFFF</div>
        <div id="room-status">Initializing...</div>
        <button id="login-btn"><span>LOGIN</span></button>
    </div>

    <button id="debug-btn">DEBUG OFF</button>
    <div id="debug-panel">
        <h3>System Tools</h3>
        <button id="reset-btn">WIPE ALL DATA</button>
        <h4>Discovered Rooms</h4>
        <div id="debug-rooms"></div>
    </div>

    <div id="dashboard-panel">
        <div id="chat-header">
            <div><span id="user-badge" title="Your Color"></span></div>
            <div class="status"><span class="dot"></span><span id="peer-count">Disconnected</span></div>
        </div>
        <div id="chat-container">
            <div id="display" contenteditable="true" spellcheck="false"></div>
        </div>
        <div id="minimap"></div>
    </div>

    <div id="tools">
        <button id="btn-bold">B</button>
        <button id="btn-italic">I</button>
        <button id="btn-link">ðŸ”—</button>
    </div>

    <div id="freeze-btn"><svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none"
            stroke-width="2">
            <path d="M9 18h6" />
            <path d="M10 22h4" />
            <path
                d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" />
        </svg></div>
    <div id="tracker">
        <div class="cone-data" id="data-0"></div>
        <div class="cone-data" id="data-1"></div>
        <div class="cone-data" id="data-2"></div>
    </div>

    <!-- P2P APP SCRIPT -->
    <script type="module">

        import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

        class ColorDB {
            constructor() {
                console.log('[ColorDB] Constructor called - initializing database wrapper');
                this.dbName = 'ColorDB';
                this.dbVersion = 1;
                this.db = null;
            }

            init() {
                console.log('[ColorDB] init() called - opening IndexedDB...');
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    request.onerror = (event) => {
                        console.error('[ColorDB] ERROR opening IndexedDB:', event);
                        reject(event);
                    };
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log('[ColorDB] IndexedDB opened successfully');
                        resolve(this.db);
                    };
                    request.onupgradeneeded = (event) => {
                        console.log('[ColorDB] Upgrade needed - creating/updating schema...');
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('rooms')) {
                            console.log('[ColorDB] Creating "rooms" object store');
                            db.createObjectStore('rooms', { keyPath: 'hex' });
                        }
                    };
                });
            }

            async getRoom(hex) {
                console.log(`[ColorDB] getRoom() called for hex: ${hex}`);
                if (!this.db) {
                    console.log('[ColorDB] DB not initialized, calling init()...');
                    await this.init();
                }
                return new Promise(resolve => {
                    const transaction = this.db.transaction(['rooms'], 'readonly');
                    const store = transaction.objectStore('rooms');
                    const req = store.get(hex);
                    req.onsuccess = () => {
                        console.log(`[ColorDB] getRoom() result for ${hex}:`, req.result ? 'FOUND' : 'NOT FOUND', req.result);
                        resolve(req.result);
                    };
                    req.onerror = () => {
                        console.error(`[ColorDB] getRoom() ERROR for ${hex}`);
                        resolve(null);
                    };
                });
            }

            async saveRoom(hex, skeleton, content) {
                console.log(`[ColorDB] saveRoom() called for hex: ${hex}, skeleton length: ${skeleton?.length}, content keys: ${Object.keys(content || {}).length}`);
                if (!this.db) {
                    console.log('[ColorDB] DB not initialized, calling init()...');
                    await this.init();
                }
                return new Promise(resolve => {
                    const transaction = this.db.transaction(['rooms'], 'readwrite');
                    const store = transaction.objectStore('rooms');
                    const data = {
                        hex: hex,
                        lastUpdated: Date.now(),
                        skeleton: skeleton, // Array of IDs ordered
                        content: content    // Map of ID -> HTML
                    };
                    store.put(data);
                    transaction.oncomplete = () => {
                        console.log(`[ColorDB] saveRoom() completed for ${hex}`);
                        resolve();
                    };
                    transaction.onerror = () => {
                        console.error(`[ColorDB] saveRoom() ERROR for ${hex}`);
                        resolve();
                    };
                });
            }

            async getAllRooms() {
                console.log('[ColorDB] getAllRooms() called');
                if (!this.db) {
                    console.log('[ColorDB] DB not initialized, calling init()...');
                    await this.init();
                }
                return new Promise(resolve => {
                    const transaction = this.db.transaction(['rooms'], 'readonly');
                    const store = transaction.objectStore('rooms');
                    const req = store.getAll();
                    req.onsuccess = () => {
                        console.log(`[ColorDB] getAllRooms() found ${req.result?.length || 0} rooms`);
                        resolve(req.result);
                    };
                    req.onerror = () => {
                        console.error('[ColorDB] getAllRooms() ERROR');
                        resolve([]);
                    };
                });
            }
        }

        // Export to window for sphere script
        window.ColorDB = ColorDB;


        class EditorApp {
            constructor() {
                console.log('[EditorApp] ========== CONSTRUCTOR STARTED ==========');
                console.log('[EditorApp] Initializing P2P Editor Application...');
                this.STORAGE_KEY = 'p2p_editor_user_v1';
                this.VISITED_KEY = 'p2p_visited_rooms_v1';

                this.ui = {
                    display: document.getElementById('display'),
                    container: document.getElementById('chat-container'),
                    minimap: document.getElementById('minimap'),
                    peerCount: document.getElementById('peer-count'),
                    dot: document.querySelector('.dot'),
                    tools: document.getElementById('tools'),
                    status: document.getElementById('room-status'),
                    btn: document.getElementById('login-btn'),
                    userBadge: document.getElementById('user-badge'),
                    loginCard: document.getElementById('login-card'),
                    dashboard: document.getElementById('dashboard-panel'),
                    logoutBtn: document.getElementById('logout-btn'),
                    hoverTrigger: document.getElementById('hover-trigger'),
                    topNav: document.getElementById('top-nav')
                };

                // FIX 1: Initialize IDB Wrapper
                console.log('[EditorApp] Initializing ColorDB...');
                this.db = new ColorDB();
                this.db.init().then(() => {
                    console.log('[EditorApp] ColorDB initialized successfully');
                }).catch(err => {
                    console.error('[EditorApp] ColorDB initialization failed:', err);
                });

                this.user = JSON.parse(localStorage.getItem(this.STORAGE_KEY)) || {
                    id: 'user_' + Math.random().toString(36).substr(2, 9),
                    color: '#000000'
                };
                console.log('[EditorApp] User loaded:', this.user);
                this.visitedRooms = JSON.parse(localStorage.getItem(this.VISITED_KEY)) || [];
                console.log(`[EditorApp] Visited rooms loaded: ${this.visitedRooms.length} rooms`);

                this.room = null;
                this.room = null;
                // this.roomDB = null; // Removed GunDB ref
                this.roomId = null;
                this.actions = {};
                this.activeLocks = {};
                this.currentLineId = null;
                this.isFresh = true;
                this.hasAutoScrolled = false;
                this.pendingRemoteData = null; // Store remote data for conflict resolution
                this.statusTimeoutAttempts = 20; // Default to 20 (5 seconds)
                this.lastLineCount = 0;

                this.bindEvents();
                this.setupGlobalExposure();
                console.log('[EditorApp] Events bound and globals exposed');

                if (!window.location.hash || window.location.hash.length < 2) {
                    console.log('[EditorApp] No hash in URL, running sequenced scan');
                    this.runSequencedScan();
                } else {
                    console.log(`[EditorApp] URL hash detected: ${window.location.hash}`);
                    // AUTO-CONNECT: Try to load from local DB immediately
                    this.tryAutoConnectFromHash();
                }
            }

            async tryAutoConnectFromHash() {
                const hex = window.location.hash.replace('#', '');
                console.log(`[EditorApp] tryAutoConnectFromHash() for hex: ${hex}`);

                this.statusTimeoutAttempts = 20; // URL hash needs full 5s delay

                this.roomId = 'doc-infinite-' + hex;
                this.user.color = '#' + hex;
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.user));
                this.ui.userBadge.style.backgroundColor = this.user.color;

                // Check if we have local data for this color
                const localData = await this.db.getRoom(hex);

                if (localData && localData.skeleton && localData.skeleton.length > 0) {
                    console.log(`[EditorApp] Found local data for ${hex} - ${localData.skeleton.length} lines`);
                    console.log('[EditorApp] BYPASSING Initializing status - loading directly from local DB');

                    // Load local data immediately
                    await this.renderFromLocalDB();

                    // Enter room UI immediately (skip login card entirely)
                    this.enterRoomUI();

                    // Join network in background - will handle conflicts
                    this.joinNetworkWithConflictDetection();
                } else {
                    console.log(`[EditorApp] No local data for ${hex} - showing login card`);
                    // No local data, show the normal login flow
                    this.ui.loginCard.classList.add('visible');
                    this.ui.status.innerText = "Checking Network...";

                    // Start network connection
                    this.joinNetwork(false);

                    // Generate fresh content after delay if still empty
                    setTimeout(async () => {
                        if (!this.ui.display.querySelector('.editor-line')) {
                            console.log('[EditorApp] No content after timeout, generating fresh');
                            this.ui.display.innerHTML = this.generateFreshLines();
                            this.isFresh = true;
                            this.ui.status.innerText = "COLOR AVAILABLE";
                        }
                    }, 3000);
                }
            }

            joinNetworkWithConflictDetection() {
                console.log('[EditorApp] joinNetworkWithConflictDetection() - connecting in background');

                try {
                    this.room = joinRoom({
                        appId: 'doc-infinite-v5-idb',
                        trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io']
                    }, this.roomId);
                    console.log('[EditorApp] Background room created');
                } catch (e) {
                    console.error('[EditorApp] Failed to create background room:', e);
                    return;
                }

                const [sendSkeleton, getSkeleton] = this.room.makeAction('skeleton');
                const [sendFragment, getFragment] = this.room.makeAction('fragment');
                const [sendLock, getLock] = this.room.makeAction('lock');
                const [reqSync, getReqSync] = this.room.makeAction('req');

                this.actions = { sendSkeleton, sendFragment, sendLock, reqSync };

                // Handle incoming skeleton - check for conflicts
                getSkeleton((ids, peerId) => {
                    console.log(`[EditorApp] RECEIVED skeleton from peer ${peerId}, ${ids?.length || 0} IDs`);

                    // Get our current local IDs
                    const myIds = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                    const myContent = this.ui.display.innerText.trim();

                    // Check if this is significantly different (conflict)
                    const idsDifferent = JSON.stringify(myIds.slice(0, 10)) !== JSON.stringify((ids || []).slice(0, 10));

                    if (idsDifferent && myContent.length > 10) {
                        console.log('[EditorApp] CONFLICT DETECTED - local data differs from remote');
                        this.pendingRemoteData = { skeleton: ids, peerId };

                        // Ask user what to do
                        const syncWithPeers = confirm(
                            `Other users are in this room with different content.\n\n` +
                            `â€¢ Click OK to sync with them (your local changes may be overwritten)\n` +
                            `â€¢ Click Cancel to stay offline with your local content`
                        );

                        if (syncWithPeers) {
                            console.log('[EditorApp] User chose to sync with peers');
                            this.handleRemoteSkeleton(ids);
                            // Request full content
                            this.actions.reqSync(null);
                        } else {
                            console.log('[EditorApp] User chose to stay offline');
                            // Disconnect from room
                            try { this.room.leave(); } catch (e) { }
                            this.room = null;
                            this.actions = {};
                            this.ui.peerCount.innerText = "Offline (by choice)";
                            this.ui.dot.classList.remove('on');
                        }
                    } else {
                        // No significant conflict, merge normally
                        this.handleRemoteSkeleton(ids);
                    }
                });

                getFragment((fragMap, peerId) => {
                    console.log(`[EditorApp] RECEIVED fragments from peer ${peerId}, ${Object.keys(fragMap || {}).length} fragments`);
                    this.handleRemoteFragments(fragMap);
                });

                getLock((data, pid) => {
                    this.handleRemoteLock(data, pid);
                });

                getReqSync((_, pid) => {
                    console.log(`[EditorApp] RECEIVED sync request from peer ${pid}`);
                    const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                    if (ids.length > 0) {
                        this.actions.sendSkeleton(ids, pid);
                        const allFragments = this.getAllFragments();
                        if (Object.keys(allFragments).length > 0) {
                            this.actions.sendFragment(allFragments, pid);
                        }
                    }
                });

                this.room.onPeerJoin(id => {
                    console.log(`[EditorApp] PEER JOINED: ${id}`);
                    this.handlePeerJoin(id);
                    this.updateStatus();
                });

                this.room.onPeerLeave(id => {
                    console.log(`[EditorApp] PEER LEFT: ${id}`);
                    this.updateStatus();
                    this.reapplyVisualLocks();
                });

                // Start status polling
                let attempts = 0;
                const poll = setInterval(() => {
                    attempts++;
                    if (!this.room) { clearInterval(poll); return; }
                    const peers = Object.keys(this.room.getPeers()).length;
                    this.updateStatus(peers, attempts);

                    // Request sync early to detect conflicts
                    if (attempts === 2 && peers > 0) {
                        console.log('[EditorApp] Requesting sync to check for conflicts');
                        this.actions.reqSync(null);
                    }

                    if (attempts > 60) clearInterval(poll);
                }, 250);
            }

            setupGlobalExposure() {
                window.connectAndPreview = (hex, fromUrl) => this.connectAndPreview(hex, fromUrl);
                window.enterRoomUI = () => this.enterRoomUI();
            }

            addVisited(r) {
                if (r && !this.visitedRooms.includes(r)) {
                    this.visitedRooms.push(r);
                    localStorage.setItem(this.VISITED_KEY, JSON.stringify(this.visitedRooms));
                }
            }

            connectAndPreview(hex, fromUrl = false) {
                console.log(`[EditorApp] connectAndPreview() called with hex: ${hex}, fromUrl: ${fromUrl}`);

                // Set status timeout: 20 attempts (5s) for URL, 2 attempts (0.5s) for click
                this.statusTimeoutAttempts = fromUrl ? 20 : 2;

                const cleanHex = hex.replace('#', '');
                this.roomId = 'doc-infinite-' + cleanHex;
                this.user.color = '#' + cleanHex;
                console.log(`[EditorApp] Room ID set to: ${this.roomId}`);
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.user));
                try { localStorage.setItem("lastSphereColor", '#' + cleanHex); } catch (e) { }
                this.ui.userBadge.style.backgroundColor = this.user.color;

                // Clean up previous room if exists
                if (this.room) {
                    console.log('[EditorApp] Cleaning up previous room connection');
                    try { this.room.leave(); } catch (e) { console.warn('[EditorApp] Error leaving room:', e); }
                    this.room = null;
                }
                this.roomDB = null;

                // Check for local data first
                this.db.getRoom(cleanHex).then(localData => {
                    if (localData && localData.skeleton && localData.skeleton.length > 0) {
                        console.log(`[EditorApp] Found local data for ${cleanHex} - loading directly`);
                        this.ui.status.innerText = "Loading...";
                        this.ui.btn.classList.remove('hidden');

                        this.renderFromLocalDB().then(() => {
                            console.log('[EditorApp] Local DB render complete');
                            // Show login card briefly then user can click to enter
                            this.ui.status.innerText = "READY";
                            // Use conflict detection for network join
                            this.joinNetworkWithConflictDetection();
                        });
                    } else {
                        console.log(`[EditorApp] No local data for ${cleanHex}`);
                        this.ui.status.innerText = "Checking Network...";
                        this.ui.btn.classList.remove('hidden');

                        this.joinNetwork(false);

                        // Generate fresh if not loaded quickly
                        setTimeout(async () => {
                            console.log('[EditorApp] 3s timeout - checking if display has content...');
                            if (!this.ui.display.querySelector('.editor-line')) {
                                console.log('[EditorApp] No content found, generating fresh');
                                this.ui.display.innerHTML = this.generateFreshLines();
                                this.isFresh = true;
                                this.ui.status.innerText = "COLOR AVAILABLE";
                            }
                        }, 3000);
                    }
                }).catch(err => {
                    console.error('[EditorApp] Error checking local DB:', err);
                    this.ui.status.innerText = "Checking Network...";
                    this.ui.btn.classList.remove('hidden');
                    this.joinNetwork(false);
                });
            }

            async renderFromLocalDB() {
                console.log('[EditorApp] renderFromLocalDB() called');
                const hex = this.user.color.replace('#', '');
                console.log(`[EditorApp] Fetching room data for hex: ${hex}`);
                const data = await this.db.getRoom(hex);
                this.ui.display.innerHTML = '';

                if (data && data.skeleton && data.skeleton.length > 0) {
                    console.log(`[EditorApp] Found local data - skeleton length: ${data.skeleton.length}`);
                    data.skeleton.forEach(id => {
                        if (data.content && data.content[id]) {
                            this.ui.display.insertAdjacentHTML('beforeend', data.content[id]);
                        } else {
                            const div = document.createElement('div');
                            div.id = id;
                            div.className = 'editor-line';
                            div.innerHTML = '<br>';
                            this.ui.display.appendChild(div);
                        }
                    });
                    this.isFresh = false;
                    console.log('[EditorApp] Rendered local content, isFresh = false');
                } else {
                    console.log('[EditorApp] No local data found, generating fresh lines');
                    this.ui.display.innerHTML = this.generateFreshLines();
                    this.isFresh = true;
                }
                this.ensureStructure();
                console.log('[EditorApp] renderFromLocalDB() complete');
            }

            joinNetwork(isBackground) {
                console.log(`[EditorApp] joinNetwork() called, isBackground: ${isBackground}`);
                console.log(`[EditorApp] Attempting to join room: ${this.roomId}`);
                try {
                    // Start Trystero
                    console.log('[EditorApp] Creating Trystero room with trackers: wss://tracker.webtorrent.dev, wss://tracker.openwebrtc.io');
                    this.room = joinRoom({ appId: 'doc-infinite-v5-idb', trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io'] }, this.roomId);
                    console.log('[EditorApp] Trystero room created successfully');
                } catch (e) {
                    console.error('[EditorApp] ERROR creating Trystero room:', e);
                    return;
                }

                // Define Actions
                console.log('[EditorApp] Setting up Trystero actions (skeleton, fragment, lock, req)');
                const [sendSkeleton, getSkeleton] = this.room.makeAction('skeleton');
                const [sendFragment, getFragment] = this.room.makeAction('fragment');
                const [sendLock, getLock] = this.room.makeAction('lock');
                const [reqSync, getReqSync] = this.room.makeAction('req');

                this.actions = { sendSkeleton, sendFragment, sendLock, reqSync };
                console.log('[EditorApp] Actions created and stored');

                // Handlers
                getSkeleton((ids, peerId) => {
                    console.log(`[EditorApp] RECEIVED skeleton from peer ${peerId}, ${ids?.length || 0} IDs`);
                    if (ids && ids.length > 0) {
                        console.log(`[EditorApp] First 3 skeleton IDs received: ${ids.slice(0, 3).join(', ')}`);
                    }
                    this.handleRemoteSkeleton(ids);
                });
                getFragment((fragMap, peerId) => {
                    const keys = Object.keys(fragMap || {});
                    console.log(`[EditorApp] RECEIVED fragments from peer ${peerId}, ${keys.length} fragments`);
                    if (keys.length > 0) {
                        // Show sample of what was received
                        const sampleId = keys[0];
                        const sampleHtml = fragMap[sampleId];
                        console.log(`[EditorApp] Sample fragment ID: ${sampleId}`);
                        console.log(`[EditorApp] Sample fragment HTML length: ${sampleHtml?.length || 0} chars`);
                    }
                    this.handleRemoteFragments(fragMap);
                });
                getLock((data, pid) => {
                    console.log(`[EditorApp] RECEIVED lock from peer ${pid}:`, data);
                    this.handleRemoteLock(data, pid);
                });

                // Respond to Sync Requests
                getReqSync((_, pid) => {
                    console.log(`[EditorApp] RECEIVED sync request from peer ${pid}`);
                    const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                    console.log(`[EditorApp] Responding with ${ids.length} skeleton IDs`);
                    console.log(`[EditorApp] First 5 IDs: ${ids.slice(0, 5).join(', ')}`);
                    if (ids.length > 0) {
                        this.actions.sendSkeleton(ids, pid);
                        console.log(`[EditorApp] SENT skeleton to peer ${pid}`);
                        // Send ALL fragments for full sync
                        const allFragments = this.getAllFragments();
                        if (Object.keys(allFragments).length > 0) {
                            this.actions.sendFragment(allFragments, pid);
                            console.log(`[EditorApp] SENT ${Object.keys(allFragments).length} ALL fragments to peer ${pid}`);
                        }
                    } else {
                        console.log(`[EditorApp] No skeleton IDs to send - display may be empty`);
                    }
                });

                // Events
                this.room.onPeerJoin(id => {
                    console.log(`[EditorApp] PEER JOINED: ${id}`);
                    this.handlePeerJoin(id);
                    this.updateStatus();
                });
                this.room.onPeerLeave(id => {
                    console.log(`[EditorApp] PEER LEFT: ${id}`);
                    this.updateStatus();
                    this.reapplyVisualLocks();
                });

                // Status Polling & Initial Sync Request
                let attempts = 0;
                let connected = false;
                console.log('[EditorApp] Starting status polling loop');

                // Immediately request sync in case peers are already there but silent
                setTimeout(() => {
                    if (this.room) {
                        console.log('[EditorApp] Sending initial sync request (500ms delay)');
                        this.actions.reqSync(null);
                    }
                }, 500);

                const poll = setInterval(() => {
                    attempts++;
                    if (!this.room) {
                        console.log('[EditorApp] Poll: Room no longer exists, clearing interval');
                        clearInterval(poll);
                        return;
                    }

                    const peers = Object.keys(this.room.getPeers()).length;
                    if (peers > 0 && !connected) {
                        console.log(`[EditorApp] Poll #${attempts}: First connection! Peers: ${peers}`);
                        connected = true;
                    }
                    if (attempts % 10 === 0) {
                        console.log(`[EditorApp] Poll #${attempts}: Peers: ${peers}, Connected: ${connected}`);
                    }

                    this.updateStatus(peers, attempts);

                    // Periodically request sync if we look empty but peers exist
                    if (peers > 0 && this.ui.display.innerText.trim().length < 5 && attempts % 4 === 0) {
                        console.log(`[EditorApp] Poll #${attempts}: Display empty with peers, requesting sync`);
                        this.actions.reqSync(null);
                    }

                    if (attempts > 120) {
                        console.log('[EditorApp] Poll: Reached 120 attempts (~30s), stopping poll');
                        clearInterval(poll);
                    }
                }, 250);
            }

            enterRoomUI() {
                console.log('[EditorApp] enterRoomUI() called');
                if (this.ui.dashboard.classList.contains('active')) {
                    console.log('[EditorApp] Dashboard already active, returning');
                    return;
                }
                this.addVisited(this.roomId);
                console.log(`[EditorApp] Added ${this.roomId} to visited rooms`);
                this.ui.btn.classList.add('hidden');
                this.ui.loginCard.classList.remove('visible');
                this.ui.dashboard.classList.add('active');
                this.ui.hoverTrigger.style.display = 'block';
                this.ui.topNav.classList.add('active');
                window.location.hash = this.roomId.replace('doc-infinite-', '');
                console.log('[EditorApp] Dashboard UI activated');

                const hasContent = this.ui.display.querySelector('.editor-line');
                if (!hasContent) {
                    console.log('[EditorApp] No content in display, generating fresh lines');
                    this.ui.display.innerHTML = this.generateFreshLines();
                    this.isFresh = true;
                }
                const isEmpty = this.ui.display.innerText.trim().length < 5;
                console.log(`[EditorApp] Content state: hasContent=${!!hasContent}, isEmpty=${isEmpty}, isFresh=${this.isFresh}`);
                if (this.isFresh || isEmpty) this.focusCenter();
                else this.ui.display.focus();
                console.log('[EditorApp] enterRoomUI() complete');
            }

            async runSequencedScan() {
                console.log('[EditorApp] runSequencedScan() started');
                const queue = [...this.visitedRooms];
                console.log(`[EditorApp] Scanning ${queue.length} visited rooms for peer counts`);
                for (const rId of queue) {
                    if (!rId) continue;
                    try {
                        console.log(`[EditorApp] Scanning room: ${rId}`);
                        const r = joinRoom({ appId: 'doc-infinite-v4', trackerUrls: ['wss://tracker.webtorrent.dev'] }, rId);
                        await new Promise(res => {
                            setTimeout(() => {
                                let count = 0;
                                try { count = Object.keys(r.getPeers()).length; } catch (e) { }
                                console.log(`[EditorApp] Room ${rId}: ${count} peers found`);
                                r.leave();
                                const hex = rId.replace('doc-infinite-', '#');
                                window.postMessage({ type: 'handle-ready', hex: hex, count: count }, '*');
                                res();
                            }, 1000);
                        });
                    } catch (e) { console.warn("[EditorApp] Scan error for room:", rId, e); }
                }
                console.log('[EditorApp] runSequencedScan() complete');
            }

            generateFreshLines() {
                let html = '';
                for (let i = 0; i < 101; i++) html += this.createLine();
                return html;
            }

            createLine() { return `<div id="line-${Math.random().toString(36).substr(2, 9)}" class="editor-line"><br></div>`; }

            focusCenter() {
                let attempts = 0;
                const focusInterval = setInterval(() => {
                    attempts++;
                    const lines = this.ui.display.getElementsByClassName('editor-line');
                    const middleLine = lines[50];
                    if (middleLine) {
                        middleLine.scrollIntoView({ block: 'center', behavior: 'auto' });
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(middleLine);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        this.ui.display.focus();
                        this.currentLineId = middleLine.id;
                        if (document.activeElement === this.ui.display || attempts > 20) clearInterval(focusInterval);
                    } else clearInterval(focusInterval);
                }, 50);
            }

            ensureStructure() {
                Array.from(this.ui.display.children).forEach(child => {
                    if (child.tagName !== 'DIV' || !child.id) child.outerHTML = `<div id="line-${Math.random().toString(36).substr(2, 9)}" class="editor-line">${child.innerHTML || '<br>'}</div>`;
                    if (!child.classList.contains('editor-line')) child.classList.add('editor-line');
                });
            }

            checkBuffers() {
                const scrollTop = this.ui.container.scrollTop;
                const scrollHeight = this.ui.container.scrollHeight;
                const clientHeight = this.ui.container.clientHeight;
                let updated = false;
                if (scrollTop < 100) {
                    const oldHeight = scrollHeight;
                    let html = '';
                    for (let i = 0; i < 10; i++) html += this.createLine();
                    this.ui.display.insertAdjacentHTML('afterbegin', html);
                    if (scrollHeight > 0) this.ui.container.scrollTop = scrollTop + (this.ui.container.scrollHeight - oldHeight);
                    updated = true;
                }
                if (scrollHeight - scrollTop - clientHeight < 100) {
                    let html = '';
                    for (let i = 0; i < 10; i++) html += this.createLine();
                    this.ui.display.insertAdjacentHTML('beforeend', html);
                    updated = true;
                }
                if (updated) {
                    this.renderMinimap();
                    this.broadcastSkeleton();
                }
            }

            broadcastSkeleton() {
                if (!this.room || !this.actions || !this.actions.sendSkeleton) return;
                const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                console.log(`[EditorApp] Broadcasting skeleton update (${ids.length} lines)`);
                this.actions.sendSkeleton(ids);
            }

            async logout() {
                console.log('[EditorApp] logout() called');

                // Stop the landing loop immediately to prevent race condition where loop adds 'visible' class
                if (window.resetSphereView) window.resetSphereView();

                this.ui.dashboard.classList.remove('active', 'revealed');
                this.ui.loginCard.classList.remove('visible');
                this.ui.btn.classList.remove('hidden');
                this.ui.hoverTrigger.style.display = 'none';
                this.ui.topNav.classList.remove('active');

                window.location.hash = '';
                if (this.room) {
                    console.log('[EditorApp] Leaving current room');
                    try { this.room.leave(); } catch (e) { console.warn('[EditorApp] Error leaving room:', e); }
                    this.room = null;
                }

                this.ui.display.innerHTML = '';
                this.ui.minimap.innerHTML = '';
                this.activeLocks = {};
                this.currentLineId = null;
                this.isFresh = true;
                this.ui.peerCount.innerText = "Disconnected";
                this.ui.dot.classList.remove('on');
                console.log('[EditorApp] State reset complete');

                if (window.updateVisitedFromDB) await window.updateVisitedFromDB();
            }

            updateStatus(peerCountOverride = null, attempts = 0) {
                if (!this.room) {
                    console.log('[EditorApp] updateStatus() called but room is null');
                    return;
                }
                const peers = peerCountOverride !== null ? peerCountOverride : Object.keys(this.room.getPeers()).length;

                if (peers === 0) {
                    // Don't give up too early
                    if (attempts < this.statusTimeoutAttempts) {
                        this.ui.status.innerText = "SEARCHING...";
                        this.ui.peerCount.innerText = "Connecting...";
                        if (attempts === 1) console.log('[EditorApp] Status: SEARCHING... (no peers yet)');
                    } else {
                        if (this.ui.status.innerText !== "COLOR AVAILABLE") {
                            console.log(`[EditorApp] Status changed: COLOR AVAILABLE (after ${attempts} attempts, no peers found)`);
                        }
                        this.ui.status.innerText = "COLOR AVAILABLE";
                        this.ui.peerCount.innerText = "Offline";
                    }
                    this.ui.dot.classList.remove('on');
                } else {
                    const newStatus = `${peers} PEER${peers > 1 ? 'S' : ''} ONLINE`;
                    if (this.ui.status.innerText !== newStatus) {
                        console.log(`[EditorApp] Status changed: ${newStatus}`);
                    }
                    this.ui.status.innerText = newStatus;
                    this.ui.peerCount.innerText = `${peers} visitors(s)`;
                    this.ui.dot.classList.add('on');
                }
            }

            getVisibleFragments() {
                // Buffer of 500px as requested
                const buffer = 500;
                const container = this.ui.container;
                const top = container.scrollTop - buffer;
                const bottom = container.scrollTop + container.clientHeight + buffer;

                const visible = {};
                Array.from(this.ui.display.children).forEach(el => {
                    if (el.offsetTop + el.offsetHeight > top && el.offsetTop < bottom) {
                        visible[el.id] = el.outerHTML;
                    }
                });
                return visible;
            }

            getAllFragments() {
                // Get ALL fragments for full sync
                const all = {};
                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id) {
                        all[el.id] = el.outerHTML;
                    }
                });
                console.log(`[EditorApp] getAllFragments() returning ${Object.keys(all).length} fragments`);
                return all;
            }

            async handleRemoteSkeleton(ids) {
                console.log(`[EditorApp] handleRemoteSkeleton() processing ${ids?.length || 0} IDs`);
                console.log(`[EditorApp] First 5 received IDs: ${ids?.slice(0, 5).join(', ')}`);

                // Received a list of IDs. Reconstruct DOM order.
                // We keep existing elements if they exist, create new ones if they don't.
                // Order matches `ids` array.

                const currentMap = {};
                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id) currentMap[el.id] = el;
                });
                console.log(`[EditorApp] Current display has ${Object.keys(currentMap).length} elements`);

                // Build new fragment with correct order
                const fragment = document.createDocumentFragment();
                let newCount = 0, existingCount = 0;
                ids.forEach(id => {
                    if (!id) return; // Skip empty IDs
                    let el = currentMap[id];
                    if (!el) {
                        el = document.createElement('div');
                        el.id = id;
                        el.className = 'editor-line';
                        el.innerHTML = '<br>'; // Placeholder until fragment arrives
                        newCount++;
                    } else {
                        existingCount++;
                    }
                    fragment.appendChild(el);
                    delete currentMap[id]; // Mark as used
                });
                console.log(`[EditorApp] Skeleton: ${existingCount} existing, ${newCount} new elements`);

                // Remove anything not in the new skeleton
                const removedCount = Object.keys(currentMap).length;
                for (const id in currentMap) {
                    currentMap[id].remove();
                }
                if (removedCount > 0) console.log(`[EditorApp] Removed ${removedCount} elements not in skeleton`);

                // CRITICAL: Clear the display and add the new ordered content
                this.ui.display.innerHTML = '';
                this.ui.display.appendChild(fragment);
                console.log(`[EditorApp] Skeleton applied to display. Final child count: ${this.ui.display.children.length}`);

                // Save new structure
                await this.triggerSave(null);
                console.log('[EditorApp] handleRemoteSkeleton() complete');
            }

            async handleRemoteFragments(fragMap) {
                console.log(`[EditorApp] handleRemoteFragments() processing ${Object.keys(fragMap || {}).length} fragments`);
                let updatedCount = 0, skippedCount = 0, notFoundCount = 0;
                // Apply content updates
                for (const [id, html] of Object.entries(fragMap)) {
                    // html is outerHTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    const newEl = tempDiv.firstElementChild;
                    if (!newEl) {
                        console.log(`[EditorApp] Fragment ${id}: Failed to parse HTML`);
                        skippedCount++;
                        continue;
                    }

                    const el = document.getElementById(id);
                    if (el) {
                        // Always sync ownership attributes
                        const newOwner = newEl.dataset.owner || '';
                        const newColor = newEl.style.getPropertyValue('--owner-color');

                        if (el.dataset.owner !== newOwner) {
                            el.dataset.owner = newOwner;
                            if (newColor) el.style.setProperty('--owner-color', newColor);
                            else el.style.removeProperty('--owner-color');
                        }

                        // If I don't own it, update editable
                        if (el.dataset.owner && el.dataset.owner !== this.user.id) {
                            el.contentEditable = "false";
                        } else {
                            el.contentEditable = "true";
                        }

                        // Sync Content - update if different and I'm not actively editing this element
                        const iAmEditing = document.activeElement === el;
                        const contentDifferent = el.innerHTML !== newEl.innerHTML;

                        if (contentDifferent && !iAmEditing) {
                            console.log(`[EditorApp] Fragment ${id}: Updating content (was different)`);
                            el.innerHTML = newEl.innerHTML;
                            updatedCount++;
                        } else if (contentDifferent && iAmEditing) {
                            console.log(`[EditorApp] Fragment ${id}: Skipped - user is editing this element`);
                            skippedCount++;
                        }
                    } else {
                        console.log(`[EditorApp] Fragment target element not found: ${id}`);
                        notFoundCount++;
                    }
                }
                console.log(`[EditorApp] Fragments: ${updatedCount} updated, ${skippedCount} skipped, ${notFoundCount} not found`);
                await this.triggerSave(null);
                console.log('[EditorApp] handleRemoteFragments() complete');
            }

            handlePeerJoin(id) {
                console.log(`[EditorApp] handlePeerJoin() - sending state to new peer: ${id}`);
                // When a peer joins, we immediately send them our state
                // This covers the case where THEY join US.
                // The 'reqSync' covers the case where WE join THEM.
                const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                console.log(`[EditorApp] Sending ${ids.length} skeleton IDs to peer ${id}`);
                console.log(`[EditorApp] First 5 IDs: ${ids.slice(0, 5).join(', ')}`);
                if (ids.length > 0) {
                    this.actions.sendSkeleton(ids, id);
                    // Send ALL fragments, not just visible ones, for full sync
                    const allFragments = this.getAllFragments();
                    console.log(`[EditorApp] Sending ${Object.keys(allFragments).length} ALL fragments to peer ${id}`);
                    if (Object.keys(allFragments).length > 0) {
                        this.actions.sendFragment(allFragments, id);
                    }
                }
                if (this.currentLineId && this.actions.sendLock) {
                    console.log(`[EditorApp] Sending lock info for line ${this.currentLineId} to peer ${id}`);
                    this.actions.sendLock({ lineId: this.currentLineId, userColor: this.user.color }, id);
                }
            }

            handleRemoteLock(data, pid) {
                this.activeLocks[pid] = { lineId: data.lineId, ts: Date.now(), color: data.userColor };
                this.reapplyVisualLocks();
            }

            reapplyVisualLocks() {
                document.querySelectorAll('.locked-line').forEach(el => {
                    el.classList.remove('locked-line');
                    el.style.removeProperty('--lock-color');
                    el.querySelector('.locked-tag')?.remove();
                    if (el.dataset.owner && el.dataset.owner !== this.user.id) el.contentEditable = "false";
                    else el.contentEditable = "true";
                });
                const now = Date.now();
                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000 || pid === selfId) continue;
                    const el = document.getElementById(lock.lineId);
                    if (el) {
                        el.classList.add('locked-line');
                        el.style.setProperty('--lock-color', lock.color);
                        el.contentEditable = "false";
                        const tag = document.createElement('div');
                        tag.className = 'locked-tag';
                        tag.innerText = lock.color;
                        el.appendChild(tag);
                    }
                }
                this.renderMinimap();
            }

            renderMinimap() {
                this.ui.minimap.innerHTML = '';
                const totalHeight = this.ui.container.scrollHeight;
                const now = Date.now();
                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000 || pid === selfId) continue;
                    const el = document.getElementById(lock.lineId);
                    if (el) {
                        const d = document.createElement('div');
                        d.className = 'scroll-dot';
                        d.style.backgroundColor = lock.color;
                        d.style.top = ((el.offsetTop / totalHeight) * 100) + '%';
                        d.onclick = () => el.scrollIntoView({ block: 'center', behavior: 'smooth' });
                        this.ui.minimap.appendChild(d);
                    }
                }
            }

            async triggerSave(changedLineId = null) {
                const currentHex = this.user.color.replace('#', '');

                // 1. Snapshot current state
                const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                const content = {};
                // Use outerHTML to persist attributes
                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id) content[el.id] = el.outerHTML;
                });

                // 2. Save to IDB
                console.log(`[EditorApp] triggerSave() - saving ${ids.length} lines to IndexedDB for hex: ${currentHex}`);
                await this.db.saveRoom(currentHex, ids, content);

                // 3. Broadcast specific change if applicable
                if (changedLineId && this.room && this.actions && this.actions.sendFragment) {
                    const el = document.getElementById(changedLineId);
                    if (el) {
                        const fragmentData = { [changedLineId]: el.outerHTML };
                        const contentPreview = el.innerText.substring(0, 50);
                        console.log(`[EditorApp] Broadcasting fragment change for line: ${changedLineId}`);
                        console.log(`[EditorApp] Content preview: "${contentPreview}..."`);
                        console.log(`[EditorApp] Room exists: ${!!this.room}, Peers: ${this.room ? Object.keys(this.room.getPeers()).length : 0}`);
                        this.actions.sendFragment(fragmentData);
                    }
                } else if (changedLineId) {
                    console.log(`[EditorApp] triggerSave() - NOT broadcasting: room=${!!this.room}, actions=${!!this.actions}, sendFragment=${!!(this.actions?.sendFragment)}`);
                }
            }

            bindEvents() {
                this.ui.container.addEventListener('scroll', () => this.checkBuffers());
                window.addEventListener('resize', () => this.renderMinimap());
                this.ui.logoutBtn.addEventListener('click', () => this.logout());
                const revealNav = () => this.ui.dashboard.classList.add('revealed');
                const hideNav = (e) => {
                    const to = e.relatedTarget;
                    if (to && (to.id === 'top-nav' || to.id === 'hover-trigger' || to.closest('#top-nav'))) return;
                    this.ui.dashboard.classList.remove('revealed');
                };
                this.ui.hoverTrigger.addEventListener('mouseenter', revealNav);
                this.ui.hoverTrigger.addEventListener('mouseleave', hideNav);
                this.ui.topNav.addEventListener('mouseenter', revealNav);
                this.ui.topNav.addEventListener('mouseleave', hideNav);
                this.ui.display.addEventListener('input', () => {
                    this.isFresh = false;

                    // Check for structural changes (lines added/removed)
                    if (this.ui.display.children.length !== this.lastLineCount) {
                        this.lastLineCount = this.ui.display.children.length;
                        this.broadcastSkeleton();
                    }

                    for (let child of this.ui.display.children) {
                        if (!child.id || !child.classList.contains('editor-line')) {
                            if (!child.id) child.id = 'line-' + Math.random().toString(36).substr(2, 9);
                            child.classList.add('editor-line');
                        }
                    }
                    const n = window.getSelection().anchorNode;
                    const line = (n.nodeType === 3 ? n.parentNode : n).closest('.editor-line');
                    let changedId = null;
                    if (line) {
                        line.dataset.owner = this.user.id;
                        line.style.setProperty('--owner-color', this.user.color);
                        line.contentEditable = "true";
                        changedId = line.id;
                    }
                    this.triggerSave(changedId);
                });
                document.addEventListener('selectionchange', () => {
                    const sel = window.getSelection();
                    if (!sel.rangeCount) return;
                    const n = sel.anchorNode.nodeType === 3 ? sel.anchorNode.parentNode : sel.anchorNode;
                    const line = n.closest('.editor-line');
                    if (line && line.id) {
                        this.currentLineId = line.id;
                        document.querySelectorAll('.my-line').forEach(e => e.classList.remove('my-line'));
                        line.classList.add('my-line');
                        this.ui.tools.classList.toggle('visible', sel.toString().length > 0);
                        if (this.actions.sendLock) this.actions.sendLock({ lineId: line.id, userColor: this.user.color });
                    }
                });
                document.getElementById('btn-bold').onclick = () => document.execCommand('bold');
                document.getElementById('btn-italic').onclick = () => document.execCommand('italic');
                document.getElementById('btn-link').onclick = () => { const u = prompt("URL:"); if (u) document.execCommand('createLink', false, u); };
                this.ui.display.addEventListener('mouseover', (e) => {
                    const line = e.target.closest('.editor-line');
                    if (line && line.dataset.owner) {
                        document.querySelectorAll(`.editor-line[data-owner="${line.dataset.owner}"]`).forEach(el => el.classList.add('group-hover'));
                    }
                });
                this.ui.display.addEventListener('mouseout', () => document.querySelectorAll('.group-hover').forEach(el => el.classList.remove('group-hover')));
            }
        }
        new EditorApp();
    </script>

    <!-- SPHERE LOGIC -->
    <script>
        let storageScope = window.localStorage;
        document.getElementById('login-btn').addEventListener('click', async () => {
            const currentHex = document.getElementById('color-hex').innerText;
            try { storageScope.setItem("lastSphereColor", currentHex); } catch (e) { }
            if (window.enterRoomUI) window.enterRoomUI();
        });

        const Vec3 = { create: (x = 0, y = 0, z = 0) => [x, y, z], add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s], dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2], cross: (a, b) => [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]], len: v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]), normalize: v => { const l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); return l > 0 ? [v[0] / l, v[1] / l, v[2] / l] : [0, 0, 0] }, dist: (a, b) => Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2) + Math.pow(a[2] - b[2], 2)) };
        const Mat4 = { perspective: (f, a, n, fr) => { const nf = 1 / (n - fr), f_t = 1 / Math.tan(f / 2); return [f_t / a, 0, 0, 0, 0, f_t, 0, 0, 0, 0, (fr + n) * nf, -1, 0, 0, 2 * fr * n * nf, 0] }, lookAt: (e, c, u) => { const z = Vec3.normalize(Vec3.sub(e, c)), x = Vec3.normalize(Vec3.cross(u, z)), y = Vec3.cross(z, x); return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -Vec3.dot(x, e), -Vec3.dot(y, e), -Vec3.dot(z, e), 1] }, multiply: (a, b) => { const o = new Float32Array(16); for (let i = 0; i < 4; i++)for (let j = 0; j < 4; j++) { let s = 0; for (let k = 0; k < 4; k++)s += a[i + k * 4] * b[k + j * 4]; o[i + j * 4] = s } return o }, rotationX: r => [1, 0, 0, 0, 0, Math.cos(r), Math.sin(r), 0, 0, -Math.sin(r), Math.cos(r), 0, 0, 0, 0, 1], translation: v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1], scale: v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1], rotationAxis: (a, r) => { const c = Math.cos(r), s = Math.sin(r), t = 1 - c, x = a[0], y = a[1], z = a[2]; return [t * x * x + c, t * x * y + z * s, t * x * z - y * s, 0, t * x * y - z * s, t * y * y + c, t * y * z + x * s, 0, t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0, 0, 0, 0, 1] }, identity: () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
        const state = { canvas: null, device: null, context: null, pipelines: { sphere: null, cone: null }, buffers: {}, bindGroups: { sphere: null, cones: [] }, cameraPos: [0, 0, 4], sphere: { rotation: Mat4.identity(), indexCount: 0 }, cones: [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }], historyHandles: [], hasRotated: false, mouse: { x: 0, y: 0, down: false }, draggedConeIndex: -1, valueScrub: { active: false, coneIndex: -1, coordIndex: 0, startY: 0 }, lastTime: 0, clickData: { startX: 0, startY: 0, startTime: 0 }, landing: { active: false, progress: 0, rotationAxis: [1, 0, 0], rotationAngle: 0, baseRotation: Mat4.identity(), coneStartPositions: [], handleStartPos: [0, 0, 0], showHandle: false, startDist: 4.0, targetDist: 1.25 }, dragStart: { active: false, mouseDir: [0, 0, 1], sphereRotation: null, conePositions: [] }, handle: { active: false, pos: [0, 0, 0], color: [1, 1, 1] }, msaaTexture: null, depthTexture: null, sampleCount: 4, presentationFormat: null, debugMode: false, uiCache: [], vpMatrix: Mat4.identity(), returning: null };

        function rgbToHex(r, g, b) { const toHex = c => Math.round(Math.min(1, Math.max(0, c)) * 255).toString(16).padStart(2, '0'); return '#' + toHex(r) + toHex(g) + toHex(b); }
        function hexToRgbNormalized(hex) { hex = hex.replace(/^#/, ''); if (hex.length === 3) hex = hex.split('').map(x => x + x).join(''); const bigint = parseInt(hex, 16); return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255]; }

        const sphereShaderWGSL = `struct Uniforms{mvp:mat4x4<f32>,model:mat4x4<f32>,normalMatrix:mat4x4<f32>,viewPos:vec3<f32>,l1:vec3<f32>,c1:vec3<f32>,l2:vec3<f32>,c2:vec3<f32>,l3:vec3<f32>,c3:vec3<f32>,debug:f32,};@group(0) @binding(0) var<uniform> u:Uniforms;struct VI{@location(0) p:vec3<f32>,@location(1) n:vec3<f32>};struct VO{@builtin(position) P:vec4<f32>,@location(0) vP:vec3<f32>,@location(1) vN:vec3<f32>};@vertex fn vs_main(i:VI)->VO{var o:VO;o.P=u.mvp*vec4<f32>(i.p,1.0);o.vP=(u.model*vec4<f32>(i.p,1.0)).xyz;o.vN=(u.normalMatrix*vec4<f32>(i.n,0.0)).xyz;return o;}fn ACES(x:vec3<f32>)->vec3<f32>{let a=2.51;let b=0.03;let c=2.43;let d=0.59;let e=0.14;return clamp((x*(a*x+b))/(x*(c*x+d)+e),vec3<f32>(0.0),vec3<f32>(1.0));}fn getI(lp:vec3<f32>,N:vec3<f32>,fp:vec3<f32>)->f32{let L=normalize(lp-fp);let distSq=dot(lp-fp,lp-fp);return pow(max(dot(N,L)+1.0,0.0)/2.0,2.5)*(1.0/(1.0+distSq*0.05));}@fragment fn fs_main(i:VO)->@location(0) vec4<f32>{let N=normalize(i.vN);if(u.debug > 0.5){let L1=normalize(u.l1-i.vP);let L2=normalize(u.l2-i.vP);let L3=normalize(u.l3-i.vP);if(dot(N,L1)>0.0 && dot(N,L2)>0.0 && dot(N,L3)>0.0){return vec4<f32>(1.0,0.0,0.0,1.0);}}let d1=getI(u.l1,N,i.vP);let d2=getI(u.l2,N,i.vP);let d3=getI(u.l3,N,i.vP);var l=(u.c1*d1)+(u.c2*d2)+(u.c3*d3);let ep=0.001;l=l+((u.c1+u.c2)*2.0*d1*d2/(d1+d2+ep)*1.8)+((u.c2+u.c3)*2.0*d2*d3/(d2+d3+ep)*1.8)+((u.c3+u.c1)*2.0*d3*d1/(d3+d1+ep)*1.8);let m=pow(min(d1,min(d2,d3)),6.0);l=l+(vec3<f32>(1.0)*m*80.0);l=max(l-vec3<f32>(0.01),vec3<f32>(0.0))*2.0;return vec4<f32>(pow(ACES(l),vec3<f32>(1.0/2.2)),1.0);}`;
        const coneShaderWGSL = `struct U{mvp:mat4x4<f32>,c:vec3<f32>};@group(0) @binding(0) var<uniform> u:U;@vertex fn vs_main(@location(0) p:vec3<f32>)->@builtin(position) vec4<f32>{return u.mvp*vec4<f32>(p,1.0);}@fragment fn fs_main()->@location(0) vec4<f32>{return vec4<f32>(u.c,1.0);}`;

        // FIX 2: Explicitly define default cone positions for consistent handle calculation
        const defaultCones = [
            { color: [1, 0, 0], pos: [0, .98, .69], active: true },
            { color: [0, 1, 0], pos: [-.85, -.49, .69], active: true },
            { color: [0, 0, 1], pos: [.85, -.49, .69], active: true }
        ];

        function findPositionFromColor(targetHex) {
            const t = hexToRgbNormalized(targetHex); let bd = Infinity, bp = null;
            for (let la = 0; la <= 60; la++) for (let lo = 0; lo <= 60; lo++) {
                const th = la * Math.PI / 60, ph = lo * 2 * Math.PI / 60, pos = [Math.cos(ph) * Math.sin(th), Math.cos(th), Math.sin(ph) * Math.sin(th)];
                // FIX 2 CONTINUED: Pass defaultCones to ignore user distortions during calculation
                const c = getSurfaceColor(pos, pos, defaultCones), d = Math.sqrt((c[0] - t[0]) ** 2 + (c[1] - t[1]) ** 2 + (c[2] - t[2]) ** 2);
                if (d < bd) { bd = d; bp = pos; }
            } return bp;
        }

        async function init() {
            // FIX: Remove duplicates, ensure clean start
            state.canvas = document.getElementById('gpu-canvas');
            if (!navigator.gpu) return alert("WebGPU not supported!");
            const adapter = await navigator.gpu.requestAdapter(); state.device = await adapter.requestDevice();
            state.context = state.canvas.getContext('webgpu'); state.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            state.context.configure({ device: state.device, format: state.presentationFormat, alphaMode: 'premultiplied' });

            const visited = JSON.parse(localStorage.getItem('p2p_visited_rooms_v1')) || [];
            const validVisited = [];
            visited.forEach(roomId => {
                if (!roomId) return;
                try {
                    const hex = roomId.replace('doc-infinite-', '#');
                    const pos = findPositionFromColor(hex);
                    if (pos) validVisited.push(roomId);
                } catch (e) { }
            });
            if (validVisited.length !== visited.length) localStorage.setItem('p2p_visited_rooms_v1', JSON.stringify(validVisited));

            state.historyHandles = [];

            await createAssets();
            window.addEventListener('resize', onResize); onResize();
            state.canvas.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
            state.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e) });
            document.getElementById('freeze-btn').addEventListener('click', toggleFreeze);

            document.getElementById('debug-btn').onclick = function () {
                state.debugMode = !state.debugMode;
                this.classList.toggle('active', state.debugMode);
                this.innerText = state.debugMode ? "DEBUG ON" : "DEBUG OFF";
                document.getElementById('debug-panel').classList.toggle('visible', state.debugMode);
            };

            document.getElementById('reset-btn').onclick = async () => {
                if (confirm("Permanently wipe all local data?")) {
                    localStorage.clear();
                    try {
                        const dbs = await window.indexedDB.databases();
                        for (const db of dbs) { await window.indexedDB.deleteDatabase(db.name); }
                    } catch (e) { }
                    window.location.reload();
                }
            };

            state.uiCache = state.cones.map((c, i) => { const el = document.getElementById(`data-${i}`); if (el) { el.innerHTML = `<span class="cone-title" id="title-${i}">${c.name}</span> <span style="color:#666">X</span> <span class="coord-val" id="x-${i}">0.00</span> <span style="color:#666">Y</span> <span class="coord-val" id="y-${i}">0.00</span> <span style="color:#666">Z</span> <span class="coord-val" id="z-${i}">0.00</span>`; const titleEl = document.getElementById(`title-${i}`); titleEl.addEventListener('click', (e) => { if (document.body.classList.contains('light-mode')) return; e.stopPropagation(); state.cones[i].active = !state.cones[i].active; });['x', 'y', 'z'].forEach((axis, axIdx) => document.getElementById(`${axis}-${i}`).addEventListener('mousedown', (e) => { if (document.body.classList.contains('light-mode')) return; e.preventDefault(); e.stopPropagation(); state.valueScrub = { active: true, coneIndex: i, coordIndex: axIdx, startY: e.clientY }; })); return { title: titleEl, x: document.getElementById(`x-${i}`), y: document.getElementById(`y-${i}`), z: document.getElementById(`z-${i}`), lastPos: [null, null, null], lastActive: null }; } return null; });

            setupColorTooltip();
            if (window.location.hash && window.location.hash.length > 1) {
                const matchPos = findPositionFromColor(window.location.hash);
                if (matchPos) triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(window.location.hash), true);
            }
            requestAnimationFrame(loop);
        }

        async function createAssets() {
            const dev = state.device, sphereGeo = createSphere(1.0, 128, 128), coneGeo = createCone(0.1, 0.3, 64);
            state.buffers.sphereVertex = createBuffer(dev, sphereGeo.p, GPUBufferUsage.VERTEX); state.buffers.sphereNormal = createBuffer(dev, sphereGeo.n, GPUBufferUsage.VERTEX); state.buffers.sphereIndex = createBuffer(dev, sphereGeo.i, GPUBufferUsage.INDEX); state.sphere.indexCount = sphereGeo.i.length;
            state.buffers.coneVertex = createBuffer(dev, coneGeo.p, GPUBufferUsage.VERTEX); state.buffers.coneIndex = createBuffer(dev, coneGeo.i, GPUBufferUsage.INDEX); state.coneIndexCount = coneGeo.i.length;
            state.buffers.sphereUniform = dev.createBuffer({ size: 320, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            state.buffers.coneUniform = dev.createBuffer({ size: 65536, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const sm = dev.createShaderModule({ code: sphereShaderWGSL }), cm = dev.createShaderModule({ code: coneShaderWGSL });
            state.pipelines.sphere = dev.createRenderPipeline({ layout: 'auto', vertex: { module: sm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }, { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }] }, fragment: { module: sm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } });
            state.pipelines.cone = dev.createRenderPipeline({ layout: 'auto', vertex: { module: cm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }] }, fragment: { module: cm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } });
            state.bindGroups.sphere = dev.createBindGroup({ layout: state.pipelines.sphere.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.sphereUniform } }] });

            state.getBindGroupForHandle = (idx) => {
                return dev.createBindGroup({ layout: state.pipelines.cone.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.coneUniform, offset: idx * 256, size: 80 } }] });
            };
            state.bindGroups.cones = [0, 1, 2, 3].map(i => state.getBindGroupForHandle(i));
        }

        function createBuffer(dev, data, usage) { const buf = dev.createBuffer({ size: data.byteLength, usage: usage | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); (data instanceof Float32Array ? new Float32Array(buf.getMappedRange()) : new Uint16Array(buf.getMappedRange())).set(data); buf.unmap(); return buf; }
        function createSphere(r, latB, longB) { const p = [], n = [], idx = []; for (let la = 0; la <= latB; la++) for (let lo = 0; lo <= longB; lo++) { const th = la * Math.PI / latB, ph = lo * 2 * Math.PI / longB, x = Math.cos(ph) * Math.sin(th), y = Math.cos(th), z = Math.sin(ph) * Math.sin(th); n.push(x, y, z); p.push(r * x, r * y, r * z); } for (let la = 0; la < latB; la++) for (let lo = 0; lo < longB; lo++) { const f = (la * (longB + 1)) + lo, s = f + longB + 1; idx.push(f, f + 1, s, s, f + 1, s + 1); } return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function createCone(r, h, s) { const p = [0, h, 0], n = [0, 1, 0], idx = []; for (let i = 0; i <= s; i++) { const th = i * 2 * Math.PI / s, x = r * Math.cos(th), z = r * Math.sin(th); p.push(x, 0, z); const nv = Vec3.normalize([x, .5, z]); n.push(nv[0], nv[1], nv[2]); } p.push(0, 0, 0); n.push(0, -1, 0); const bc = p.length / 3 - 1; for (let i = 1; i <= s; i++) idx.push(0, i, i + 1, bc, i + 1, i); return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function onResize() { if (!state.device) return; const w = Math.ceil(window.innerWidth), h = Math.ceil(window.innerHeight); state.canvas.width = w; state.canvas.height = h; if (state.msaaTexture) state.msaaTexture.destroy(); if (state.depthTexture) state.depthTexture.destroy(); state.msaaTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: state.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT }); state.depthTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: 'depth24plus', usage: GPUTextureUsage.RENDER_ATTACHMENT }); }
        function getMouseRay(x, y) { const aspect = state.canvas.width / state.canvas.height, ndcX = (x / state.canvas.width) * 2 - 1, ndcY = -(y / state.canvas.height) * 2 + 1; const dir = Vec3.normalize([ndcX * aspect * Math.tan(Math.PI / 8), ndcY * Math.tan(Math.PI / 8), -1]); return { o: state.cameraPos, d: dir }; }
        function getTargetPos(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)); return Vec3.dot(p, p) <= 1 ? Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))) : Vec3.scale(Vec3.normalize(p), 1); }
        function calculateConePosition(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)), dist = Math.sqrt(Vec3.dot(p, p)), R = 1.2; if (dist <= R) return Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(R * R - Vec3.dot(p, p)))); const axis = Vec3.cross(Vec3.normalize(r.o), r.d); return Vec3.scale(transformPos(Vec3.normalize(r.o), Mat4.rotationAxis(Vec3.normalize(Vec3.len(axis) < .001 ? [1, 0, 0] : axis), Math.acos(R / Vec3.len(r.o)) + (dist - R))), R); }
        function transformPos(p, m) { return [m[0] * p[0] + m[4] * p[1] + m[8] * p[2] + m[12], m[1] * p[0] + m[5] * p[1] + m[9] * p[2] + m[13], m[2] * p[0] + m[6] * p[1] + m[10] * p[2] + m[14]]; }

        function projectToScreen(worldPos) {
            const m = state.vpMatrix;
            const x = worldPos[0], y = worldPos[1], z = worldPos[2];
            const clipX = x * m[0] + y * m[4] + z * m[8] + m[12];
            const clipY = x * m[1] + y * m[5] + z * m[9] + m[13];
            const clipW = x * m[3] + y * m[7] + z * m[11] + m[15];

            if (clipW <= 0) return null; // Behind camera

            const ndcX = clipX / clipW;
            const ndcY = clipY / clipW;

            return {
                x: (ndcX + 1) * state.canvas.width / 2,
                y: (1 - ndcY) * state.canvas.height / 2
            };
        }

        function onMouseDown(e) {
            if (state.valueScrub.active) return;
            state.mouse = { x: e.clientX, y: e.clientY, down: true };
            state.clickData = { startX: e.clientX, startY: e.clientY, startTime: Date.now() };
            if (document.body.classList.contains('light-mode')) {
                const p = getTargetPos(state.mouse.x, state.mouse.y), r = getMouseRay(state.mouse.x, state.mouse.y);
                if (Vec3.dot(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))), Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)))) <= 1) {
                    state.dragStart = { active: true, mouseDir: Vec3.normalize(p), sphereRotation: [...state.sphere.rotation], conePositions: state.cones.map(c => [...c.pos]) };
                    state.handle = { active: true, pos: p, color: getSurfaceColor(p, Vec3.normalize(p)) };
                    state.hasRotated = true;
                }
            }
        }
        function onMouseMove(e) { state.mouse.x = e.clientX; state.mouse.y = e.clientY; }

        function onMouseUp(e) {
            state.mouse.down = false; state.handle.active = false; if (state.valueScrub.active) { state.valueScrub.active = false; return; }
            const dist = Math.sqrt((e.clientX - state.clickData.startX) ** 2 + (e.clientY - state.clickData.startY) ** 2);
            if (document.body.classList.contains('light-mode') && dist < 5 && Date.now() - state.clickData.startTime < 250) {
                // 1. CHECK HANDLES WITH PROJECTION
                for (let h of state.historyHandles) {
                    const worldPos = transformPos(h.pos, state.sphere.rotation);
                    const screenPos = projectToScreen(worldPos);
                    if (screenPos) {
                        const dx = e.clientX - screenPos.x;
                        const dy = e.clientY - screenPos.y;
                        if (Math.sqrt(dx * dx + dy * dy) < 30) {
                            triggerLanding(h.pos, worldPos, h.color, false);
                            return;
                        }
                    }
                }
                // 2. CHECK SPHERE SURFACE
                const r = getMouseRay(e.clientX, e.clientY);
                const tSphere = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d);
                const pSphere = Vec3.add(r.o, Vec3.scale(r.d, tSphere));
                if (Vec3.dot(pSphere, pSphere) <= 1) {
                    const hp = Vec3.sub(pSphere, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(pSphere, pSphere))));
                    triggerLanding(Vec3.normalize(hp), hp, getSurfaceColor(hp, Vec3.normalize(hp)), false);
                }
            }
        }
        function getLuminance(r, g, b) { return 0.299 * r + 0.587 * g + 0.114 * b; }
        function triggerLanding(norm, pos, col, fromUrl = false) {
            state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [...pos], showHandle: true, targetDist: 1.25 }; state.handle.color = [...col]; state.hasRotated = true;
            const hex = rgbToHex(col[0], col[1], col[2]); document.getElementById('color-hex').innerText = hex.toUpperCase();
            try { localStorage.setItem("lastSphereColor", hex); } catch (e) { } // FIX: Save on landing trigger too
            const isLight = getLuminance(col[0], col[1], col[2]) > 0.5;
            const textColor = isLight ? 'black' : 'white';
            document.getElementById('login-card').style.color = textColor;
            document.getElementById('top-nav').style.setProperty('--nav-color', textColor);
            const cam = Vec3.normalize(state.cameraPos), axis = Vec3.cross(norm, cam), dot = Vec3.dot(norm, cam);
            state.landing.rotationAxis = Vec3.len(axis) < .001 ? [1, 0, 0] : Vec3.normalize(axis); state.landing.rotationAngle = Vec3.len(axis) < .001 ? (dot > 0 ? 0 : Math.PI) : Math.acos(Math.min(1, Math.max(-1, dot)));
            if (window.connectAndPreview) window.connectAndPreview(hex, fromUrl);
        }
        function toggleFreeze() {
            const f = document.getElementById('flash-overlay');
            const isFrozen = document.body.classList.toggle('light-mode');
            state.landing = { active: false, showHandle: false };
            document.getElementById('login-card').classList.remove('visible');
            document.getElementById('dashboard-panel').classList.remove('active');
            state.cameraPos = [0, 0, 4];
            f.style.backgroundColor = isFrozen ? 'white' : 'black';
            document.body.style.backgroundColor = '';
            f.classList.remove('active'); void f.offsetWidth; f.classList.add('active'); setTimeout(() => f.classList.remove('active'), 0);
        }

        // FIX 2 CONTINUED: Update getSurfaceColor to accept optional cones override
        function getSurfaceColor(p, n, cones = state.cones) {
            const getI = (i) => { if (!cones[i].active) return 0; const L = Vec3.sub(cones[i].pos, p), d = Vec3.dot(L, L); return Math.pow(Math.max(Vec3.dot(n, Vec3.normalize(L)) + 1, 0) / 2, 2.5) * (1 / (1 + d * .05)); };
            const d = [getI(0), getI(1), getI(2)], c = cones.map(x => x.color);
            let l = Vec3.add(Vec3.add(Vec3.scale(c[0], d[0]), Vec3.scale(c[1], d[1])), Vec3.scale(c[2], d[2])), ep = 0.001;
            l = Vec3.add(l, Vec3.add(Vec3.scale(Vec3.add(c[0], c[1]), 2 * d[0] * d[1] / (d[0] + d[1] + ep) * 1.8), Vec3.add(Vec3.scale(Vec3.add(c[1], c[2]), 2 * d[1] * d[2] / (d[1] + d[2] + ep) * 1.8), Vec3.scale(Vec3.add(c[2], c[0]), 2 * d[2] * d[0] / (d[2] + d[0] + ep) * 1.8))));
            let m = Math.pow(Math.min(d[0], Math.min(d[1], d[2])), 6); l = Vec3.add(l, [m * 80, m * 80, m * 80]); l = Vec3.scale([Math.max(l[0] - .01, 0), Math.max(l[1] - .01, 0), Math.max(l[2] - .01, 0)], 2);
            const r = (x) => (x * (2.51 * x + .03)) / (x * (2.43 * x + .59) + .14), co = [r(l[0]), r(l[1]), r(l[2])]; return [Math.pow(co[0], 1 / 2.2), Math.pow(co[1], 1 / 2.2), Math.pow(co[2], 1 / 2.2)];
        }

        function setupColorTooltip() {
            const t = document.createElement('div'); t.className = 'sphere-tooltip'; document.body.appendChild(t);
            window.addEventListener('mousemove', e => {
                if (!document.body.classList.contains('light-mode')) { t.style.display = 'none'; return; }
                if (e.target.closest('#dashboard-panel') || e.target.closest('#login-card') || e.target.closest('#top-nav')) { t.style.display = 'none'; return; }

                // 1. CHECK HANDLES (Using Screen Projection)
                for (let h of state.historyHandles) {
                    const worldPos = transformPos(h.pos, state.sphere.rotation);
                    const screenPos = projectToScreen(worldPos);

                    if (screenPos) {
                        const dx = e.clientX - screenPos.x;
                        const dy = e.clientY - screenPos.y;

                        if (Math.sqrt(dx * dx + dy * dy) < 30) {
                            const count = h.peerCount || 0;
                            const meta = count > 0 ? `${count} PEER${count > 1 ? 'S' : ''} ONLINE` : "OFFLINE";
                            const metaClass = count > 0 ? "meta online" : "meta";
                            t.innerHTML = `<span class="hex">${h.hex.toUpperCase()}</span><span class="${metaClass}">${meta}</span>`;
                            t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px';
                            t.style.border = `1px solid ${h.hex}`;
                            return;
                        }
                    }
                }

                // 2. CHECK SPHERE
                const r = getMouseRay(e.clientX, e.clientY), tV = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, tV));
                if (Vec3.dot(p, p) > 1 || (tV - Math.sqrt(1 - Vec3.dot(p, p))) < 0) { t.style.display = 'none'; return; }
                const h = Vec3.add(r.o, Vec3.scale(r.d, tV - Math.sqrt(1 - Vec3.dot(p, p)))), c = getSurfaceColor(h, Vec3.normalize(h));
                const hex = rgbToHex(c[0], c[1], c[2]).toUpperCase();
                t.innerHTML = `<span class="hex">${hex}</span>`;
                t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px';
                t.style.border = `1px solid ${hex}`;
            });
        }

        window.resetSphereView = function () {
            // 1. Stop any conflicting animations
            state.landing.active = false;

            // 2. Calculate the Axis and Angle to return to Identity
            // We want to rotate FROM the current rotation (m) BACK to identity.
            const m = state.sphere.rotation;
            const trace = m[0] + m[5] + m[10];
            let angle = Math.acos(Math.max(-1, Math.min(1, (trace - 1) / 2)));
            let axis = [1, 0, 0];
            const diff = [m[6] - m[9], m[8] - m[2], m[1] - m[4]];
            const sinLen = Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2]);
            if (sinLen > 0.001) axis = [diff[0] / sinLen, diff[1] / sinLen, diff[2] / sinLen];

            // 3. Start the Returning State
            // Do NOT reset hasRotated yet, so background stays colored until end
            state.returning = {
                active: true,
                progress: 0,
                baseRotation: m,
                rotationAxis: axis,
                rotationAngle: -angle,
                startDist: Vec3.len(state.cameraPos),
                targetDist: 4.0,
                coneStartPositions: state.cones.map(c => [...c.pos])
            };
        };

        function loop(ts) {
            const dt = Math.min((ts - state.lastTime) / 1000, 0.1); state.lastTime = ts;
            const aspect = state.canvas.width / state.canvas.height, proj = Mat4.perspective(Math.PI / 4, aspect, .1, 100);
            if (document.body.classList.contains('light-mode') && state.hasRotated) { const c = getSurfaceColor([0, 0, 1], [0, 0, 1]); document.body.style.backgroundColor = rgbToHex(c[0], c[1], c[2]); }
            if (state.valueScrub.active) { const d = Math.abs(state.valueScrub.startY - state.mouse.y); if (d > 5) state.cones[state.valueScrub.coneIndex].pos[state.valueScrub.coordIndex] += Math.sign(state.valueScrub.startY - state.mouse.y) * Math.pow((d - 5) / 500, 3) * .05; }

            if (state.landing.active) {
                state.landing.progress = Math.min(state.landing.progress + dt * .5, 1);
                if (state.landing.progress >= 1) { document.getElementById('login-card').classList.add('visible'); state.landing.showHandle = false; }
                const t = state.landing.progress, rot = Mat4.rotationAxis(state.landing.rotationAxis, state.landing.rotationAngle * t * t);
                state.sphere.rotation = Mat4.multiply(rot, state.landing.baseRotation);
                state.cones.forEach((c, i) => c.pos = transformPos(state.landing.coneStartPositions[i], rot));
                if (state.landing.showHandle) state.handle.pos = transformPos(state.landing.handleStartPos, rot);
                state.cameraPos = Vec3.scale(Vec3.normalize([0, 0, 4]), state.landing.startDist + (state.landing.targetDist - state.landing.startDist) * t * t * t);
            }

            if (state.returning && state.returning.active) {
                const speed = 1.5;
                state.returning.progress = Math.min(state.returning.progress + dt * speed, 1);
                const t = state.returning.progress;
                const ease = 1 - Math.pow(1 - t, 3); // Cubic Ease Out

                const rot = Mat4.rotationAxis(state.returning.rotationAxis, state.returning.rotationAngle * ease);
                state.sphere.rotation = Mat4.multiply(rot, state.returning.baseRotation);
                state.cameraPos = [0, 0, state.returning.startDist + (state.returning.targetDist - state.returning.startDist) * ease];
                state.cones.forEach((c, i) => { c.pos = transformPos(state.returning.coneStartPositions[i], rot); });

                if (t >= 1) {
                    state.returning.active = false;
                    state.hasRotated = false;
                    state.sphere.rotation = Mat4.identity();
                    state.cones = [
                        { color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true },
                        { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true },
                        { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }
                    ];
                    state.cameraPos = [0, 0, 4];
                    document.body.style.backgroundColor = '';
                    document.getElementById('color-hex').innerText = "#FFFFFF";
                    document.getElementById('login-card').style.color = '';
                    document.getElementById('top-nav').style.removeProperty('--nav-color');
                }
            }

            const view = Mat4.lookAt(state.cameraPos, [0, 0, 0], [0, 1, 0]);
            state.vpMatrix = Mat4.multiply(proj, view);
            const vp = state.vpMatrix;
            const tp = getTargetPos(state.mouse.x, state.mouse.y);

            if (!document.body.classList.contains('light-mode')) {
                state.cones.forEach((c, i) => { const cache = state.uiCache[i]; if (!cache) return; if (cache.lastActive !== c.active) { cache.title.style.color = c.active ? c.cssColor : 'grey'; cache.lastActive = c.active; } ['x', 'y', 'z'].forEach((axis, axIdx) => { const val = c.pos[axIdx]; if (Math.abs(val - cache.lastPos[axIdx]) > 0.005) { cache[axis].innerText = val.toFixed(2); cache.lastPos[axIdx] = val; } }); });
            }

            if (!document.body.classList.contains('light-mode')) {
                if (state.mouse.down) {
                    if (state.draggedConeIndex === -1 && tp) state.cones.forEach((c, i) => { if (c.active && Vec3.dist(c.pos, tp) < 0.8) state.draggedConeIndex = i; });
                    if (state.draggedConeIndex !== -1) { const np = calculateConePosition(state.mouse.x, state.mouse.y), c = state.cones[state.draggedConeIndex]; c.vel = Vec3.scale(Vec3.sub(np, c.pos), 1 / dt); c.pos = np; }
                } else state.draggedConeIndex = -1;
                state.cones.forEach(c => { if (state.draggedConeIndex === -1 || state.cones[state.draggedConeIndex] !== c) { if (Vec3.len(c.vel) > .001) { c.pos = Vec3.scale(Vec3.normalize(Vec3.add(c.pos, Vec3.scale(c.vel, dt))), 1.2); c.vel = Vec3.scale(c.vel, .95); } else c.pos = Vec3.scale(Vec3.normalize(c.pos), 1.2); } });
            } else if (state.mouse.down && state.dragStart.active) {
                state.landing.active = false; state.landing.showHandle = false; document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active');
                if (tp) { state.handle.pos = tp; const a = Vec3.cross(state.dragStart.mouseDir, Vec3.normalize(tp)), d = Math.min(1, Math.max(-1, Vec3.dot(state.dragStart.mouseDir, Vec3.normalize(tp)))); if (Vec3.len(a) > .001) { const r = Mat4.rotationAxis(Vec3.normalize(a), Math.acos(d)); state.sphere.rotation = Mat4.multiply(r, state.dragStart.sphereRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.dragStart.conePositions[i], r)); } }
            } else { state.dragStart.active = false; state.handle.active = false; }

            if (state.device && state.pipelines.sphere && state.msaaTexture) {
                const enc = state.device.createCommandEncoder(), pass = enc.beginRenderPass({ colorAttachments: [{ view: state.msaaTexture.createView(), resolveTarget: state.context.getCurrentTexture().createView(), clearValue: document.body.classList.contains('light-mode') ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, g: 0, b: 0, a: 1 }, loadOp: 'clear', storeOp: 'discard' }], depthStencilAttachment: { view: state.depthTexture.createView(), depthClearValue: 1, depthLoadOp: 'clear', depthStoreOp: 'discard' } });
                const sd = new Float32Array(80); sd.set(Mat4.multiply(vp, state.sphere.rotation), 0); sd.set(state.sphere.rotation, 16); sd.set(state.sphere.rotation, 32); sd.set(state.cameraPos, 48);[0, 1, 2].forEach(i => { sd.set(state.cones[i].pos, 52 + i * 8); sd.set(state.cones[i].active ? state.cones[i].color : [0, 0, 0], 56 + i * 8); });
                sd[76] = state.debugMode ? 1.0 : 0.0;
                state.device.queue.writeBuffer(state.buffers.sphereUniform, 0, sd);
                pass.setPipeline(state.pipelines.sphere); pass.setBindGroup(0, state.bindGroups.sphere); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setVertexBuffer(1, state.buffers.sphereNormal); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16'); pass.drawIndexed(state.sphere.indexCount);
                if (!document.body.classList.contains('light-mode')) {
                    pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, state.buffers.coneVertex); pass.setIndexBuffer(state.buffers.coneIndex, 'uint16');
                    state.cones.forEach((c, i) => { if (c.active) { let m; if (Vec3.len(Vec3.cross([0, 1, 0], c.pos)) > .001) { const y = Vec3.normalize(c.pos), x = Vec3.normalize(Vec3.cross(Vec3.len(Vec3.cross([0, 1, 0], y)) < .01 ? [0, 0, 1] : [0, 1, 0], y)), z = Vec3.cross(x, y); m = [x[0], x[1], x[2], 0, y[0], y[1], y[2], 0, z[0], z[1], z[2], 0, c.pos[0], c.pos[1], c.pos[2], 1]; } else m = Mat4.multiply(Mat4.translation(c.pos), c.pos[1] < 0 ? Mat4.rotationX(Math.PI) : Mat4.identity()); const cd = new Float32Array(20); cd.set(Mat4.multiply(vp, Mat4.multiply(m, Mat4.scale([.5, .5, .5]))), 0); cd.set(c.color, 16); state.device.queue.writeBuffer(state.buffers.coneUniform, i * 256, cd); pass.setBindGroup(0, state.bindGroups.cones[i]); pass.drawIndexed(state.coneIndexCount); } });
                } else {
                    pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16');
                    if (state.handle.active || state.landing.showHandle) {
                        const hd = new Float32Array(20); hd.set(Mat4.multiply(vp, Mat4.multiply(Mat4.translation(state.handle.pos), Mat4.scale([.08, .08, .08]))), 0); hd.set(state.handle.color, 16);
                        state.device.queue.writeBuffer(state.buffers.coneUniform, 3 * 256, hd);
                        pass.setBindGroup(0, state.getBindGroupForHandle(3));
                        pass.drawIndexed(state.sphere.indexCount);
                    }
                    let bindIdx = 4;
                    state.historyHandles.forEach((h) => {
                        const worldPos = transformPos(h.pos, state.sphere.rotation);
                        if (worldPos[2] > -0.5) {
                            const hd = new Float32Array(20);
                            hd.set(Mat4.multiply(vp, Mat4.multiply(Mat4.translation(worldPos), Mat4.scale([.08, .08, .08]))), 0);
                            hd.set(h.color, 16);
                            state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, hd);
                            pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx));
                            pass.drawIndexed(state.sphere.indexCount);
                            bindIdx++;
                        }
                    });
                }
                pass.end(); state.device.queue.submit([enc.finish()]);
            }
            requestAnimationFrame(loop);
        }
        init();

        window.updateVisitedFromDB = async function () {
            if (!window.ColorDB) return;
            const db = new window.ColorDB();
            const rooms = await db.getAllRooms();
            if (rooms && rooms.length > 0) {
                const ids = rooms.map(r => 'doc-infinite-' + r.hex);
                localStorage.setItem('p2p_visited_rooms_v1', JSON.stringify(ids));

                // Also update in-memory state so Sphere updates immediately
                if (typeof state !== 'undefined' && state.historyHandles) {
                    state.historyHandles = [];
                    rooms.forEach(r => {
                        const hex = '#' + r.hex;
                        if (typeof findPositionFromColor === 'function') {
                            const pos = findPositionFromColor(hex);
                            if (pos) {
                                state.historyHandles.push({
                                    pos: Vec3.normalize(pos),
                                    color: hexToRgbNormalized(hex),
                                    hex: hex,
                                    peerCount: 0
                                });
                            }
                        }
                    });
                }
            }
        };

        window.addEventListener("message", (event) => {
            if (event.data === "getSphereColor") {
                let savedColor = storageScope.getItem("lastSphereColor");
                if (!savedColor) savedColor = "#ff0000";
                event.source.postMessage(savedColor, event.origin);
            }
            if (event.data && event.data.type === 'handle-ready') {
                const hex = event.data.hex;
                // FIX 2 CONTINUED: Pass defaultCones ensures handles are placed based on the "Platonic" sphere
                const pos = findPositionFromColor(hex);

                // Avoid duplicates
                if (pos && !state.historyHandles.some(h => h.hex === hex)) {
                    state.historyHandles.push({
                        pos: Vec3.normalize(pos),
                        color: hexToRgbNormalized(hex),
                        hex: hex,
                        peerCount: event.data.count
                    });

                    const d = document.getElementById('debug-rooms');
                    const dItem = document.createElement('div');
                    dItem.className = 'debug-room-item ' + (event.data.count > 0 ? 'active' : '');
                    dItem.innerHTML = `<span>${hex}</span> <span class="count">${event.data.count} peer(s)</span>`;
                    d.appendChild(dItem);
                }
            }
        });

        async function initStorageAccess() {
            if (window.self === window.top) return;

            const attemptRetrieval = async (handle) => {
                try {
                    if (handle && handle.localStorage) storageScope = handle.localStorage;
                    const color = storageScope.getItem("lastSphereColor");
                    const overlay = document.getElementById('saa-overlay');
                    if (color) {
                        window.parent.postMessage(color, "*");
                        if (overlay) {
                            overlay.innerHTML = `<div style="font-family:sans-serif; color:green; font-weight:bold; text-align:center;">Synced: ${color}</div>`;
                            document.body.style.backgroundColor = color;
                        }
                    } else { if (overlay) overlay.remove(); }
                } catch (e) { console.error("Error reading storage handle:", e); }
            };

            const handleAccessRequest = async () => {
                try { const handle = await document.requestStorageAccess({ localStorage: true }); await attemptRetrieval(handle); }
                catch (err) { const overlay = document.getElementById('saa-overlay'); if (overlay) overlay.innerHTML = "Access Denied"; }
            };

            const showButton = () => {
                if (document.getElementById('saa-overlay')) return;
                const overlay = document.createElement('div');
                overlay.id = 'saa-overlay';
                Object.assign(overlay.style, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: '#fff', zIndex: 10000, display: 'flex', justifyContent: 'center', alignItems: 'center' });
                const btn = document.createElement("button");
                btn.innerText = "ðŸ”Œ Connect to Sphere";
                Object.assign(btn.style, { padding: "12px 24px", fontSize: "16px", cursor: "pointer", background: "#000", color: "#fff", border: "none", borderRadius: "8px" });
                overlay.appendChild(btn);
                document.body.appendChild(overlay);
                btn.addEventListener("click", handleAccessRequest);
            };

            try {
                const hasAccess = await document.hasStorageAccess();
                if (hasAccess) {
                    try { const handle = await document.requestStorageAccess({ localStorage: true }); await attemptRetrieval(handle); }
                    catch (e) { await attemptRetrieval(null); }
                } else { showButton(); }
            } catch (e) { console.error("Storage Access API not supported", e); }
        }

        initStorageAccess();
    </script>
</body>

</html>
