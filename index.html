<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color</title>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.8/html5-qrcode.min.js" type="text/javascript"></script>

    <!-- CSS Remains Exactly as provided -->
    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --ui-bg: rgba(255, 255, 255, 0.1);
            --ui-border: rgba(255, 255, 255, 0.2);
            --nav-color: white;
            --tracker-bg: rgba(0, 0, 0, 0.75);
            --nav-height: 90px;
            --sub-nav-height: 150px;
            --sliver-height: 10px;
        }

        body.light-mode {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --ui-bg: rgba(0, 0, 0, 0.1);
            --ui-border: rgba(0, 0, 0, 0.2);
            --nav-color: black;
            --tracker-bg: transparent;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.1s linear;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        #flash-overlay.active {
            opacity: 1;
            transition: none;
        }

        #login-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.5s ease, visibility 0s linear 0.5s;
            color: inherit;
        }

        #login-card.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.5s ease;
        }

        #color-hex {
            font-size: 5rem;
            font-weight: 900;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            line-height: 1;
        }

        #room-status {
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            margin: 15px 0 25px 0;
            opacity: 0.7;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-height: 1.2em;
            font-weight: bold;
        }

        #login-btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 12px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-decoration: none;
        }

        #login-btn:hover {
            background: currentColor;
            opacity: 0.8;
        }

        #login-btn:hover span {
            filter: invert(1);
        }

        #login-btn.hidden {
            display: none;
        }

        #hover-trigger {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--sliver-height);
            z-index: 300;
            display: none;
        }

        #top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--nav-height);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            z-index: 150;
            opacity: 0;
            pointer-events: none;
        }

        #top-nav.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-item {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            opacity: 0.5;
            transition: 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--nav-color);
            border-bottom: 2px solid transparent;
            padding-bottom: 2px;
        }

        .nav-item:hover,
        .nav-item.active {
            opacity: 1;
        }

        .nav-item.active {
            border-bottom-color: var(--nav-color);
        }

        #sub-nav-layer {
            position: fixed;
            top: var(--nav-height);
            left: 0;
            width: 100%;
            height: var(--sub-nav-height);
            z-index: 140;
            pointer-events: none;
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        #sub-nav-layer.peek-slide {
            transform: translateY(calc(100vh - var(--nav-height) - var(--sub-nav-height) - 50px + 1px));
        }

        .sub-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px 40px 0 40px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            opacity: 0;
            transition: opacity 0s;
        }

        .sub-header.active {
            opacity: 1;
            pointer-events: auto;
        }

        .page-title {
            font-size: 3rem;
            font-weight: 900;
            margin: 0 0 15px 0;
            letter-spacing: -1px;
            color: var(--text-color);
        }

        .tabs-row {
            display: flex;
            gap: 2px;
            width: 100%;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs-row::-webkit-scrollbar {
            display: none;
        }

        .sub-tab {
            padding: 12px 24px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s ease;
            user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .sub-tab:hover {
            color: white;
            background: rgba(0, 0, 0, 0.7);
        }

        .sub-tab.active {
            background: white;
            color: black;
            cursor: default;
        }

        /* Create App Button (Matches Login Button Style) */
        #create-app-btn {
            position: absolute;
            right: 40px;
            top: 45px;
            background: var(--text-color);
            color: var(--bg-color);
            padding: 8px 30px;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            z-index: 10;
        }

        #create-app-btn:hover {
            opacity: 0.8;
        }

        #dashboard-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            will-change: transform;
        }

        #dashboard-panel.active {
            transform: translateY(var(--sliver-height));
        }

        #dashboard-panel.active.revealed {
            transform: translateY(var(--nav-height));
        }

        #dashboard-panel.active.step-down {
            transform: translateY(calc(var(--nav-height) + var(--sub-nav-height)));
        }

        #dashboard-panel.active.peek-mode {
            transform: translateY(calc(100% - 50px));
        }

        #dashboard-panel.active.half-peek {
            transform: translateY(calc(100% - 60vh));
        }

        #sub-nav-layer.half-slide {
            transform: translateY(calc(100vh - var(--nav-height) - var(--sub-nav-height) - 60vh + 1px));
        }

        /* Connect Options Styles */
        .connect-options {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 20px;
            flex-wrap: wrap;
        }

        .connect-option {
            padding: 16px 28px;
            background: transparent;
            border: 1.5px solid rgba(0, 0, 0, 0.2);
            border-radius: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 0.5px;
            color: #333;
        }

        .connect-option:hover {
            background: rgba(0, 0, 0, 0.06);
            border-color: rgba(0, 0, 0, 0.35);
        }

        /* User Badge Hover Tooltip */
        #user-badge {
            position: relative;
            cursor: pointer;
        }

        #user-badge::after {
            content: attr(data-hex);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
            color: #999;
            font-size: 0.7rem;
            font-weight: 600;
            font-family: 'Menlo', monospace;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
        }

        #user-badge:hover::after {
            opacity: 1;
        }

        /* User Profile Styles */
        .user-profile {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        .user-hex-display {
            font-size: 3.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -2px;
            /* Color set dynamically via JS based on luminance */
        }

        .user-stats {
            display: flex;
            gap: 40px;
            margin-top: 20px;
        }

        /* Connect Panel Title - Distinct from page-title */
        .connect-panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 15px 0;
            text-align: center;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }

        .stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            opacity: 0.6;
            color: #333;
        }

        .content-view {
            flex: 1;
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .content-view.active {
            display: flex;
        }

        .settings-pane,
        .apps-pane {
            display: none;
            padding: 40px;
            color: #333;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        .settings-pane.active,
        .apps-pane.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #tools {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 10px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 205;
        }

        #tools.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #tools button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
            font-weight: bold;
        }

        #debug-btn,
        #freeze-btn {
            position: absolute;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            z-index: 180;
        }

        #debug-btn {
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Menlo', monospace;
            font-size: 0.8rem;
        }

        #debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #debug-btn.active {
            background: rgba(255, 0, 0, 0.5);
            border-color: red;
            color: white;
        }

        #freeze-btn {
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        #settings-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            margin-right: 30px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            pointer-events: auto;
        }

        #debug-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 10px;
            z-index: 2000;
            color: #0f0;
            font-family: 'Menlo', monospace;
            font-size: 12px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
        }

        #debug-panel.visible {
            display: block;
        }

        #debug-rooms {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .debug-room-item {
            padding: 4px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .debug-room-item .count {
            color: #fff;
            font-weight: bold;
        }

        .debug-room-item.active {
            color: #00e676;
        }

        #reset-btn {
            margin-top: 10px;
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
        }

        /* Connect Content Layer */
        #connect-content-layer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            z-index: 50;
            pointer-events: none;
            display: none;
            text-align: center;
        }

        #connect-content-layer.visible {
            display: block;
            pointer-events: auto;
        }

        .connect-view {
            display: none;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            line-height: 1.5;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .connect-view.active {
            display: flex;
            animation: fadeIn 0.5s ease;
        }

        .connect-view p {
            margin-bottom: 20px;
        }

        /* QR Specific Styles */
        #qr-display-container {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            margin-bottom: 15px;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            margin-top: 10px;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        #reset-btn:hover {
            background: #900;
        }

        .sphere-tooltip {
            position: absolute;
            display: none;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-Family: monospace;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(15px, 15px);
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
        }

        .sphere-tooltip .hex {
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            margin-bottom: 2px;
            display: block;
        }

        .sphere-tooltip .meta {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sphere-tooltip .meta.online {
            color: #00e676;
            font-weight: bold;
        }

        #chat-header {
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-family: -apple-system, system-ui, sans-serif;
            flex-shrink: 0;
            color: #1a1a1a;
            cursor: ns-resize;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 10px;
            transition: background 0.2s;
        }

        .status:hover {
            background: #eee;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .dot.on {
            background: #00e676;
            box-shadow: 0 0 5px #00e676;
        }

        #user-badge {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #999;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #fff;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow-anchor: none;
        }

        #display {
            min-height: 100%;
            outline: none;
            padding: 40px 60px;
            font-size: 16px;
            line-height: 24px;
            position: relative;
        }

        .editor-line {
            min-height: 24px;
            display: block;
            padding-left: 5px;
            border-left: 4px solid transparent;
            white-space: pre-wrap;
            transition: border-left-color 0.4s ease;
        }


        .editor-line:hover,
        .editor-line.group-hover {
            border-left-color: var(--owner-color, transparent);
        }

        .locked-line {
            position: relative;
        }

        .locked-line::before {
            content: attr(data-lock-owner);
            position: absolute;
            left: 0;
            top: 0;
            transform: translateX(-100%);
            height: 100%;
            background-color: var(--lock-color);
            color: transparent;
            font-family: sans-serif;
            font-size: 10px;
            white-space: nowrap;
            width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px 0 0 2px;
            pointer-events: auto;
            transition: width 0.3s, opacity 0.1s;
            z-index: 10;
            background-image: none !important;
            content: attr(data-lock-owner);
        }

        .locked-line:hover::before {
            width: 20px;
            opacity: 1;
            color: transparent;
        }

        .locked-line::before:hover {
            width: 60px !important;
            padding: 0 6px;
            color: #fff !important;
            z-index: 999;
        }

        #minimap {
            position: absolute;
            right: 5px;
            top: 60px;
            bottom: 0;
            width: 12px;
            z-index: 201;
            pointer-events: none;
        }

        .scroll-dot {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: top 0.1s ease-out;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        #tracker {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 25px;
            background: var(--tracker-bg);
            border: 1px solid var(--ui-border);
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 10;
            pointer-events: none;
        }

        body.light-mode #tracker {
            display: none;
        }

        .cone-data {
            display: flex;
            gap: 8px;
            font-size: 11px;
            font-family: 'Menlo', monospace;
            color: rgba(255, 255, 255, 0.6);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
            pointer-events: auto;
            cursor: default;
        }

        .cone-data:last-child {
            border-right: none;
            padding-right: 0;
        }

        .cone-title {
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
        }

        .coord-val {
            color: white;
            min-width: 38px;
            cursor: ns-resize;
        }

        @media (max-width: 768px) {
            .sub-header {
                padding-right: 0 !important;
            }

            #tracker {
                flex-direction: column !important;
                height: auto !important;
                padding: 15px !important;
                border-radius: 20px !important;
                gap: 10px !important;
                align-items: center !important;
            }

            .cone-data {
                border-right: none !important;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                padding-right: 0 !important;
                padding-bottom: 8px;
                width: 100%;
                justify-content: space-between;
            }

            .cone-data:last-child {
                border-bottom: none;
            }

            /* Mobile Nav Visibility */
            #top-nav {
                gap: 15px;
                padding: 0 10px;
            }

            .nav-item {
                font-size: 0.7rem;
                letter-spacing: 0.5px;
            }

            #settings-btn {
                width: 40px;
                height: 40px;
                margin-right: 10px;
            }

            /* Mobile Connect Options */
            .connect-options {
                gap: 12px;
                padding: 15px;
            }

            .connect-option {
                width: 85px;
                height: 85px;
                font-size: 0.55rem;
            }

            .connect-option span:first-child {
                font-size: 1.5rem;
            }

            /* Mobile Profile Display */
            .user-hex-display {
                font-size: 2.5rem;
            }

            .user-stats {
                gap: 25px;
            }

            .stat-value {
                font-size: 1.2rem;
            }

            .stat-label {
                font-size: 0.6rem;
            }

            /* Half-peek sub-header centering */
            #header-connect .page-title,
            #header-profile .page-title {
                font-size: 1.3rem;
                text-align: center;
                padding: 0 20px;
            }
        }

        .dummy-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333;
            font-weight: 900;
            font-size: 3rem;
            letter-spacing: -1px;
        }

        .settings-group {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.05);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .settings-label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .settings-input {
            width: 100%;
            background: #fff;
            border: 1px solid #ccc;
            color: #000;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }

        .settings-input:focus {
            border-color: #333;
            outline: none;
        }

        .settings-hint {
            font-size: 0.8rem;
            color: #666;
            margin-top: -5px;
            margin-bottom: 15px;
        }
    </style>
</head>

<body class="light-mode">
    <canvas id="gpu-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="hover-trigger"></div>

    <!-- Connect Content Layer (Hidden by default) -->
    <div id="connect-content-layer">
        <!-- View 1: Display QR -->
        <div id="view-qr" class="connect-view">
            <div id="qr-display-container"></div>
            <p style="margin:10px 0 20px 0; font-size: 0.8rem; opacity: 0.8; font-weight: 600;">SCAN TO JOIN INSTANTLY
            </p>
            <button id="btn-scan-mode" class="action-btn">I WANT TO SCAN</button>
        </div>
        <!-- View 2: Scan QR -->
        <div id="view-scanner" class="connect-view">
            <div id="qr-reader"
                style="width: 250px; height: 250px; background: #000; border-radius: 10px; overflow: hidden; margin-bottom: 20px; border: 2px solid rgba(255,255,255,0.3);">
            </div>
            <button id="btn-cancel-scan" class="action-btn">CANCEL</button>
        </div>
    </div>

    <nav id="top-nav">
        <div class="nav-item active" data-target="home">Home</div>
        <div class="nav-item" data-target="apps">BLOCKS</div>
        <div class="nav-item" data-target="connect">CONNECT</div>
        <div id="settings-btn">
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor" stroke="none">
                <path
                    d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.488.488 0 0 0-.58-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.488.488 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z" />
            </svg>
        </div>
    </nav>

    <div id="login-card">
        <div id="color-hex">#FFFFFF</div>
        <div id="room-status">Initializing...</div>
        <button id="login-btn"><span>LOGIN</span></button>
    </div>

    <button id="debug-btn">DEBUG OFF</button>
    <div id="debug-panel">
        <h3>System Tools</h3>
        <div
            style="background: #330000; padding: 10px; border: 1px solid #ff4444; margin-bottom: 15px; border-radius: 4px;">
            <h4 style="margin: 0 0 5px 0; color: #ff4444;">ðŸ”’ Master Security</h4>
            <div id="security-status" style="font-size: 11px; margin-bottom: 8px; color: #aaa;">STATUS: <b>UNSECURED</b>
            </div>
            <input type="password" id="master-pass" placeholder="Type Password to Lock/Unlock"
                style="width: 100%; background: #000; border: 1px solid #555; color: white; padding: 5px; margin-bottom: 5px;">
            <button id="btn-security-apply"
                style="width: 100%; background: #444; border: 1px solid #666; color: white; cursor: pointer;">APPLY
                PASSWORD</button>
        </div>
        <button id="reset-btn">WIPE ALL DATA</button>
        <h4>Discovered Rooms</h4>
        <div id="debug-rooms"></div>
    </div>

    <div id="sub-nav-layer">
        <div id="header-apps" class="sub-header">
            <h1 class="page-title">APPS</h1>
            <button id="create-app-btn">CREATE</button>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="discover" data-group="apps">DISCOVER</div>
                <div class="sub-tab" data-tab="installed" data-group="apps">INSTALLED</div>
                <div class="sub-tab" data-tab="updates" data-group="apps">UPDATES</div>
            </div>
        </div>
        <div id="header-settings" class="sub-header">
            <h1 class="page-title">SETTINGS</h1>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="general" data-group="settings">GENERAL</div>
                <div class="sub-tab" data-tab="connections" data-group="settings">CONNECTIONS</div>
                <div class="sub-tab" data-tab="signatures" data-group="settings">SIGNATURES</div>
                <div class="sub-tab" data-tab="raw" data-group="settings">RAW DATA</div>
            </div>
        </div>
        <div id="header-connect" class="sub-header">
            <div class="connect-panel-title">How would you like to connect?</div>
            <div class="connect-options">
                <div class="connect-option" data-connect-type="qr">QR Code</div>
                <div class="connect-option" data-connect-type="nearby">Nearby</div>
                <div class="connect-option" data-connect-type="topic">Topic</div>
            </div>
        </div>
        <div id="header-profile" class="sub-header">
            <div class="user-profile">
                <div class="user-hex-display" id="profile-hex">#FFFFFF</div>
                <div class="user-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-connections">0</div>
                        <div class="stat-label">Connections</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-trust">0</div>
                        <div class="stat-label">Trust</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-coins">0</div>
                        <div class="stat-label">Coins</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="dashboard-panel">
        <div id="view-home" class="content-view active">
            <div id="chat-header">
                <div><span id="user-badge" title="Your Color"></span></div>
                <div class="status" id="status-toggle"><span class="dot"></span><span
                        id="peer-count">Disconnected</span></div>
            </div>
            <div id="chat-container">
                <div id="display" contenteditable="true" spellcheck="false"></div>
            </div>
            <div id="minimap"></div>
        </div>
        <div id="view-apps" class="content-view">
            <div id="tab-discover" class="apps-pane active">
                <h2>Discover Apps</h2>
                <div class="dummy-content">APPS STORE</div>
            </div>
            <div id="tab-installed" class="apps-pane">
                <h2>Installed</h2>
            </div>
            <div id="tab-updates" class="apps-pane">
                <h2>Updates</h2>
            </div>
        </div>
        <div id="view-settings" class="content-view">
            <div id="tab-general" class="settings-pane active">
                <h2>General Settings</h2>
            </div>
            <div id="tab-connections" class="settings-pane">
                <h2>Network Connections</h2>
                <div class="settings-group">
                    <h3 style="margin-top:0; margin-bottom: 10px; font-size: 1rem;">How to get a Free TURN Server</h3>
                    <ol
                        style="font-size: 0.85rem; line-height: 1.5; padding-left: 20px; color: #444; margin-bottom: 20px;">
                        <li>Go to <a href="https://metered.ca/stun-turn" target="_blank"
                                style="color: #0066cc; text-decoration: none; font-weight: bold;">Metered.ca
                                STUN/TURN</a> and create a free account.</li>
                        <li>Give your app a name and hit "Create App".</li>
                        <li>Copy and paste your custom <strong>App Name</strong> and <strong>API Key</strong> into the
                            fields below.</li>
                    </ol>

                    <label class="settings-label">Metered.ca App Name</label>
                    <input type="text" id="turn-app-name" class="settings-input" placeholder="e.g. yourappname">
                    <label class="settings-label">Metered.ca API Key</label>
                    <input type="password" id="turn-api-key" class="settings-input" placeholder="e.g. at_xxx...">
                </div>
            </div>
            <div id="tab-signatures" class="settings-pane">
                <h2>Cryptographic Signatures</h2>
            </div>
            <div id="tab-raw" class="settings-pane">
                <h2>Raw Data Inspector</h2>
            </div>
        </div>
    </div>

    <div id="tools">
        <button id="btn-bold">B</button>
        <button id="btn-italic">I</button>
        <button id="btn-link">ðŸ”—</button>
    </div>

    <div id="freeze-btn"><svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none"
            stroke-width="2">
            <path d="M9 18h6" />
            <path d="M10 22h4" />
            <path
                d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" />
        </svg></div>
    <div id="tracker">
        <div class="cone-data" id="data-0"></div>
        <div class="cone-data" id="data-1"></div>
        <div class="cone-data" id="data-2"></div>
    </div>

    <script type="module">
        const TRACKERS = ['wss://relay.rollcall.network', 'wss://tracker.webtorrent.dev', 'wss://tracker.openwebtorrent.com', 'wss://tracker.btorrent.xyz'];
        const OFFER_POOL_SIZE = 12;
        const OFFER_TTL = 57_333;
        const ANNOUNCE_INTERVAL = 33_333;
        const ICE_TIMEOUT = 5000;
        let cachedRTCConfig = null;
        let rtcConfigFetchTime = 0;

        async function getRTCConfig() {
            if (cachedRTCConfig && (Date.now() - rtcConfigFetchTime < 1000 * 60 * 60 * 12)) {
                return cachedRTCConfig;
            }

            const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }, { urls: 'stun:stun2.l.google.com:19302' }, { urls: 'stun:stun.cloudflare.com:3478' }] };
            const appName = localStorage.getItem('turnAppName');
            const apiKey = localStorage.getItem('turnApiKey');

            if (appName && apiKey) {
                try {
                    const response = await fetch(`https://${appName}.metered.live/api/v1/turn/credentials?apiKey=${apiKey}`);
                    if (response.ok) {
                        const iceServers = await response.json();
                        config.iceServers = iceServers;
                    } else {
                        console.warn("Failed to fetch TURN credentials from Metered.ca");
                    }
                } catch (e) {
                    console.error("Error fetching TURN credentials:", e);
                }
            }

            cachedRTCConfig = config;
            rtcConfigFetchTime = Date.now();
            return config;
        }

        const charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';
        const genId = n => Array(n).fill().map(() => charSet[Math.floor(Math.random() * charSet.length)]).join('');
        const encoder = new TextEncoder();
        async function sha1Hash(str) { const hashBuffer = await crypto.subtle.digest('SHA-1', encoder.encode(str)); return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(36)).join('').slice(0, 20); }
        const selfId = genId(20);

        function waitForIce(pc) { return Promise.race([new Promise(resolve => { const checkState = () => { if (pc.iceGatheringState === 'complete') { pc.removeEventListener('icegatheringstatechange', checkState); resolve(); } }; pc.addEventListener('icegatheringstatechange', checkState); checkState(); }), new Promise(resolve => setTimeout(resolve, ICE_TIMEOUT))]).then(() => ({ type: pc.localDescription.type, sdp: pc.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, '') })); }

        async function createPeerConnection(isInitiator, onDataChannel, connectedPeersRef = null, peerLeaveCallbacksRef = null, onIceFailedRef = null, peerId = null) {
            const config = await getRTCConfig();
            const pc = new RTCPeerConnection(config);
            let dc = null;
            if (isInitiator) { dc = pc.createDataChannel('data'); dc.binaryType = 'arraybuffer'; } else { pc.ondatachannel = e => { dc = e.channel; dc.binaryType = 'arraybuffer'; onDataChannel?.(dc); }; }
            pc.onconnectionstatechange = () => { if (pc.connectionState === 'closed' && connectedPeersRef) for (const [pId, peer] of Object.entries(connectedPeersRef)) if (peer.pc === pc) { delete connectedPeersRef[pId]; peerLeaveCallbacksRef?.forEach(cb => cb(pId)); break; } };
            pc.oniceconnectionstatechange = () => { if (pc.iceConnectionState === 'failed' && onIceFailedRef && peerId) onIceFailedRef(peerId); };
            return { pc, dc };
        }
        async function createOffer(connectedPeersRef = null, peerLeaveCallbacksRef = null, onIceFailedRef = null) { const { pc, dc } = await createPeerConnection(true, null, connectedPeersRef, peerLeaveCallbacksRef, onIceFailedRef); const offerId = genId(20); await pc.setLocalDescription(await pc.createOffer()); const offer = await waitForIce(pc); return { pc, dc, offer, offerId, created: Date.now() }; }

        function joinRoom(config, roomId) {
            const connectedPeers = {}, pendingOffers = {}, handledOffers = new Set(), trackerSockets = {}, peerJoinCallbacks = [], peerLeaveCallbacks = [], peerDiscoverCallbacks = [], peerErrorCallbacks = [], actionHandlers = {}, announceIntervals = [];
            let offerPool = [], infoHash = null, isLeaving = false, readyResolve;
            let syncEnabled = false;
            let discoveredPeers = new Set();
            const readyPromise = new Promise(resolve => { readyResolve = resolve; });

            async function fillOfferPool() { const needed = OFFER_POOL_SIZE - offerPool.length; if (needed > 0) offerPool.push(...await Promise.all(Array(needed).fill().map(() => createOffer(connectedPeers, peerLeaveCallbacks, (pid) => peerErrorCallbacks.forEach(cb => cb(pid)))))); }
            async function getOffersFromPoolAsync(n) {
                if (offerPool.length === 0) fillOfferPool();
                while (offerPool.length === 0 && !isLeaving) await new Promise(r => setTimeout(r, 100));
                if (isLeaving) return [];
                const now = Date.now(); offerPool = offerPool.filter(o => now - o.created <= OFFER_TTL);
                const taken = offerPool.splice(0, n); fillOfferPool(); return taken;
            }
            function setupDataChannel(dc, peerId) {
                const handleOpen = () => peerJoinCallbacks.forEach(cb => cb(peerId));
                if (dc.readyState === 'open') handleOpen(); else dc.onopen = handleOpen;
                dc.onclose = () => { delete connectedPeers[peerId]; peerLeaveCallbacks.forEach(cb => cb(peerId)); };
                dc.onmessage = e => { try { const msg = JSON.parse(e.data); if (msg.action && actionHandlers[msg.action]) actionHandlers[msg.action].forEach(cb => cb(msg.data, peerId)); } catch (err) { } };
            }
            function sendToAllPeers(action, data, targetPeerId = null) {
                const message = JSON.stringify({ action, data });
                for (const [peerId, peer] of Object.entries(connectedPeers)) { if (targetPeerId && peerId !== targetPeerId) continue; if (peer.dc && peer.dc.readyState === 'open') try { peer.dc.send(message); } catch (e) { } }
            }
            function connectToTracker(url) {
                if (isLeaving) return;
                const ws = new WebSocket(url); trackerSockets[url] = ws;
                ws.onopen = () => startAnnouncing(ws, url);
                ws.onerror = (e) => { console.warn(`Tracker connection error to ${url}:`, e); };
                ws.onmessage = e => { try { const data = JSON.parse(e.data); if (data) handleTrackerMessage(ws, data); } catch (err) { } };
                ws.onclose = () => { delete trackerSockets[url]; if (!isLeaving) setTimeout(() => connectToTracker(url), 5000); };
            }
            async function startAnnouncing(ws, url) {
                await readyPromise;
                const announce = async () => {
                    if (ws.readyState !== WebSocket.OPEN || isLeaving || !infoHash) return;
                    const offers = syncEnabled ? await getOffersFromPoolAsync(3) : [];
                    if (syncEnabled && offers.length === 0) return;
                    if (syncEnabled) {
                        for (const o of offers) { pendingOffers[o.offerId] = { pc: o.pc, dc: o.dc, created: o.created }; setTimeout(() => { if (pendingOffers[o.offerId]) { pendingOffers[o.offerId].pc.close(); delete pendingOffers[o.offerId]; } }, OFFER_TTL); }
                    }
                    ws.send(JSON.stringify({ action: 'announce', info_hash: infoHash, peer_id: selfId, numwant: OFFER_POOL_SIZE, offers: offers.map(o => ({ offer_id: o.offerId, offer: { type: o.offer.type, sdp: o.offer.sdp } })) }));
                };
                await announce(); announceIntervals.push(setInterval(announce, ANNOUNCE_INTERVAL));
            }
            async function handleTrackerMessage(ws, data) {
                await readyPromise;
                if (data.info_hash !== infoHash || data.peer_id === selfId) return;

                if (data.peer_id && !discoveredPeers.has(data.peer_id)) {
                    discoveredPeers.add(data.peer_id);
                    peerDiscoverCallbacks.forEach(cb => cb(data.peer_id));
                }

                if (!syncEnabled) return;

                if (data.offer && data.offer_id) {
                    if (handledOffers.has(data.offer_id) || connectedPeers[data.peer_id]) return;
                    handledOffers.add(data.offer_id);
                    if (Object.values(pendingOffers).some(p => p.peerId === data.peer_id) && selfId > data.peer_id) return;
                    try {
                        const peerEntry = { pc: null, dc: null }; connectedPeers[data.peer_id] = peerEntry;
                        const { pc, dc } = await createPeerConnection(false, channel => { if (connectedPeers[data.peer_id]) connectedPeers[data.peer_id].dc = channel; else connectedPeers[data.peer_id] = { pc: pc, dc: channel }; setupDataChannel(channel, data.peer_id); }, connectedPeers, peerLeaveCallbacks, (pid) => peerErrorCallbacks.forEach(cb => cb(pid)), data.peer_id);
                        peerEntry.pc = pc; await pc.setRemoteDescription(new RTCSessionDescription(data.offer)); await pc.setLocalDescription(await pc.createAnswer());
                        ws.send(JSON.stringify({ action: 'announce', info_hash: infoHash, peer_id: selfId, to_peer_id: data.peer_id, offer_id: data.offer_id, answer: await waitForIce(pc) }));
                    } catch (err) { delete connectedPeers[data.peer_id]; }
                }
                if (data.answer && data.offer_id) {
                    const pending = pendingOffers[data.offer_id];
                    if (!pending || connectedPeers[data.peer_id]) return;
                    try {
                        connectedPeers[data.peer_id] = { pc: pending.pc, dc: pending.dc }; setupDataChannel(pending.dc, data.peer_id);
                        pending.pc.oniceconnectionstatechange = () => { if (pending.pc.iceConnectionState === 'failed') peerErrorCallbacks.forEach(cb => cb(data.peer_id)); };
                        await pending.pc.setRemoteDescription(new RTCSessionDescription(data.answer)); delete pendingOffers[data.offer_id];
                    } catch (err) { pending.pc.close(); delete pendingOffers[data.offer_id]; delete connectedPeers[data.peer_id]; }
                }
            }
            TRACKERS.forEach(url => connectToTracker(url));
            (async () => {
                infoHash = await sha1Hash(config.appId + roomId);
                readyResolve(); // Resolve immediately to unblock tracker announce
                await fillOfferPool();
                setInterval(fillOfferPool, OFFER_TTL);
            })();
            return {
                makeAction(name) { if (!actionHandlers[name]) actionHandlers[name] = []; return [(data, target) => sendToAllPeers(name, data, target), cb => actionHandlers[name].push(cb)]; },
                onPeerJoin(cb) { peerJoinCallbacks.push(cb); }, onPeerLeave(cb) { peerLeaveCallbacks.push(cb); }, getPeers() { return connectedPeers; },
                onPeerDiscover(cb) { peerDiscoverCallbacks.push(cb); }, onPeerError(cb) { peerErrorCallbacks.push(cb); },
                getDiscoveredPeers() { return discoveredPeers; },
                enableSync() {
                    if (!syncEnabled) {
                        syncEnabled = true;
                        Object.values(trackerSockets).forEach(async ws => {
                            if (ws.readyState === WebSocket.OPEN) {
                                const offers = await getOffersFromPoolAsync(3);
                                for (const o of offers) { pendingOffers[o.offerId] = { pc: o.pc, dc: o.dc, created: o.created }; setTimeout(() => { if (pendingOffers[o.offerId]) { pendingOffers[o.offerId].pc.close(); delete pendingOffers[o.offerId]; } }, OFFER_TTL); }
                                ws.send(JSON.stringify({ action: 'announce', info_hash: infoHash, peer_id: selfId, numwant: OFFER_POOL_SIZE, offers: offers.map(o => ({ offer_id: o.offerId, offer: { type: o.offer.type, sdp: o.offer.sdp } })) }));
                            }
                        });
                    }
                },
                leave() { isLeaving = true; announceIntervals.forEach(clearInterval); Object.values(trackerSockets).forEach(ws => ws.close()); Object.values(connectedPeers).forEach(p => p.pc.close()); Object.values(pendingOffers).forEach(p => p.pc.close()); offerPool.forEach(o => o.pc.close()); }
            };
        }

        // =================================================================================
        // ARCHITECTURE LAYERS: Identity -> TrustedMesh -> StateStore -> UI
        // =================================================================================

        class ColorDB {
            constructor() { this.name = 'color'; }
            async init() { return; }
            async _open(hex) {
                await window.app.identity._call('db_init', { roomHex: hex });
            }
            async saveLine(hex, index, content, ownerHex) {
                console.warn("ColorDB.saveLine called - should use identity.db_write_local");
            }
            async getCursor(hex) { return window.app.identity._call('db_read_cursor', { roomHex: hex }); }
            async getRange(hex, min, max) { return window.app.identity._call('db_read_range', { roomHex: hex, min, max }); }
            async getSpecific(hex, keys) {
                return window.app.identity._call('db_read_specific', { roomHex: hex, keys });
            }
            async getAllRooms() {
                return window.app.identity._call('db_get_all_rooms', {});
            }
            async saveSignature(hex, signature) {
                return window.app.identity._call('saveSignature', { roomHex: hex, signature });
            }
            async getLastEdited(hex) {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open('color');
                    req.onsuccess = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(hex)) { db.close(); resolve(0); return; }
                        const tx = db.transaction([hex], 'readonly');
                        const store = tx.objectStore(hex);
                        let maxTs = 0;
                        let lastIndex = 0;

                        const cursorReq = store.openCursor();
                        cursorReq.onsuccess = (ev) => {
                            const cursor = ev.target.result;
                            if (cursor) {
                                if (cursor.value.updated > maxTs) {
                                    maxTs = cursor.value.updated;
                                    lastIndex = parseInt(cursor.key);
                                }
                                cursor.continue();
                            } else {
                                db.close();
                                resolve(lastIndex);
                            }
                        };
                        cursorReq.onerror = () => { db.close(); resolve(0); };
                    };
                    req.onerror = () => resolve(0);
                });
            }
            async roomExists(hex) {
                return window.app.identity._call('db_has_room', { roomHex: hex });
            }
        }
        window.ColorDB = ColorDB;

        class TrustedMesh {
            constructor(roomId, identity) {
                this.roomHex = roomId.replace('color-', '');
                this.room = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69' }, roomId);
                this.identity = identity;
                this.handlers = new Map();

                // CRITICAL: The "VIP List"
                this.verifiedPeers = new Set();

                // NEW: Secrets Management for QR Fast-Pass
                this.outgoingQrSecret = null;
                this.expectedQrSecret = null;

                this.room.onPeerDiscover((pid) => {
                    this.emit('peer-discover', pid);
                });

                this.room.onPeerError((pid) => {
                    this.emit('peer-error', pid);
                });

                // Actions
                const [sendFrag, onFrag] = this.room.makeAction('fragment');
                const [sendLock, onLock] = this.room.makeAction('lock');
                const [sendReq, onReq] = this.room.makeAction('req');
                const [sendId, onId] = this.room.makeAction('identity');
                this.rawSendFrag = sendFrag; this.rawSendLock = sendLock; this.rawSendReq = sendReq; this.rawSendId = sendId;

                // 1. Identity Handshake (Sending my ID when I meet someone)
                this.room.onPeerJoin(async (pid) => {
                    console.log(`%c[P2P] Peer Joined: ${pid}`, 'color: cyan; font-weight: bold;');
                    const jwk = await this.identity.getPublicKeyData();
                    const token = window.app.user.proofToken || "PENDING";

                    this.rawSendId({
                        color: window.app.user.color,
                        pubKey: jwk,
                        cursor: window.app.currentLineId ? (window.app.parseId(window.app.currentLineId)?.index || 0) : 0,
                        minedToken: token,
                        // NEW: Include secret if we are the guest
                        qrSecret: this.outgoingQrSecret
                    }, pid);

                    this.emit('peer-join', pid);
                });

                // 2. RECEIVE IDENTITY HANDSHAKE (The Bouncer Logic)
                onId(async (data, pid) => {
                    let isVerified = false;

                    // CHECK 1: The QR Fast-Pass (Option C)
                    // If they have the secret we generated, verify them INSTANTLY.
                    if (this.expectedQrSecret && data.qrSecret === this.expectedQrSecret) {
                        console.log(`%c[P2P] ðŸŽŸï¸ VIP Ticket Accepted for ${pid}`, 'color: gold; font-weight: bold;');
                        isVerified = true;
                    }
                    // CHECK 1.5: The Room Owner (Original Peer)
                    else if (data.color && data.color.replace('#', '').toLowerCase() === this.roomHex.toLowerCase()) {
                        console.log(`%c[P2P] ðŸ‘‘ Room Owner verified automatically: ${pid}`, 'color: #00e676; font-weight: bold;');
                        isVerified = true;
                    }
                    // CHECK 2: The Standard Mining Check (Fallback)
                    else if (data.minedToken && data.minedToken !== "PENDING") {
                        isVerified = await this.identity._call('validate_peer', {
                            peerId: data.minedToken,
                            roomHex: this.roomHex
                        });
                    } else {
                        console.log(`[P2P] Peer ${pid} is not ready yet (Token: ${data.minedToken})`);
                    }

                    if (isVerified) {
                        console.log(`%c[P2P] âœ… Peer verified: ${pid}`, 'color: #00e676;');
                        this.verifiedPeers.add(pid);
                        if (data.pubKey) await this.identity.storePeerKey(pid, data.pubKey);
                        this.emit('peer-identity', data, pid);
                    } else if (data.minedToken && data.minedToken !== "PENDING") {
                        console.warn(`[P2P] âŒ Peer verification failed for ${pid}`);
                    }
                });

                // 3. Verified Data Pipeline
                onFrag(async (fragMap, pid) => {
                    if (!this.verifiedPeers.has(pid)) {
                        console.warn(`[P2P] ðŸ›‘ BLOCKED packet from ${pid}: Peer not verified.`);
                        return; // REJECT DATA
                    }

                    console.log(`[P2P] ðŸ“¦ Processing verified packet from ${pid}`, fragMap);

                    if (!this.roomHex) return;
                    const verifiedData = await this.identity._call('db_verify_remote', {
                        fragments: fragMap,
                        roomHex: this.roomHex,
                        peerId: pid
                    });

                    if (Object.keys(verifiedData).length > 0) this.emit('fragment', verifiedData, pid);
                });

                // Passthrough actions
                onLock((d, p) => this.emit('lock', d, p));
                onReq((d, p) => this.emit('req', d, p));
                this.room.onPeerLeave(p => this.emit('peer-leave', p));
            }

            // NEW FUNCTION: Call this when mining finishes!
            async broadcastIdentity() {
                const token = window.app.user.proofToken;
                const jwk = await this.identity.getPublicKeyData();
                if (token && jwk) {
                    console.log(`%c[P2P] ðŸ“¡ Broadcasting NEW Identity to all peers`, 'color: orange;');
                    this.rawSendId({
                        color: window.app.user.color,
                        pubKey: jwk,
                        // Parse the current line ID to get the integer index
                        cursor: window.app.currentLineId ? (window.app.parseId(window.app.currentLineId)?.index || 0) : 0,
                        minedToken: token,
                        qrSecret: this.outgoingQrSecret
                    });
                }
            }

            async broadcastFragment(fragMap) {
                this.rawSendFrag(fragMap);
            }

            broadcastLock(data) { this.rawSendLock(data); }
            requestSync(keys) { this.rawSendReq(keys); }
            getPeers() { return this.room.getPeers(); }
            getDiscoveredPeers() { return this.room.getDiscoveredPeers(); }
            enableSync() { this.room.enableSync(); }
            leave() { this.room.leave(); }
            on(e, cb) { if (!this.handlers.has(e)) this.handlers.set(e, []); this.handlers.get(e).push(cb); }
            emit(e, ...args) { this.handlers.get(e)?.forEach(cb => cb(...args)); }

            // NEW: Helper methods
            setExpectedSecret(secret) { this.expectedQrSecret = secret; }
            setOutgoingSecret(secret) { this.outgoingQrSecret = secret; }
        }
        class StateStore {
            constructor(db, mesh, identity) {
                this.db = db;
                this.mesh = mesh;
                this.identity = identity;
                this.roomId = null;
                this.listeners = []; // Simple event system

                // Bind Network Events immediately
                this.mesh.on('fragment', (data, pid) => this.handleRemoteUpdate(data, pid));
            }

            setRoom(hex) {
                this.roomId = hex;
            }

            subscribe(callback) {
                this.listeners.push(callback);
            }

            emitChange(index, content, owner) {
                this.listeners.forEach(cb => cb(index, content, owner));
            }

            // HANDLE REMOTE DATA
            async handleRemoteUpdate(fragMap, pid) {
                if (!this.roomId) return;
                const indices = Object.keys(fragMap).map(k => parseInt(k)).sort((a, b) => a - b);
                for (const idx of indices) {
                    const item = fragMap[idx];
                    this.emitChange(idx, item.content, item.owner);
                }
            }

            // HANDLE LOCAL USER INPUT
            async handleLocalUpdate(index, content, userColor) {
                if (!this.roomId) return;
                const ownerHex = userColor.replace('#', '');
                const roomHex = this.roomId.replace('color-', '');

                // Call worker
                const result = await this.identity._call('db_write_local', { roomHex, index, content, owner: ownerHex });

                // Broadcast payload includes the timestamp (result.updated)
                this.mesh.broadcastFragment({
                    [index]: {
                        content: result.content,
                        owner: result.owner,
                        signature: result.signature,
                        updated: result.updated // Critical for verification
                    }
                });
            }
        }

        class EditorApp {
            constructor() {
                this.identity = new SecureIdentity();
                this.db = new ColorDB();
                this.mesh = null;
                this.ui = Object.fromEntries(['display', 'chat-container', 'minimap', 'peer-count', 'tools', 'room-status', 'login-btn', 'user-badge', 'login-card', 'dashboard-panel', 'hover-trigger', 'top-nav', 'sub-nav-layer'].map(id => [id.replace(/-./g, x => x[1].toUpperCase()), document.getElementById(id)]));
                this.ui.dot = document.querySelector('.dot');

                let savedColor = localStorage.getItem('lastSphereColor') || '#ffffff';
                this.user = { id: 'user_' + savedColor.replace('#', ''), color: savedColor };

                this.visitedRooms = [];
                this.activeLocks = {};
                this.peerColors = {};
                this.initDone = false;
                this.currentLineId = null;
                this.isFresh = true;
                this.saveTimeout = null;
                this.store = null;
                this.halfPeekMode = null;
                this.pendingVipTicket = null; // New state for Guest QR flow

                // Init Systems
                Promise.all([this.identity.init(), this.db.init()]).then(async () => {
                    const rooms = await this.db.getAllRooms();
                    this.visitedRooms = rooms.map(r => 'color-' + r.hex);
                    if (!window.location.hash || window.location.hash.length < 2) this.runSequencedScan();
                    else this.tryAutoConnectFromHash();
                    this.initDone = true;
                });

                this.bindEvents();
                this.setupGlobalExposure();
            }

            // --- HELPERS ---
            makeId(index) { return this.roomId.replace('color-', '') + index; }

            parseId(id) {
                if (!id) return null;
                const roomHex = this.roomId.replace('color-', '');
                if (id.startsWith(roomHex)) {
                    const idx = parseInt(id.slice(roomHex.length), 10);
                    if (!isNaN(idx)) return { index: idx, owner: roomHex };
                }
                return null;
            }

            reconstructLine(id, content, ownerHex) {
                const myHex = this.user.color.replace('#', '');
                const effectiveOwner = ownerHex || this.roomId.replace('color-', '');
                const isEmpty = !content || content === '<br>' || content.trim() === '';
                const amOwner = (effectiveOwner === myHex);
                const isEditable = (isEmpty || amOwner) ? 'true' : 'false';
                return `<div id="${id}" class="editor-line" contenteditable="${isEditable}">${content || '<br>'}</div>`;
            }

            createRow(index) {
                return this.reconstructLine(this.makeId(index), null, null);
            }

            createLines(count) {
                let html = '';
                for (let i = 0; i < count; i++) {
                    html += this.createRow(i);
                }
                return html;
            }

            // --- MISSING METHODS RESTORED ---
            tryAutoConnectFromHash() {
                if (window.location.hash.length > 1) this.connectAndPreview(window.location.hash, true);
            }

            getFragments(visibleOnly = false) {
                const d = {};
                const top = this.ui.chatContainer.scrollTop - 500;
                const bot = top + this.ui.chatContainer.clientHeight + 1000;
                const roomHex = this.roomId.replace('color-', '');

                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id && (!visibleOnly || (el.offsetTop + el.offsetHeight > top && el.offsetTop < bot))) {
                        const meta = this.parseId(el.id);
                        if (meta) {
                            const content = el.innerHTML;
                            if (content && content !== '<br>' && content.trim().length > 0) {
                                d[meta.index] = {
                                    content: content,
                                    owner: el.getAttribute('data-lock-owner') || roomHex
                                };
                            }
                        }
                    }
                });
                return d;
            }

            // --- CORE UI LOGIC ---
            enterRoomUI() {
                if (window.state) { window.state.landing.active = false; window.state.landing.showHandle = false; }
                if (this.ui.dashboardPanel.classList.contains('active')) return;

                const roomHex = this.roomId.replace('color-', '');

                if (this.ui.loginBtn.textContent === "LOGIN") {
                    this.user.color = '#' + roomHex;
                    this.ui.userBadge.style.backgroundColor = this.user.color;
                    localStorage.setItem('lastSphereColor', this.user.color);
                    this.user.id = 'user_' + this.user.color.replace('#', '');
                }

                this.ui.loginBtn.classList.add('hidden');
                this.ui.loginCard.classList.remove('visible');
                this.ui.dashboardPanel.classList.add('active');

                this.triggerSave(null);
                this.ui.hoverTrigger.style.display = 'block';

                if (window.state && window.state.interactionSignature) {
                    this.db.saveSignature(roomHex, window.state.interactionSignature);
                }

                if (!this.visitedRooms.includes(this.roomId)) {
                    this.visitedRooms.push(this.roomId);
                    this.db._open(roomHex);
                }

                setTimeout(() => {
                    document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                }, 300);

                window.location.hash = roomHex;

                if (!this.ui.display.querySelector('.editor-line')) {
                    this.ui.display.innerHTML = this.createLines(101);
                    this.isFresh = true;
                    this.focusLine(50);
                } else {
                    this.db.getLastEdited(roomHex).then(idx => {
                        this.focusLine(idx);
                    });
                }
            }

            startMining() {
                if (this.minedForSession || this.miningInProgress) return;
                const cleanHex = this.roomId.replace('color-', '').toLowerCase();
                const userHex = this.user.color.replace('#', '').toLowerCase();

                if (cleanHex === userHex) {
                    this.minedForSession = true;
                    if (this.mesh) this.mesh.enableSync();
                    return;
                }

                this.miningInProgress = true;
                console.log("%c[MINING] Starting mining...", "color: orange;");
                this.identity._call('generate_token', { roomHex: cleanHex }).then(token => {
                    console.log("%c[MINING] Proof Generated: " + token, "color: orange; font-weight: bold;");
                    this.user.proofToken = token;
                    this.minedForSession = true;
                    this.miningInProgress = false;

                    if (this.mesh) {
                        this.mesh.broadcastIdentity();
                        this.mesh.enableSync();
                        console.log("[P2P] â³ Ready. Waiting for peer cursor...");
                    }

                    this.updateStatus();
                }).catch(err => {
                    console.error("Mining failed:", err);
                    this.miningInProgress = false;
                    this.updateStatus();
                });
            }

            async connectAndPreview(hex, fromUrl = false) {
                const cleanHex = hex.replace('#', '').toLowerCase();
                this.roomId = 'color-' + cleanHex;
                this.user.color = localStorage.getItem('lastSphereColor') || '#ffffff';
                this.ui.userBadge.style.backgroundColor = this.user.color;
                this.ui.userBadge.setAttribute('data-hex', this.user.color.toUpperCase());
                this.user.id = 'user_' + this.user.color.replace('#', '');

                if (this.mesh) { this.mesh.leave(); this.mesh = null; }

                this.ui.loginBtn.classList.remove('hidden');
                // Ensure worker has init
                await this.db._open();

                const exists = await this.db.roomExists(cleanHex);

                if (exists) {
                    this.ui.roomStatus.textContent = "Loading...";
                    const centerIndex = await this.db.getLastEdited(cleanHex);
                    const data = await this.db.getRange(cleanHex, centerIndex - 50, centerIndex + 50);
                    await this.renderFromLocalDB(data, centerIndex);
                    this.ui.roomStatus.textContent = "READY";
                    this.joinNetwork();
                    if (fromUrl && window.state?.landing) {
                        window.state.landing.shouldAutoEnter = true;
                        if (window.state.landing.progress >= 1 && window.enterRoomUI) window.enterRoomUI();
                    }
                } else {
                    this.ui.roomStatus.textContent = "Checking Network...";
                    this.joinNetwork();

                    // Only say COLOR AVAILABLE if we didn't discover any peers in 8 seconds (accounts for mobile latency).
                    setTimeout(() => {
                        const discoveredPeers = this.mesh?.getDiscoveredPeers()?.size || 0;
                        if (discoveredPeers === 0 && this.ui.roomStatus.textContent === "Checking Network...") {
                            this.ui.roomStatus.textContent = "COLOR AVAILABLE";
                        }
                    }, 8000);
                }

                if (fromUrl) {
                    this.startMining();
                } else {
                    if (this.mesh) this.mesh.enableSync();
                }
            }

            async renderFromLocalDB(data, centerIndex) {
                this.renderInitialState(data, centerIndex);
                this.isFresh = false;
            }


            joinNetwork() {
                this.mesh = new TrustedMesh(this.roomId, this.identity);

                // NEW: Check for pending VIP Ticket (Guest Mode)
                if (this.pendingVipTicket) {
                    this.mesh.setOutgoingSecret(this.pendingVipTicket);
                    this.pendingVipTicket = null; // Clear after assignment
                }

                this.store = new StateStore(this.db, this.mesh, this.identity);
                this.store.setRoom(this.roomId.replace('color-', ''));

                this.store.subscribe((index, content, owner) => {
                    this.renderUpdate(index, content, owner);
                });

                this.mesh.on('peer-discover', (pid) => {
                    this.updateStatus();
                });

                this.mesh.on('peer-error', (pid) => {
                    this.updateStatus(true);
                });

                this.mesh.on('peer-join', (pid) => {
                    this.updateStatus();
                    if (this.currentLineId) this.mesh.broadcastLock({ lineId: this.currentLineId, userColor: this.user.color });
                });

                this.mesh.on('peer-leave', () => { this.updateStatus(); this.reapplyVisualLocks(); });

                this.mesh.on('peer-identity', (data, pid) => {
                    this.peerColors[pid] = data?.color || '#ffffff';

                    // IF WE ARE THE NEW USER (Fresh session) AND PEER SENT A CURSOR
                    if (this.isFresh && typeof data.cursor === 'number') {
                        console.log(`[EditorApp] ðŸŽ¯ Peer is at line ${data.cursor}. Syncing range...`);
                        this.pendingFocusLine = data.cursor;
                        this.renderInitialState({}, data.cursor);
                        this.isFresh = false;

                        const start = data.cursor - 50;
                        const end = data.cursor + 50;
                        const missingKeys = [];
                        const roomHex = this.roomId.replace('color-', '');

                        for (let i = start; i <= end; i++) {
                            missingKeys.push(roomHex + i);
                        }
                        this.mesh.requestSync(missingKeys);
                    }
                });

                this.mesh.on('lock', (data, pid) => {
                    this.activeLocks[pid] = { lineId: data.lineId, ts: Date.now(), color: data.userColor };
                    this.reapplyVisualLocks();
                });

                this.mesh.on('req', async (keys, pid) => {
                    const roomHex = this.roomId.replace('color-', '');
                    if (keys && Array.isArray(keys)) {
                        const payload = await this.db.getSpecific(roomHex, keys);
                        if (Object.keys(payload).length > 0) {
                            this.mesh.broadcastFragment(payload);
                        }
                    }
                });

                setInterval(() => this.updateStatus(), 1000);
            }

            renderUpdate(index, newContent, newOwner) {
                const roomHex = this.roomId.replace('color-', '');
                const domId = roomHex + index;
                let el = document.getElementById(domId);

                if (document.activeElement === el) return;

                if (!el) {
                    const temp = document.createElement('div');
                    temp.innerHTML = this.reconstructLine(domId, newContent, newOwner);
                    const newEl = temp.firstElementChild;
                    const children = Array.from(this.ui.display.children);
                    let ref = null;
                    for (let j = 0; j < children.length; j++) {
                        const cMeta = this.parseId(children[j].id);
                        if (cMeta && cMeta.index > index) { ref = children[j]; break; }
                    }
                    this.ui.display.insertBefore(newEl, ref);
                    el = newEl;
                }

                if (el) {
                    if (el.innerHTML !== newContent) el.innerHTML = this.sanitize(newContent || '<br>');
                    const myHex = this.user.color.replace('#', '');
                    const isEmpty = !newContent || newContent.trim() === '' || newContent === '<br>';
                    const amOwner = (newOwner === myHex);
                    el.contentEditable = (isEmpty || amOwner) ? 'true' : 'false';
                }

                if (this.pendingFocusLine !== undefined && index === this.pendingFocusLine) {
                    this.focusLine(this.pendingFocusLine);
                    this.pendingFocusLine = undefined;
                }
            }

            async triggerSave(lineId) {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                const meta = this.parseId(lineId);
                if (!meta) return;

                const el = document.getElementById(lineId);
                if (!el) return;
                const content = el.innerText.trim().length > 0 ? el.innerHTML : null;
                console.log("[EditorApp] triggerSave", lineId, content);

                if (this.store) {
                    await this.store.handleLocalUpdate(meta.index, content, this.user.color);
                }
            }

            bindEvents() {
                this.ui.display.addEventListener('input', (e) => {
                    this.isFresh = false; clearTimeout(this.saveTimeout);
                    let line = e.target.closest('.editor-line');
                    if (!line) {
                        const sel = window.getSelection();
                        if (sel.rangeCount > 0) { const node = sel.anchorNode; line = (node.nodeType === 3 ? node.parentNode : node).closest('.editor-line'); }
                    }
                    if (!line && this.currentLineId) line = document.getElementById(this.currentLineId);

                    if (line) {
                        this.currentLineId = line.id;
                        this.saveTimeout = setTimeout(() => this.triggerSave(line.id), 500);
                    }
                });

                this.ui.chatContainer.addEventListener('scroll', () => this.checkBuffers());
                const resizeObserver = new ResizeObserver(() => { requestAnimationFrame(() => this.renderMinimap()); });
                resizeObserver.observe(this.ui.chatContainer);
                document.getElementById('status-toggle').addEventListener('click', () => {
                    if (!this.ui.dashboardPanel.classList.contains('active')) return;

                    if (this.peeking) {
                        this.togglePeek();
                        if (window.state) {
                            const targetZ = window.state.landing?.targetDist || 1.25;
                            window.state.returning = {
                                active: true,
                                progress: 0,
                                baseRotation: [...window.state.sphere.rotation],
                                rotationAxis: [1, 0, 0],
                                rotationAngle: 0,
                                keepRotation: true,
                                startDist: window.state.cameraPos[2],
                                targetDist: targetZ,
                                coneStartPositions: window.state.cones.map(c => [...c.pos])
                            };
                        }
                    } else {
                        if (window.resetSphereView) window.resetSphereView(false, true);
                        if (window.state) window.state.renderPath = false;
                        this.togglePeek();
                    }
                });

                // NEW: Bind QR Action Buttons
                document.getElementById('btn-scan-mode').addEventListener('click', () => {
                    this.startScanning();
                });
                document.getElementById('btn-cancel-scan').addEventListener('click', () => {
                    // Return to QR display view
                    document.querySelectorAll('.connect-view').forEach(el => el.classList.remove('active'));
                    document.getElementById('view-qr').classList.add('active');
                    // Note: Camera stop logic is handled inside startScanning wrapper if implemented robustly, 
                    // or we rely on the library to clean up. In a production app we'd track the scanner instance.
                    // For this snippet, the next startScanning call will re-init.
                });

                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const targetId = item.getAttribute('data-target');
                        if (targetId === 'connect') {
                            if (this.peeking || this.halfPeekMode === 'connect') return;

                            if (this.halfPeekMode) {
                                this.exitHalfPeek();
                            }

                            this.halfPeekMode = 'connect';
                            this.ui.dashboardPanel.classList.add('half-peek');
                            this.ui.subNavLayer.classList.add('half-slide');

                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            document.getElementById('header-connect')?.classList.add('active');

                            this.ui.topNav.classList.add('visible');

                            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                            item.classList.add('active');
                            return;
                        }
                        if (this.halfPeekMode) {
                            this.exitHalfPeek();
                        }
                        if (this.peeking) {
                            this.togglePeek();
                            document.getElementById('sub-nav-layer')?.classList.remove('peek-slide');
                            if (window.state) {
                                const targetZ = window.state.landing?.targetDist || 1.25;
                                window.state.returning = {
                                    active: true,
                                    progress: 0,
                                    baseRotation: [...window.state.sphere.rotation],
                                    rotationAxis: [1, 0, 0],
                                    rotationAngle: 0,
                                    keepRotation: true,
                                    startDist: window.state.cameraPos[2],
                                    targetDist: targetZ,
                                    coneStartPositions: window.state.cones.map(c => [...c.pos])
                                };
                            }
                        }
                        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active')); item.classList.add('active');
                        document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                        document.getElementById('view-' + targetId)?.classList.add('active');
                        if (targetId === 'home') {
                            this.ui.dashboardPanel.classList.remove('step-down'); this.ui.dashboardPanel.classList.add('revealed');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                        } else {
                            this.ui.dashboardPanel.classList.add('step-down');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            document.getElementById('header-' + targetId)?.classList.add('active');
                        }
                    });
                });

                document.getElementById('settings-btn').addEventListener('click', () => {
                    document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                    document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                    document.getElementById('view-settings').classList.add('active');
                    this.ui.dashboardPanel.classList.add('step-down');
                    document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                    document.getElementById('header-settings').classList.add('active');
                });
                document.querySelectorAll('.sub-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const group = tab.getAttribute('data-group'), target = tab.getAttribute('data-tab');

                        if (target === 'signatures') {
                            if (window.resetSphereView) window.resetSphereView(false, true);

                            if (!this.peeking) {
                                this.peeking = true;
                                this.ui.dashboardPanel.classList.add('peek-mode');
                                document.getElementById('sub-nav-layer')?.classList.add('peek-slide');
                                this.updatePeekState(1);
                            }

                            if (window.state) {
                                window.state.renderPath = true;
                                if (window.state.interactionSignature && window.state.interactionSignature.path.length > 0) {
                                    window.state.pathPoints = [...window.state.interactionSignature.path];
                                }
                            }
                        } else {
                            if (window.state) window.state.renderPath = false;
                            if (this.peeking) {
                                this.togglePeek();
                                document.getElementById('sub-nav-layer')?.classList.remove('peek-slide');
                                if (window.state) {
                                    const targetZ = window.state.landing?.targetDist || 1.25;
                                    window.state.returning = {
                                        active: true,
                                        progress: 0,
                                        baseRotation: [...window.state.sphere.rotation],
                                        rotationAxis: [1, 0, 0],
                                        rotationAngle: 0,
                                        keepRotation: true,
                                        startDist: window.state.cameraPos[2],
                                        targetDist: targetZ,
                                        coneStartPositions: window.state.cones.map(c => [...c.pos])
                                    };
                                }
                            }
                        }

                        document.querySelectorAll(`.sub-tab[data-group="${group}"]`).forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        document.querySelector(`.content-view.active`)?.querySelectorAll('.settings-pane, .apps-pane').forEach(p => p.classList.remove('active'));
                        document.querySelector(`.content-view.active #tab-${target}`)?.classList.add('active');
                    });
                });

                document.querySelectorAll('.connect-option').forEach(option => {
                    option.addEventListener('click', () => {
                        const connectType = option.getAttribute('data-connect-type');
                        this.enterFullPeek(connectType);
                    });
                });

                this.ui.userBadge.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!this.ui.dashboardPanel.classList.contains('active')) return;

                    const currentRoomHex = window.location.hash.replace('#', '').toLowerCase();
                    const userHex = this.user.color.replace('#', '').toLowerCase();

                    const isOwnRoom = currentRoomHex === userHex;

                    if (isOwnRoom) {
                        if (this.halfPeekMode === 'profile') {
                            this.exitHalfPeek();
                            return;
                        }
                        this.showProfileHalfPeek();
                    } else {
                        window.location.hash = userHex;
                        if (window.connectAndPreview) {
                            window.connectAndPreview('#' + userHex, true);
                        }
                    }
                });

                window.addEventListener('mousemove', e => {
                    if (!this.ui.dashboardPanel.classList.contains('active') || this.ui.dashboardPanel.classList.contains('step-down') || this.ui.dashboardPanel.classList.contains('peek-mode') || this.ui.dashboardPanel.classList.contains('half-peek')) {
                        if (!this.peeking && !this.halfPeekMode) this.ui.dashboardPanel.style.transform = ''; return;
                    }

                    const sliverHeight = 10;
                    const showheight = 18;
                    const hintZoneEnd = 25;

                    if (e.clientY <= showheight) {
                        this.ui.dashboardPanel.classList.add('revealed');
                        this.ui.topNav.classList.add('visible');
                        this.ui.dashboardPanel.style.transform = '';
                    } else if (e.clientY > sliverHeight && e.clientY <= hintZoneEnd) {
                        if (!this.ui.dashboardPanel.classList.contains('revealed')) {
                            const progress = 1 - ((e.clientY - sliverHeight) / (hintZoneEnd - sliverHeight));
                            const hintOffset = sliverHeight + (progress * 20);
                            this.ui.dashboardPanel.style.transform = `translateY(${hintOffset}px)`;
                        }
                    } else if (e.clientY > hintZoneEnd) {
                        if (!this.ui.dashboardPanel.classList.contains('revealed')) {
                            this.ui.dashboardPanel.style.transform = '';
                        }
                        if (e.clientY > 100 && this.ui.dashboardPanel.classList.contains('revealed')) {
                            this.ui.dashboardPanel.classList.remove('revealed');
                            this.ui.topNav.classList.remove('visible');
                            this.ui.dashboardPanel.style.transform = '';
                        }
                    }
                });

                let ts = 0, isDrag = false;
                window.addEventListener('touchstart', e => { ts = e.touches[0].clientY; if (this.ui.dashboardPanel.classList.contains('active') && (ts < 150 || this.peeking || this.halfPeekMode)) isDrag = true; }, { passive: true });
                window.addEventListener('touchmove', e => {
                    if (!isDrag) return;
                    const currentY = e.touches[0].clientY;
                    const delta = currentY - ts;
                    const navHeight = 90;
                    const halfPeekPos = window.innerHeight * 0.33;
                    const maxDrag = window.innerHeight - 50;
                    if (delta > 10) {
                        this.ui.topNav.classList.add('visible');
                        this.ui.dashboardPanel.classList.add('revealed');
                    } else {
                        this.ui.topNav.classList.remove('visible');
                        this.ui.dashboardPanel.classList.remove('revealed');
                    }
                    if (delta > 0 && !this.peeking && !this.halfPeekMode) {
                        this.ui.dashboardPanel.style.transform = `translateY(${delta}px)`;
                        if (delta > navHeight) {
                            const range = maxDrag - navHeight;
                            const prog = Math.min(1, (delta - navHeight) / range);
                            if (window.state && window.state.peeking) { window.state.peeking.active = true; window.state.peeking.value = prog; }
                        }
                    }

                    if (delta > 0 && this.halfPeekMode && !this.peeking) {
                        const currentPos = halfPeekPos + delta;
                        this.ui.dashboardPanel.style.transform = `translateY(calc(100% - 33vh + ${delta}px))`;
                    }

                    if (delta < 0 && this.halfPeekMode && !this.peeking) {
                        this.ui.dashboardPanel.style.transform = `translateY(calc(100% - 33vh + ${delta}px))`;
                    }

                    if (delta < 0 && this.peeking) {
                        const realY = maxDrag + delta;
                        this.ui.dashboardPanel.style.transform = `translateY(${realY}px)`;
                        const range = maxDrag - navHeight;
                        const prog = Math.max(0, (realY - navHeight) / range);
                        if (window.state && window.state.peeking) { window.state.peeking.active = true; window.state.peeking.value = prog; }
                    }
                }, { passive: true });
                window.addEventListener('touchend', e => {
                    if (!isDrag) return; isDrag = false; this.ui.dashboardPanel.style.transform = '';
                    const endY = e.changedTouches[0].clientY;
                    const halfPeekThreshold = window.innerHeight * 0.5;

                    if (this.peeking && endY < window.innerHeight * 0.5) {
                        this.peeking = false;
                        this.ui.dashboardPanel.classList.remove('peek-mode');
                        this.updatePeekState(0);
                    }
                    else if (this.halfPeekMode) {
                        if (endY > window.innerHeight * 0.7) {
                            this.enterFullPeek();
                        } else if (endY < window.innerHeight * 0.25) {
                            this.exitHalfPeek();
                        }
                    }
                    else if (!this.peeking && !this.halfPeekMode) {
                        if (endY > window.innerHeight * 0.5) {
                            this.peeking = true;
                            this.ui.dashboardPanel.classList.add('peek-mode');
                            this.updatePeekState(1);
                        } else if (endY > window.innerHeight * 0.25) {
                            this.halfPeekMode = 'connect';
                            this.ui.dashboardPanel.classList.add('half-peek');
                            this.ui.subNavLayer.classList.add('half-slide');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            document.getElementById('header-connect')?.classList.add('active');
                            this.ui.topNav.classList.add('visible');
                            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                            document.querySelector('.nav-item[data-target="connect"]')?.classList.add('active');
                        }
                    }
                });

                document.addEventListener('selectionchange', () => {
                    const s = window.getSelection(); if (!s.rangeCount) return;
                    const line = (s.anchorNode.nodeType === 3 ? s.anchorNode.parentNode : s.anchorNode).closest('.editor-line');
                    if (line && line.id) {
                        this.currentLineId = line.id; document.querySelectorAll('.my-line').forEach(e => e.classList.remove('my-line')); line.classList.add('my-line');
                        this.ui.tools.classList.toggle('visible', s.toString().length > 0);
                        if (this.mesh) this.mesh.broadcastLock({ lineId: line.id, userColor: this.user.color });
                    }
                });

                document.getElementById('display').addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace') {
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const anchor = sel.anchorNode;
                            const currentLine = (anchor.nodeType === 3 ? anchor.parentNode : anchor).closest('.editor-line');
                            if (currentLine) {
                                const isAtStart = range.collapsed && range.startOffset === 0 &&
                                    (anchor === currentLine || anchor === currentLine.firstChild);
                                if (isAtStart) {
                                    const prevLine = currentLine.previousElementSibling;
                                    if (prevLine && prevLine.isContentEditable === false) {
                                        e.preventDefault();
                                        return;
                                    }
                                }
                            }
                        }
                    }

                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const br = document.createElement('br');
                            range.deleteContents();
                            range.insertNode(br);
                            range.setStartAfter(br);
                            range.setEndAfter(br);
                            let next = br.nextSibling;
                            if (next && next.nodeType === 3 && next.length === 0) {
                                next = next.nextSibling;
                            }
                            if (!next) {
                                br.parentNode.appendChild(document.createElement('br'));
                            }
                            sel.removeAllRanges();
                            sel.addRange(range);
                            e.target.dispatchEvent(new Event('input', { bubbles: true }));
                            const anchor = sel.anchorNode;
                            const element = anchor.nodeType === 1 ? anchor : anchor.parentElement;
                            if (element) {
                                element.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                            }
                        }
                    }
                });
                ['bold', 'italic'].forEach(c => document.getElementById('btn-' + c).onclick = () => document.execCommand(c));
                document.getElementById('btn-link').onclick = () => { const u = prompt("URL:"); if (u) document.execCommand('createLink', false, u); };
            }

            updateStatus(isError = false) {
                if (!this.mesh) return;
                const discoveredPeers = this.mesh.getDiscoveredPeers()?.size || 0;
                const connectedPeers = Object.values(this.mesh.getPeers()).filter(p => p.dc?.readyState === 'open').length;
                const cleanHex = this.roomId.replace('color-', '').toLowerCase();
                const userHex = this.user.color.replace('#', '').toLowerCase();
                const isFounder = cleanHex === userHex;

                if (isError && connectedPeers === 0) {
                    this.ui.roomStatus.textContent = "TURN SERVER REQUIRED (NAT BLOCKED)";
                    this.ui.roomStatus.style.color = "red";
                    this.ui.peerCount.innerText = "Connection Failed";
                    this.ui.dot.classList.remove('on');
                    return;
                }

                if (discoveredPeers > 0) {
                    // Update UI immediately for discovery before mining completes
                    if (!this.user.proofToken && !isFounder) {
                        this.startMining();
                        this.ui.roomStatus.textContent = `${discoveredPeers} PEER${discoveredPeers > 1 ? 'S' : ''} ONLINE`;
                        this.ui.roomStatus.style.color = "";
                        this.ui.peerCount.innerText = "Generating Proof...";
                        this.ui.loginBtn.innerHTML = "<span style='font-size:0.7rem'>VERIFYING...</span>";
                        this.ui.loginBtn.classList.add('hidden');
                        this.ui.dot.classList.remove('on');
                    } else {
                        // Mining is complete or user is founder
                        this.ui.loginBtn.innerHTML = "<span>JOIN</span>";
                        if (!this.ui.dashboardPanel.classList.contains('active')) {
                            this.ui.loginBtn.classList.remove('hidden');
                        }
                        this.ui.roomStatus.textContent = `${discoveredPeers} PEER${discoveredPeers > 1 ? 'S' : ''} ONLINE`;
                        this.ui.roomStatus.style.color = "";
                        this.ui.peerCount.innerText = connectedPeers > 0 ? `${connectedPeers} connected` : `Ready to join...`;
                        this.ui.dot.classList.add('on');
                    }
                } else {
                    // Update UI for 0 peers
                    this.ui.peerCount.innerText = "Offline";
                    this.ui.loginBtn.innerHTML = "<span>LOGIN</span>";

                    if (!this.ui.dashboardPanel.classList.contains('active')) {
                        this.ui.loginBtn.classList.remove('hidden');
                    } else {
                        this.ui.loginBtn.classList.add('hidden');
                    }
                    this.ui.dot.classList.remove('on');
                }
            }

            togglePeek() {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                this.peeking = !this.peeking;
                this.ui.dashboardPanel.classList.toggle('peek-mode', this.peeking);
                this.updatePeekState(this.peeking ? 1 : 0);
                document.getElementById('connect-content-layer')?.classList.remove('visible');
            }
            updatePeekState(val) { if (window.state?.peeking) { window.state.peeking.active = val > 0; window.state.peeking.value = val; } }

            exitHalfPeek() {
                if (!this.halfPeekMode) return;
                this.halfPeekMode = null;
                this.ui.dashboardPanel.classList.remove('half-peek');
                this.ui.subNavLayer.classList.remove('half-slide');
                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                document.getElementById('connect-content-layer')?.classList.remove('visible');
            }

            enterFullPeek(connectType = null) {
                this.ui.dashboardPanel.classList.remove('half-peek');
                this.ui.subNavLayer.classList.remove('half-slide');
                this.halfPeekMode = null;

                if (window.state) window.state.renderPath = false;

                this.peeking = true;
                this.ui.dashboardPanel.classList.add('peek-mode');

                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));

                const contentLayer = document.getElementById('connect-content-layer');
                if (contentLayer) {
                    contentLayer.querySelectorAll('.connect-view').forEach(el => el.classList.remove('active'));

                    if (connectType === 'qr') {
                        contentLayer.classList.add('visible');
                        document.getElementById('view-qr')?.classList.add('active');

                        // NEW: Generate QR Code for Host Mode
                        const qrContainer = document.getElementById('qr-display-container');
                        qrContainer.innerHTML = ''; // Clear previous

                        // 1. Generate VIP Secret
                        const secret = Math.random().toString(36).substring(2, 8);

                        // 2. Register Secret with Mesh
                        if (this.mesh) this.mesh.setExpectedSecret(secret);

                        // 3. Create Payload (Room Hex + Secret)
                        const roomHex = this.user.color.replace('#', '');
                        const payload = JSON.stringify({ h: roomHex, s: secret });

                        // 4. Render QR
                        new QRCode(qrContainer, {
                            text: payload,
                            width: 250,
                            height: 250,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.L
                        });

                    } else {
                        contentLayer.classList.remove('visible');
                    }
                }

                if (connectType) {
                    this.selectedConnectType = connectType;
                }
            }

            // NEW: Scan Logic (Guest Mode)
            startScanning() {
                // Switch to scanner view
                document.querySelectorAll('.connect-view').forEach(el => el.classList.remove('active'));
                document.getElementById('view-scanner').classList.add('active');

                const html5QrCode = new Html5Qrcode("qr-reader");

                html5QrCode.start(
                    { facingMode: "environment" },
                    { fps: 10, qrbox: { width: 250, height: 250 } },
                    (decodedText, decodedResult) => {
                        html5QrCode.stop().then(() => {
                            this.handleScannedData(decodedText);
                        }).catch(err => console.error("Stop failed", err));
                    },
                    (errorMessage) => {
                        // ignore parse errors
                    }
                ).catch(err => {
                    console.error("Camera failed", err);
                    alert("Camera access required to scan.");
                });
            }

            handleScannedData(jsonString) {
                try {
                    const data = JSON.parse(jsonString);
                    // Expect format: { h: "hexcolor", s: "secret" }
                    if (data.h && data.s) {
                        console.log("QR Scan Success:", data);

                        // 1. Store ticket for the upcoming connection
                        this.pendingVipTicket = data.s;

                        // 2. Hide scanner UI
                        this.togglePeek(); // Close the peek panel

                        // 3. Connect to the room
                        this.connectAndPreview('#' + data.h, true);
                    }
                } catch (e) {
                    alert("Invalid QR Code Format");
                }
            }

            showProfileHalfPeek() {
                if (this.peeking) {
                    this.togglePeek();
                }
                if (this.halfPeekMode) {
                    this.exitHalfPeek();
                }

                this.halfPeekMode = 'profile';
                this.ui.dashboardPanel.classList.add('half-peek');
                this.ui.subNavLayer.classList.add('half-slide');

                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                document.getElementById('header-profile')?.classList.add('active');

                const profileHex = document.getElementById('profile-hex');
                if (profileHex) {
                    profileHex.textContent = this.user.color.toUpperCase();
                    const hex = this.user.color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16) / 255;
                    const g = parseInt(hex.substr(2, 2), 16) / 255;
                    const b = parseInt(hex.substr(4, 2), 16) / 255;
                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                    profileHex.style.color = luminance > 0.5 ? 'black' : 'white';
                }

                this.ui.topNav.classList.add('visible');
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            }

            logout() {
                if (window.resetSphereView) window.resetSphereView();
                this.ui.dashboardPanel.classList.remove('active', 'revealed', 'step-down', 'peek-mode', 'half-peek'); this.ui.dashboardPanel.style.transform = '';
                this.peeking = false; this.halfPeekMode = null; this.updatePeekState(0);
                this.ui.loginCard.classList.remove('visible'); this.ui.topNav.classList.remove('visible');
                this.ui.hoverTrigger.style.display = 'none'; this.ui.loginBtn.classList.remove('hidden');
                document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
                if (this.mesh) { this.mesh.leave(); this.mesh = null; }
                this.ui.display.innerHTML = ''; this.ui.minimap.innerHTML = ''; this.activeLocks = {};

                document.getElementById('connect-content-layer')?.classList.remove('visible');

                document.getElementById('sub-nav-layer')?.classList.remove('peek-slide', 'half-slide');
                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelector('.nav-item[data-target="home"]')?.classList.add('active');
                document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                document.getElementById('view-home')?.classList.add('active');

                if (window.updateVisitedFromDB) window.updateVisitedFromDB();
                this.minedForSession = false;
            }

            renderInitialState(data, centerIndex) {
                let html = ''; const roomHex = this.roomId.replace('color-', '');
                for (let i = centerIndex - 50; i <= centerIndex + 50; i++) html += this.reconstructLine(roomHex + i, data[i]?.content, data[i]?.owner);
                this.ui.display.innerHTML = html; this.focusLine(centerIndex);
            }

            focusLine(index) {
                requestAnimationFrame(() => {
                    const domId = this.roomId.replace('color-', '') + index;
                    const el = document.getElementById(domId);
                    if (el) {
                        el.scrollIntoView({ block: 'center' });
                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(el);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        this.ui.display.focus();
                        this.currentLineId = domId;

                        this.checkBuffers();
                    }
                });
            }

            checkBuffers() {
                if (this.bufferCheckPending) return;
                this.bufferCheckPending = true;

                requestAnimationFrame(async () => {
                    const c = this.ui.chatContainer;
                    const { scrollTop: st, scrollHeight: sh, clientHeight: ch } = c;
                    const children = this.ui.display.children;
                    if (children.length === 0) { this.bufferCheckPending = false; return; }

                    const firstMeta = this.parseId(children[0].id);
                    const lastMeta = this.parseId(children[children.length - 1].id);
                    if (!firstMeta || !lastMeta) { this.bufferCheckPending = false; return; }

                    const firstIndex = firstMeta.index;
                    const lastIndex = lastMeta.index;
                    const roomHex = this.roomId.replace('color-', '');

                    const keysToRequest = [];

                    if (st < 100) {
                        const oldHeight = sh;
                        const start = firstIndex - 10;
                        const end = firstIndex - 1;

                        let html = '';
                        for (let i = start; i <= end; i++) {
                            html += this.reconstructLine(roomHex + i, null, null);
                            keysToRequest.push(roomHex + i);
                        }

                        this.ui.display.insertAdjacentHTML('afterbegin', html);
                        if (c.scrollHeight > 0) c.scrollTop = st + (c.scrollHeight - oldHeight);
                    }

                    if (sh - st - ch < 100) {
                        const start = lastIndex + 1;
                        const end = lastIndex + 10;

                        let html = '';
                        for (let i = start; i <= end; i++) {
                            html += this.reconstructLine(roomHex + i, null, null);
                            keysToRequest.push(roomHex + i);
                        }

                        this.ui.display.insertAdjacentHTML('beforeend', html);
                    }

                    if (children.length > 250) {
                        if (st > sh / 2) {
                            for (let i = 0; i < 50; i++) children[0].remove();
                        } else {
                            for (let i = 0; i < 50; i++) children[children.length - 1].remove();
                        }
                    }

                    if (this.mesh && keysToRequest.length > 0) {
                        this.mesh.requestSync(keysToRequest);
                    }

                    this.bufferCheckPending = false;
                });
            }

            sanitize(str) { return DOMPurify.sanitize(str, { ALLOWED_TAGS: ['b', 'i', 'u', 'a', 'br', 'div', 'span'], ALLOWED_ATTR: ['href', 'style', 'class', 'target'] }); }

            reapplyVisualLocks() {
                document.querySelectorAll('.locked-line').forEach(el => {
                    el.classList.remove('locked-line');
                    el.style.removeProperty('--lock-color');
                    el.removeAttribute('data-lock-owner');
                });

                const now = Date.now();
                const hexRegex = /^#[0-9a-fA-F]{6}$/i;

                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000) continue;

                    if (!lock.color || !hexRegex.test(lock.color)) continue;

                    const el = document.getElementById(lock.lineId);
                    if (el) {
                        el.classList.add('locked-line');
                        el.style.setProperty('--lock-color', lock.color);
                        el.contentEditable = "false";
                        el.setAttribute('data-lock-owner', lock.color);
                    }
                }
                this.renderMinimap();
            }
            renderMinimap() {
                const h = this.ui.chatContainer.scrollHeight, now = Date.now();
                this.ui.minimap.innerHTML = Object.entries(this.activeLocks).filter(([pid, lock]) => now - lock.ts <= 60000).map(([_, lock]) => {
                    const el = document.getElementById(lock.lineId);
                    return el ? `<div class="scroll-dot" style="background:${lock.color};top:${(el.offsetTop / h) * 100}%"></div>` : '';
                }).join('');
            }
            setupGlobalExposure() { window.connectAndPreview = (h, u) => this.connectAndPreview(h, u); window.enterRoomUI = () => this.enterRoomUI(); }
            async runSequencedScan() { for (const rId of this.visitedRooms) { try { const r = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69' }, rId); await new Promise(res => setTimeout(() => { window.postMessage({ type: 'handle-ready', hex: rId.replace('color-', '#'), count: Object.keys(r.getPeers()).length }, '*'); r.leave(); res(); }, 1000)); } catch (e) { } } }
        }

        // 1. The Worker Logic
        const WORKER_SOURCE = `
const DEFAULT_PASS = "FFFFFF";
let _keyPair = null;
let _aesKey = null;
let _peerKeys = {};
let _encryptedBlob = null;
let _locked = true;
let _currentPassword = null;

const DIFFICULTY_PREFIX = "0000"; 

async function computeProof(roomHex) {
    const encoder = new TextEncoder();
    let nonce = 0;
    while (true) {
        nonce++;
        const hourStamp = Math.floor(Date.now() / 3600000); 
        const attempt = roomHex + hourStamp + nonce;
        const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(attempt));
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        if (hashHex.startsWith(DIFFICULTY_PREFIX)) {
            return hourStamp + "_" + nonce;
        }
        if (nonce % 1000 === 0) await new Promise(r => setTimeout(r, 0));
    }
}

async function isValidPeer(peerId, roomHex) {
    if (!peerId || !peerId.includes('_')) return false;
    const [hourStamp, nonce] = peerId.split('_');
    const currentHour = Math.floor(Date.now() / 3600000);
    if (Math.abs(currentHour - parseInt(hourStamp)) > 1) return false;

    const encoder = new TextEncoder();
    const attempt = roomHex + hourStamp + nonce;
    const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(attempt));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex.startsWith(DIFFICULTY_PREFIX);
}

function openKeyDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open("sys_security", 2);
        req.onupgradeneeded = e => { if (!e.target.result.objectStoreNames.contains("keys")) e.target.result.createObjectStore("keys"); };
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e);
    });
}

function openColorDB(hex = null) {
    return new Promise((res, rej) => {
        const req = indexedDB.open('color');
        req.onupgradeneeded = () => { };
        req.onerror = e => rej(e);
        req.onsuccess = e => {
            const db = e.target.result;
            if (!db) { rej("DB failed to open"); return; }
            if (hex && !db.objectStoreNames.contains(hex)) {
                const v = db.version + 1;
                db.close();
                const upg = indexedDB.open('color', v);
                upg.onupgradeneeded = evt => {
                    const d = evt.target.result;
                    if (!d.objectStoreNames.contains(hex)) d.createObjectStore(hex).createIndex('owner', 'owner', { unique: false });
                };
                upg.onerror = evt => rej(evt);
                upg.onsuccess = evt => res(evt.target.result);
            } else {
                res(db);
            }
        };
    });
}

async function deriveKeyFromPass(password, salt) {
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
    return crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
}

async function loadKeysToMemory(sigJWK, aesJWK, pubJWK) {
    _aesKey = await crypto.subtle.importKey("jwk", aesJWK, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
    _keyPair = {
        privateKey: await crypto.subtle.importKey("jwk", sigJWK, { name: "ECDSA", namedCurve: "P-521" }, false, ["sign"]),
        publicKey: await crypto.subtle.importKey("jwk", pubJWK, { name: "ECDSA", namedCurve: "P-521" }, true, ["verify"])
    };
    _locked = false;
}

async function saveWrappedKeys(password, keysJwkObj, pubKeyJwk) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const wrapKey = await deriveKeyFromPass(password, salt);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encryptedData = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, wrapKey, new TextEncoder().encode(JSON.stringify(keysJwkObj)));
    _encryptedBlob = { salt, iv, data: encryptedData, pubKey: pubKeyJwk };
    const db = await openKeyDB();
    const tx = db.transaction(["keys"], "readwrite");
    tx.objectStore("keys").put(_encryptedBlob, "wrapped_keys");
    await new Promise(r => tx.oncomplete = r);
    db.close(); 
}

async function encrypt(data) {
    if (_locked) throw new Error("Locked");
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const c = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, _aesKey, new TextEncoder().encode(data));
    const p = new Uint8Array(iv.length + c.byteLength);
    p.set(iv, 0); p.set(new Uint8Array(c), 12);
    return p.buffer;
}

async function decrypt(buffer) {
    if (_locked) return "ðŸ”’";
    try {
        const p2 = new Uint8Array(buffer);
        const iv2 = p2.slice(0, 12);
        const c2 = p2.slice(12);
        const d = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv2 }, _aesKey, c2);
        return new TextDecoder().decode(d);
    } catch(e) { return "--- CORRUPT ---"; }
}

async function sign(data) {
     if (_locked) throw new Error("Locked");
     const buf = await crypto.subtle.sign({ name: "ECDSA", hash: "SHA-512" }, _keyPair.privateKey, new TextEncoder().encode(data));
     return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

async function verify(key, content, signature) {
    return await crypto.subtle.verify({ name: "ECDSA", hash: "SHA-512" }, key, Uint8Array.from(atob(signature), c => c.charCodeAt(0)), new TextEncoder().encode(content));
}

async function init() {
    const db = await openKeyDB();
    const tx = db.transaction(["keys"], "readwrite");
    const req = tx.objectStore("keys").get("wrapped_keys");
    await new Promise(r => tx.oncomplete = r);
    const result = req.result;
    db.close(); 

    if (result) {
        _encryptedBlob = result;
        try { 
            await unlock(DEFAULT_PASS); 
            return "DEFAULT"; 
        } catch(e) { 
            return "LOCKED"; 
        }
    } else {
        await generate(); 
        return "DEFAULT";
    }
}

async function generate() {
    const kSig = await crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-521" }, true, ["sign", "verify"]);
    const kAes = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
    const sigJWK = await crypto.subtle.exportKey("jwk", kSig.privateKey);
    const pubJWK = await crypto.subtle.exportKey("jwk", kSig.publicKey);
    const aesJWK = await crypto.subtle.exportKey("jwk", kAes);
    await saveWrappedKeys(DEFAULT_PASS, { aes: aesJWK, sig: sigJWK }, pubJWK);
    _currentPassword = DEFAULT_PASS;
    await loadKeysToMemory(sigJWK, aesJWK, pubJWK);
}

async function unlock(password) {
    if (!_encryptedBlob) throw new Error("No keys");
    const wrapKey = await deriveKeyFromPass(password, _encryptedBlob.salt);
    try {
        const decryptedBytes = await crypto.subtle.decrypt({ name: "AES-GCM", iv: _encryptedBlob.iv }, wrapKey, _encryptedBlob.data);
        const keysObj = JSON.parse(new TextDecoder().decode(decryptedBytes));
        await loadKeysToMemory(keysObj.sig, keysObj.aes, _encryptedBlob.pubKey);
        _currentPassword = password;
    } catch(e) { throw new Error("Wrong Password"); }
}

async function updatePass(newPassword) {
     if (_locked) throw new Error("Locked");
     const oldWrapKey = await deriveKeyFromPass(_currentPassword, _encryptedBlob.salt);
     const bytes = await crypto.subtle.decrypt({ name: "AES-GCM", iv: _encryptedBlob.iv }, oldWrapKey, _encryptedBlob.data);
     const keysObj = JSON.parse(new TextDecoder().decode(bytes));
     await saveWrappedKeys(newPassword, keysObj, _encryptedBlob.pubKey);
     _currentPassword = newPassword;
}

async function db_write_local({ roomHex, index, content, owner }) {
    if (_locked) throw new Error("Locked");
    const ts = Date.now();
    const safeContent = content || "";
    const payload = index + ":" + ts + ":" + owner + ":" + safeContent;
    const signature = await sign(payload);
    const encrypted = await encrypt(content);
    const db = await openColorDB(roomHex);
     return new Promise((resolve, reject) => {
        const tx = db.transaction([roomHex], 'readwrite');
        const store = tx.objectStore(roomHex);
        const record = { 
            content: encrypted, 
            owner: owner, 
            updated: ts, 
            signature: signature 
        };
        if (!content || content.trim() === '') store.delete(parseInt(index));
        else store.put(record, parseInt(index));
        tx.oncomplete = () => { 
            db.close(); 
            resolve({ index, content, owner, signature, updated: ts }); 
        };
        tx.onerror = () => { db.close(); reject(tx.error); };
    });
}

async function db_verify_remote_batch({ fragments, roomHex, peerId }) {
    if (!_peerKeys[peerId]) return {};
    const db = await openColorDB(roomHex);
    const tx = db.transaction([roomHex], 'readwrite');
    const store = tx.objectStore(roomHex);
    const verified = {};
    for (const idxString of Object.keys(fragments)) {
        const index = parseInt(idxString);
        const item = fragments[idxString];
        const safeContent = item.content || "";
        const payload = index + ":" + item.updated + ":" + item.owner + ":" + safeContent;
        try {
            const isValid = await verify(_peerKeys[peerId], payload, item.signature);
            if (!isValid) continue;
            const existing = await new Promise(r => {
                const req = store.get(index);
                req.onsuccess = () => r(req.result);
                req.onerror = () => r(null);
            });
            if (existing && existing.updated >= item.updated) continue;
            if (existing && existing.owner && existing.owner !== item.owner) continue;

            if (item.content && item.content.trim() !== '') {
                const enc = await encrypt(item.content);
                store.put({ 
                    content: enc, 
                    owner: item.owner, 
                    updated: item.updated, 
                    signature: item.signature 
                }, index);
            } else {
                store.delete(index);
            }
            verified[index] = item;
        } catch(e) { }
    }
    await new Promise(r => {
        tx.oncomplete = () => { db.close(); r(); };
        tx.onerror = () => { db.close(); r(); };
    });
    return verified;
}

async function db_read_range({ roomHex, min, max }) {
    const db = await openColorDB(roomHex);
    if (!db.objectStoreNames.contains(roomHex)) { db.close(); return {}; }
    const raw = {};
    await new Promise(r => {
        const req = db.transaction([roomHex], 'readonly').objectStore(roomHex).openCursor(IDBKeyRange.bound(min, max));
        req.onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) { raw[cursor.key] = cursor.value; cursor.continue(); } else r();
        }
        req.onerror = () => r();
    });
    db.close();
    const result = {};
    for (const k in raw) {
        const row = raw[k];
        if (row.content instanceof ArrayBuffer) row.content = await decrypt(row.content);
        result[k] = row;
    }
    return result;
}

async function db_read_specific({ roomHex, keys }) {
     const db = await openColorDB(roomHex);
     if (!db.objectStoreNames.contains(roomHex)) { db.close(); return {}; }
     const tx = db.transaction([roomHex], 'readonly');
     const store = tx.objectStore(roomHex);
     const results = {};
     await Promise.all(keys.map(k => new Promise(resolve => {
         const idx = parseInt(k.replace(roomHex, ''), 10);
         if (isNaN(idx)) { resolve(); return; }
         const req = store.get(idx);
         req.onsuccess = async e => {
             const row = e.target.result;
             if (row) {
                if (row.content instanceof ArrayBuffer) row.content = await decrypt(row.content);
                results[idx] = row;
             }
             resolve();
         };
         req.onerror = () => resolve();
     })));
     db.close();
     return results;
}

self.onmessage = async (e) => {
    const { id, action, data } = e.data;
    try {
        let res;
        switch(action) {
            case 'init': res = await init(); break;
            case 'unlock': await unlock(data); res = "SUCCESS"; break;
            case 'generate': await generate(); res = "DEFAULT"; break;
            case 'updatePassword': await updatePass(data); res = "SUCCESS"; break;
            case 'getPublicKey': res = _locked ? null : await crypto.subtle.exportKey("jwk", _keyPair.publicKey); break;
            case 'storePeerKey': 
                try {
                    _peerKeys[data.peerId] = await crypto.subtle.importKey("jwk", data.jwk, { name: "ECDSA", namedCurve: "P-521" }, true, ["verify"]);
                    res = true;
                } catch(e) { res = false; }
                break;
            case 'db_init': 
                const dbInit = await openColorDB(data.roomHex); 
                dbInit.close(); 
                res = true; 
                break;
            case 'db_write_local': res = await db_write_local(data); break;
            case 'db_verify_remote': res = await db_verify_remote_batch(data); break;
            case 'db_read_range': res = await db_read_range(data); break;
            case 'db_read_specific': res = await db_read_specific(data); break;
            case 'db_has_room':
                 const dbHas = await openColorDB();
                 res = dbHas.objectStoreNames.contains(data.roomHex);
                 dbHas.close();
                 break;
            case 'db_get_all_rooms':
                 const dbAll = await openColorDB();
                 res = Array.from(dbAll.objectStoreNames).map(hex => ({ hex }));
                 dbAll.close();
                 break;
            case 'db_read_cursor': 
                 const dbCursor = await openColorDB(data.roomHex);
                 res = await new Promise(r => {
                     const tx = dbCursor.transaction([data.roomHex], 'readonly');
                     const req = tx.objectStore(data.roomHex).get("cursor");
                     req.onsuccess = () => r(req.result || 0);
                     req.onerror = () => r(0);
                 });
                 dbCursor.close();
                 break;
             case 'db_wipe':
                 const dbs = await indexedDB.databases();
                 for (const d of dbs) await indexedDB.deleteDatabase(d.name);
                 res = true;
                 break;
             case 'saveSignature':
                if (_locked) break;
                const sdb = await openColorDB(data.roomHex);
                const stx = sdb.transaction([data.roomHex], 'readwrite');
                stx.objectStore(data.roomHex).put({ ...data.signature, created: Date.now() }, 'signature');
                stx.oncomplete = () => sdb.close();
                stx.onerror = () => sdb.close();
                res = true;
                break;
            case 'sign': res = await sign(data); break;
            case 'encrypt': res = await encrypt(data); break;
            case 'decrypt': res = await decrypt(data); break;
            case 'generate_token': res = await computeProof(data.roomHex); break;
            case 'validate_peer': res = await isValidPeer(data.peerId, data.roomHex); break;
        }
        self.postMessage({ id, result: res });
    } catch(err) {
        self.postMessage({ id, error: err.message });
    }
};
`;

        // 2. The Class that your App uses
        class SecureIdentity {
            constructor() {
                const blob = new Blob([WORKER_SOURCE], { type: "text/javascript" });
                this.worker = new Worker(window.URL.createObjectURL(blob));
                this.callbacks = {};
                this.ready = false;
                this.locked = true;
                this.DEFAULT_PASS = "FFFFFF";

                this.worker.onmessage = (e) => {
                    const { id, result, error } = e.data;
                    if (this.callbacks[id]) {
                        if (error) this.callbacks[id].reject(new Error(error));
                        else this.callbacks[id].resolve(result);
                        delete this.callbacks[id];
                    }
                };
            }

            _call(action, data, transfer = []) {
                return new Promise((resolve, reject) => {
                    const id = Math.random().toString(36).slice(2);
                    this.callbacks[id] = { resolve, reject };
                    this.worker.postMessage({ id, action, data }, transfer);
                });
            }

            updateUI(status) {
                const el = document.getElementById('security-status'), btn = document.getElementById('btn-security-apply'), input = document.getElementById('master-pass');
                if (status === "LOCKED") {
                    this.locked = true; this.ready = true;
                    el.innerHTML = "STATUS: <b style='color:red'>LOCKED</b>"; btn.innerText = "UNLOCK"; input.value = "";
                }
                else if (status === "DEFAULT") {
                    this.locked = false; this.ready = true;
                    el.innerHTML = "STATUS: <b style='color:orange'>UNSECURED (DEFAULT)</b>"; btn.innerText = "UPDATE PASSWORD"; input.value = this.DEFAULT_PASS;
                }
                else {
                    this.locked = false; this.ready = true;
                    el.innerHTML = "STATUS: <b style='color:#00e676'>SECURED</b>"; btn.innerText = "UPDATE PASSWORD"; input.value = ""; input.placeholder = "Type new password...";
                }
            }

            async init() {
                try {
                    const status = await this._call('init');
                    this.updateUI(status);
                } catch (e) { console.error(e); }
            }

            async unlockWithPassword(password, silent = false) {
                try {
                    const res = await this._call('unlock', password);
                    if (res === "SUCCESS") {
                        this.updateUI(password === this.DEFAULT_PASS ? "DEFAULT" : "SECURE");
                        if (window.app) window.app.connectAndPreview(window.location.hash || '#ffffff');
                        return true;
                    }
                    return false;
                } catch (e) {
                    if (!silent) alert("Wrong Password");
                    return false;
                }
            }

            async updatePassword(newPassword) {
                if (this.locked || !newPassword) return;
                try {
                    await this._call('updatePassword', newPassword);
                    this.updateUI("SECURE");
                } catch (e) { alert("Update failed"); }
            }

            async getPublicKeyData() {
                if (!this.ready || this.locked) return null;
                return this._call('getPublicKey');
            }

            async storePeerKey(peerId, jwk) {
                return this._call('storePeerKey', { peerId, jwk });
            }

            async sign(text) {
                if (!this.ready || this.locked) return null;
                return this._call('sign', text);
            }

            async verify(peerId, content, signature) {
                return this._call('verify', { peerId, content, signature });
            }

            async encryptContent(text) {
                if (!this.ready || this.locked) throw new Error("Keystore Locked");
                return this._call('encrypt', text);
            }

            async decryptContent(packedBuffer) {
                if (!this.ready || this.locked) return "ðŸ”’ LOCKED";
                try {
                    return await this._call('decrypt', packedBuffer);
                } catch (e) { return "--- CORRUPT ---"; }
            }
        }

        window.app = new EditorApp();
        document.getElementById('btn-security-apply').addEventListener('click', async () => {
            const pass = document.getElementById('master-pass').value;
            if (window.app.identity.locked) await window.app.identity.unlockWithPassword(pass);
            else if (confirm("Update master password?")) await window.app.identity.updatePassword(pass);
        });
    </script>
    <script type="module">
        let storageScope = window.localStorage; document.getElementById('login-btn').addEventListener('click', async () => {
            const btnText = document.getElementById('login-btn').innerText;
            if (btnText === 'LOGIN') {
                try { storageScope.setItem("lastSphereColor", document.getElementById('color-hex').innerText); } catch (e) { }
                if (window.app && window.app.mesh) window.app.mesh.enableSync();
            } else if (btnText === 'JOIN') {
                if (window.app && window.app.mesh) window.app.mesh.enableSync();
                document.getElementById('room-status').innerText = "CONNECTED";
                if (window.app && window.app.mesh) {
                    const peers = Object.values(window.app.mesh.getPeers()).filter(p => p.dc?.readyState === 'open').length;
                    document.getElementById('peer-count').innerText = peers > 0 ? `${peers} connected` : `Syncing...`;
                }
            }
            if (window.enterRoomUI) window.enterRoomUI();
            document.getElementById('login-btn').classList.add('hidden');
        });
        const Vec3 = { create: () => [0, 0, 0], add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s], dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2], cross: (a, b) => [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]], len: v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]), normalize: v => { const l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); return l > 0 ? [v[0] / l, v[1] / l, v[2] / l] : [0, 0, 0] }, dist: (a, b) => Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) };
        const Mat4 = { perspective: (f, a, n, fr) => { const nf = 1 / (n - fr), f_t = 1 / Math.tan(f / 2); return [f_t / a, 0, 0, 0, 0, f_t, 0, 0, 0, 0, (fr + n) * nf, -1, 0, 0, 2 * fr * n * nf, 0] }, lookAt: (e, c, u) => { const z = Vec3.normalize(Vec3.sub(e, c)), x = Vec3.normalize(Vec3.cross(u, z)), y = Vec3.cross(z, x); return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -Vec3.dot(x, e), -Vec3.dot(y, e), -Vec3.dot(z, e), 1] }, multiply: (a, b) => [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]], rotationX: r => [1, 0, 0, 0, 0, Math.cos(r), Math.sin(r), 0, 0, -Math.sin(r), Math.cos(r), 0, 0, 0, 0, 1], translation: v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1], scale: v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1], rotationAxis: (a, r) => { const c = Math.cos(r), s = Math.sin(r), t = 1 - c, x = a[0], y = a[1], z = a[2]; return [t * x * x + c, t * x * y + z * s, t * x * z - y * s, 0, t * x * y - z * s, t * y * y + c, t * y * z + x * s, 0, t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0, 0, 0, 0, 1] }, identity: () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] };
        const state = { canvas: null, device: null, context: null, pipelines: { sphere: null, cone: null }, buffers: {}, bindGroups: { sphere: null, cones: [] }, cameraPos: [0, 0, 4], sphere: { rotation: Mat4.identity(), indexCount: 0 }, cones: [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }], historyHandles: [], hasRotated: false, mouse: { x: 0, y: 0, down: false }, draggedConeIndex: -1, valueScrub: { active: false, coneIndex: -1, coordIndex: 0, startY: 0 }, lastTime: 0, clickData: { startX: 0, startY: 0, startTime: 0 }, landing: { active: false, progress: 0, rotationAxis: [1, 0, 0], rotationAngle: 0, baseRotation: Mat4.identity(), coneStartPositions: [], handleStartPos: [0, 0, 0], showHandle: false, startDist: 4.0, targetDist: 1.25, shouldAutoEnter: false }, dragStart: { active: false, mouseDir: [0, 0, 1], sphereRotation: null, conePositions: [], lastTrackPos: null }, inertia: { active: false, axis: [1, 0, 0], val: 0 }, handle: { active: false, pos: [0, 0, 0], color: [1, 1, 1] }, msaaTexture: null, depthTexture: null, sampleCount: 4, presentationFormat: null, debugMode: false, uiCache: [], vpMatrix: Mat4.identity(), returning: null, uniforms: { sphere: new Float32Array(80), cone: new Float32Array(20) }, peeking: { active: false, value: 0 }, interaction: { mode: 'none', hasTouchedSphere: false }, pathPoints: [], pathStartPos: null, renderPath: false, interactionSignature: { type: 'click', path: [] } };
        window.state = state;
        function rgbToHex(r, g, b) { return '#' + [r, g, b].map(x => Math.round(Math.min(1, Math.max(0, x)) * 255).toString(16).padStart(2, '0')).join(''); }
        function hexToRgbNormalized(hex) { const bigint = parseInt(hex.replace(/^#/, '').replace(/^([a-f\d])([a-f\d])([a-f\d])$/i, '$1$1$2$2$3$3'), 16); return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255]; }
        const gradientShaderWGSL = `struct Uniforms { mvp: mat4x4<f32>, model: mat4x4<f32>, normalMatrix: mat4x4<f32>, viewPos: vec3<f32>, l1: vec3<f32>, c1: vec3<f32>, l2: vec3<f32>, c2: vec3<f32>, l3: vec3<f32>, c3: vec3<f32>, debug: f32, }; @group(0) @binding(0) var<uniform> u: Uniforms; struct VI { @location(0) p: vec3<f32>, @location(1) n: vec3<f32> }; struct VO { @builtin(position) P: vec4<f32>, @location(0) vP: vec3<f32>, @location(1) vN: vec3<f32> }; @vertex fn vs_main(i: VI) -> VO { var o: VO; o.P = u.mvp * vec4<f32>(i.p, 1.0); o.vP = (u.model * vec4<f32>(i.p, 1.0)).xyz; o.vN = (u.normalMatrix * vec4<f32>(i.n, 0.0)).xyz; return o; } fn Contrast(x: vec3<f32>) -> vec3<f32> { return x * x * (3.0 - 2.0 * x); } fn getI(lp: vec3<f32>, N: vec3<f32>, fp: vec3<f32>) -> f32 { let distSq = dot(lp - fp, lp - fp); let L = normalize(lp - fp); let wrap = max(dot(N, L) + 1.0, 0.0) / 2.0; let spread = pow(wrap, 1.25); return spread * (1.0 / (1.0 + distSq * 0.05)); } @fragment fn fs_main(i: VO) -> @location(0) vec4<f32> { let N = normalize(i.vN); let raw_d1 = getI(u.l1, N, i.vP); let raw_d2 = getI(u.l2, N, i.vP); let raw_d3 = getI(u.l3, N, i.vP); let d1 = raw_d1 * max(u.c1.r, max(u.c1.g, u.c1.b)); let d2 = raw_d2 * max(u.c2.r, max(u.c2.g, u.c2.b)); let d3 = raw_d3 * max(u.c3.r, max(u.c3.g, u.c3.b)); var l = (u.c1 * d1) + (u.c2 * d2) + (u.c3 * d3); let ep = 0.001; l = l + ((u.c1 + u.c2) * 2.0 * d1 * d2 / (d1 + d2 + ep)); l = l + ((u.c2 + u.c3) * 2.0 * d2 * d3 / (d2 + d3 + ep)); l = l + ((u.c3 + u.c1) * 2.0 * d3 * d1 / (d3 + d1 + ep)); let min_i = min(d1, min(d2, d3)); let max_i = max(d1, max(d2, d3)); let mask_base = smoothstep(0.15, 0.40, min_i); let variance = max_i - min_i; let roundness = exp(-variance * 10.0); let final_mask = mask_base * roundness; l = mix(l, vec3(1.0), final_mask); l = l * 1.2; let contrasty = Contrast(clamp(l, vec3(0.0), vec3(1.0))); return vec4<f32>(contrasty, 1.0); }`;
        const solidShaderWGSL = `struct U{mvp:mat4x4<f32>,c:vec4<f32>};@group(0) @binding(0) var<uniform> u:U;@vertex fn vs_main(@location(0) p:vec3<f32>)->@builtin(position) vec4<f32>{return u.mvp*vec4<f32>(p,1.0);}@fragment fn fs_main()->@location(0) vec4<f32>{return u.c;}`;
        const defaultCones = [{ color: [1, 0, 0], pos: [0, .98, .69], active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], active: true }];
        function findPositionFromColor(targetHex) { const t = hexToRgbNormalized(targetHex); let bd = Infinity, bp = null; for (let la = 0; la <= 30; la++) for (let lo = 0; lo <= 30; lo++) { const th = la * Math.PI / 30, ph = lo * 2 * Math.PI / 30, pos = [Math.cos(ph) * Math.sin(th), Math.cos(th), Math.sin(ph) * Math.sin(th)]; const c = getSurfaceColor(pos, pos, defaultCones), d = Math.sqrt((c[0] - t[0]) ** 2 + (c[1] - t[1]) ** 2 + (c[2] - t[2]) ** 2); if (d < bd) { bd = d; bp = pos; } if (d < 0.05) return bp; } return bp; }
        async function init() {
            if (window.self !== window.top) document.getElementById('debug-btn').style.display = 'none';
            state.canvas = document.getElementById('gpu-canvas'); if (!navigator.gpu) return alert("WebGPU not supported!"); const adapter = await navigator.gpu.requestAdapter(); state.device = await adapter.requestDevice(); state.context = state.canvas.getContext('webgpu'); state.presentationFormat = navigator.gpu.getPreferredCanvasFormat(); state.context.configure({ device: state.device, format: state.presentationFormat, alphaMode: 'premultiplied' });

            await createAssets();
            state.historyHandles = [];
            const rooms = await (new window.ColorDB()).getAllRooms();

            window.addEventListener('resize', onResize); onResize();

            state.canvas.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp); state.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e.touches[0]) }, { passive: false }); state.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e.touches[0]) }, { passive: false }); state.canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e.changedTouches[0]) }); document.getElementById('freeze-btn').addEventListener('click', toggleFreeze);
            document.getElementById('debug-btn').onclick = function () { state.debugMode = !state.debugMode; this.classList.toggle('active', state.debugMode); this.innerText = state.debugMode ? "DEBUG ON" : "DEBUG OFF"; document.getElementById('debug-panel').classList.toggle('visible', state.debugMode); };
            document.getElementById('reset-btn').onclick = async () => {
                if (confirm("Permanently wipe all local data?")) {
                    localStorage.clear();
                    const DB_NAMES = ['color', 'sys_security'];
                    for (const name of DB_NAMES) {
                        try { window.indexedDB.deleteDatabase(name); } catch (e) { }
                    }
                    window.location.href = window.location.origin + window.location.pathname;
                }
            }; state.cones.forEach((c, i) => { const el = document.getElementById(`data-${i}`); if (!el) return; el.innerHTML = `<span class="cone-title" id="title-${i}">${c.name}</span> <span style="color:#666">X</span> <span class="coord-val" id="x-${i}">0.00</span> <span style="color:#666">Y</span> <span class="coord-val" id="y-${i}">0.00</span> <span style="color:#666">Z</span> <span class="coord-val" id="z-${i}">0.00</span>`; const title = document.getElementById(`title-${i}`); title.addEventListener('click', (e) => { if (!document.body.classList.contains('light-mode')) { e.stopPropagation(); state.cones[i].active = !state.cones[i].active; } });['x', 'y', 'z'].forEach((ax, idx) => document.getElementById(`${ax}-${i}`).addEventListener('mousedown', (e) => { if (!document.body.classList.contains('light-mode')) { e.preventDefault(); e.stopPropagation(); state.valueScrub = { active: true, coneIndex: i, coordIndex: idx, startY: e.clientY }; } })); state.uiCache[i] = { title, x: document.getElementById(`x-${i}`), y: document.getElementById(`y-${i}`), z: document.getElementById(`z-${i}`), lastPos: [null, null, null], lastActive: null }; });
            setupColorTooltip(); if (window.location.hash && window.location.hash.length > 1) { const matchPos = findPositionFromColor(window.location.hash); if (matchPos) triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(window.location.hash), true); }
            requestAnimationFrame(loop);
        }
        async function createAssets() { const dev = state.device, sphereGeo = createSphere(1.0, 128, 128), coneGeo = createCone(0.1, 0.3, 64); state.buffers.sphereVertex = createBuffer(dev, sphereGeo.p, GPUBufferUsage.VERTEX); state.buffers.sphereNormal = createBuffer(dev, sphereGeo.n, GPUBufferUsage.VERTEX); state.buffers.sphereIndex = createBuffer(dev, sphereGeo.i, GPUBufferUsage.INDEX); state.sphere.indexCount = sphereGeo.i.length; state.buffers.coneVertex = createBuffer(dev, coneGeo.p, GPUBufferUsage.VERTEX); state.buffers.coneIndex = createBuffer(dev, coneGeo.i, GPUBufferUsage.INDEX); state.coneIndexCount = coneGeo.i.length; state.buffers.sphereUniform = dev.createBuffer({ size: 320, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); state.buffers.coneUniform = dev.createBuffer({ size: 65536, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); const sm = dev.createShaderModule({ code: gradientShaderWGSL }), cm = dev.createShaderModule({ code: solidShaderWGSL }); state.pipelines.sphere = dev.createRenderPipeline({ layout: 'auto', vertex: { module: sm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }, { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }] }, fragment: { module: sm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } }); state.pipelines.cone = dev.createRenderPipeline({ layout: 'auto', vertex: { module: cm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }] }, fragment: { module: cm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } }); state.bindGroups.sphere = dev.createBindGroup({ layout: state.pipelines.sphere.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.sphereUniform } }] }); state.getBindGroupForHandle = (idx) => dev.createBindGroup({ layout: state.pipelines.cone.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.coneUniform, offset: idx * 256, size: 80 } }] }); state.bindGroups.cones = [0, 1, 2, 3].map(i => state.getBindGroupForHandle(i)); }
        function createBuffer(dev, data, usage) { const buf = dev.createBuffer({ size: data.byteLength, usage: usage | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); (data instanceof Float32Array ? new Float32Array(buf.getMappedRange()) : new Uint16Array(buf.getMappedRange())).set(data); buf.unmap(); return buf; }
        function createSphere(r, latB, longB) { const p = [], n = [], idx = []; for (let la = 0; la <= latB; la++) for (let lo = 0; lo <= longB; lo++) { const th = la * Math.PI / latB, ph = lo * 2 * Math.PI / longB, x = Math.cos(ph) * Math.sin(th), y = Math.cos(th), z = Math.sin(ph) * Math.sin(th); n.push(x, y, z); p.push(r * x, r * y, r * z); } for (let la = 0; la < latB; la++) for (let lo = 0; lo < longB; lo++) { const f = (la * (longB + 1)) + lo, s = f + longB + 1; idx.push(f, f + 1, s, s, f + 1, s + 1); } return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function createCone(r, h, s) { const p = [0, h, 0], n = [0, 1, 0], idx = []; for (let i = 0; i <= s; i++) { const th = i * 2 * Math.PI / s, x = r * Math.cos(th), z = r * Math.sin(th); p.push(x, 0, z); const nv = Vec3.normalize([x, .5, z]); n.push(nv[0], nv[1], nv[2]); } p.push(0, 0, 0); n.push(0, -1, 0); const bc = p.length / 3 - 1; for (let i = 1; i <= s; i++) idx.push(0, i, i + 1, bc, i + 1, i); return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function pathToVertices(pathPoints, sphereRotation) { if (pathPoints.length < 2) return null; const WIDTH = 0.015; const PROTRUDE = 1.02; const path = pathPoints.map(p => { const wp = transformPos(p, sphereRotation); return Vec3.scale(Vec3.normalize(wp), PROTRUDE); }); const tangents = []; for (let i = 0; i < path.length; i++) { let dir; if (i === 0) { dir = Vec3.sub(path[1], path[0]); } else if (i === path.length - 1) { dir = Vec3.sub(path[i], path[i - 1]); } else { dir = Vec3.sub(path[i + 1], path[i - 1]); } const radial = Vec3.normalize(path[i]); let tangent = Vec3.cross(dir, radial); const tLen = Vec3.len(tangent); if (tLen < 0.001) { tangent = Vec3.cross(dir, [0, 1, 0]); if (Vec3.len(tangent) < 0.001) tangent = Vec3.cross(dir, [1, 0, 0]); } tangents.push(Vec3.scale(Vec3.normalize(tangent), WIDTH)); } const vertices = []; for (let i = 1; i < path.length; i++) { const p0 = path[i - 1], p1 = path[i]; const t0 = tangents[i - 1], t1 = tangents[i]; const v0p = Vec3.add(p0, t0), v0m = Vec3.sub(p0, t0); const v1p = Vec3.add(p1, t1), v1m = Vec3.sub(p1, t1); vertices.push(...v1p, ...v1m, ...v0m); vertices.push(...v1p, ...v0m, ...v0p); } return new Float32Array(vertices); }
        function onResize() { if (!state.device) return; const w = state.canvas.clientWidth; const h = state.canvas.clientHeight; state.canvas.width = w; state.canvas.height = h; if (state.msaaTexture) state.msaaTexture.destroy(); if (state.depthTexture) state.depthTexture.destroy(); state.msaaTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: state.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT }); state.depthTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: 'depth24plus', usage: GPUTextureUsage.RENDER_ATTACHMENT }); const aspect = w / h; const newZ = aspect < 1 ? 3.5 / aspect : 4; if (!state.landing.active && (!state.returning || !state.returning.active)) { state.cameraPos = [0, 0, newZ]; } if (state.returning) state.returning.targetDist = newZ; }
        function getMouseRay(x, y) { const aspect = state.canvas.width / state.canvas.height, ndcX = (x / state.canvas.width) * 2 - 1, ndcY = -(y / state.canvas.height) * 2 + 1; const dir = Vec3.normalize([ndcX * aspect * Math.tan(Math.PI / 8), ndcY * Math.tan(Math.PI / 8), -1]); return { o: state.cameraPos, d: dir }; }
        function getTargetPos(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)); return Vec3.dot(p, p) <= 1 ? Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))) : Vec3.scale(Vec3.normalize(p), 1); }
        function calculateConePosition(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)), dist = Math.sqrt(Vec3.dot(p, p)), R = 1.2; if (dist <= R) return Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(R * R - Vec3.dot(p, p)))); const axis = Vec3.cross(Vec3.normalize(r.o), r.d); return Vec3.scale(transformPos(Vec3.normalize(r.o), Mat4.rotationAxis(Vec3.normalize(Vec3.len(axis) < .001 ? [1, 0, 0] : axis), Math.acos(R / Vec3.len(r.o)) + (dist - R))), R); }
        function transformPos(p, m) { return [m[0] * p[0] + m[4] * p[1] + m[8] * p[2] + m[12], m[1] * p[0] + m[5] * p[1] + m[9] * p[2] + m[13], m[2] * p[0] + m[6] * p[1] + m[10] * p[2] + m[14]]; }
        function projectToScreen(worldPos) { const m = state.vpMatrix, x = worldPos[0], y = worldPos[1], z = worldPos[2], clipX = x * m[0] + y * m[4] + z * m[8] + m[12], clipY = x * m[1] + y * m[5] + z * m[9] + m[13], clipW = x * m[3] + y * m[7] + z * m[11] + m[15]; if (clipW <= 0) return null; return { x: (clipX / clipW + 1) * state.canvas.width / 2, y: (1 - clipY / clipW) * state.canvas.height / 2 }; }
        function onMouseDown(e) {
            if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav') || e.target.closest('#connect-content-layer')) return;
            if (state.valueScrub.active) return;

            const dashboardActive = document.getElementById('dashboard-panel')?.classList.contains('active');
            const loginCardVisible = document.getElementById('login-card')?.classList.contains('visible');
            if (dashboardActive || loginCardVisible) return;

            const rect = state.canvas.getBoundingClientRect();
            state.mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top, down: true };
            state.clickData = { startX: state.mouse.x, startY: state.mouse.y, startTime: Date.now() };

            state.interactionSignature = { type: 'click', path: [] };
            state.pathPoints = [];
            state.pathStartPos = null;

            if (document.body.classList.contains('light-mode')) {
                state.inertia.val = 0;
                let clickedExisting = false;
                for (let h of state.historyHandles) {
                    const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                    if (sp && Math.sqrt((state.mouse.x - sp.x) ** 2 + (state.mouse.y - sp.y) ** 2) < 20) {
                        clickedExisting = true;
                        break;
                    }
                }
                const p = getTargetPos(state.mouse.x, state.mouse.y);
                const r = getMouseRay(state.mouse.x, state.mouse.y);
                const hit = Vec3.dot(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))), Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)))) <= 1;

                if (hit) {
                    state.interaction = { mode: 'zoom', hasTouchedSphere: true, startZ: state.cameraPos[2], startMouse: { x: state.mouse.x, y: state.mouse.y } };
                    const m = state.sphere.rotation;
                    const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]);
                    const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100];

                    state.pathPoints = [rounded];
                    state.interactionSignature.path = [rounded];

                    startDragLogic(p, clickedExisting);
                } else {
                    state.interaction = { mode: 'waiting', hasTouchedSphere: false };
                    state.handle.active = false;
                    state.dragStart.active = false;
                }
                state.hasRotated = true;
            }
        }
        function startDragLogic(p, clickedExisting) { state.dragStart = { active: true, mouseDir: Vec3.normalize(p), sphereRotation: [...state.sphere.rotation], conePositions: state.cones.map(c => [...c.pos]), lastTrackPos: p }; if (!clickedExisting) { state.handle = { active: true, pos: p, color: getSurfaceColor(p, Vec3.normalize(p)) }; } }
        function onMouseMove(e) {
            const r = state.canvas.getBoundingClientRect();
            state.mouse.x = e.clientX - r.left;
            state.mouse.y = e.clientY - r.top;

            if (state.mouse.down && state.interaction && state.interaction.mode === 'waiting') {
                const ray = getMouseRay(state.mouse.x, state.mouse.y);
                const closest = Vec3.add(ray.o, Vec3.scale(ray.d, Vec3.dot(Vec3.sub([0, 0, 0], ray.o), ray.d)));
                const onSphere = Vec3.dot(closest, closest) <= 1;
                if (onSphere) {
                    const p = getTargetPos(state.mouse.x, state.mouse.y);
                    state.interaction.mode = 'normal';
                    state.interaction.hasTouchedSphere = true;

                    state.interactionSignature.type = 'drag';
                    const m = state.sphere.rotation;
                    const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]);
                    const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100];

                    state.pathPoints = [rounded];
                    state.interactionSignature.path = [rounded];

                    startDragLogic(p, false);
                }
            }

            if (state.mouse.down && state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active) {
                const m = state.sphere.rotation;
                const localCenterPos = [m[2], m[6], m[10]];
                const lastPoint = state.pathPoints[state.pathPoints.length - 1];

                if (!lastPoint || Vec3.dist(localCenterPos, lastPoint) > 0.01) {
                    const normalized = Vec3.normalize(localCenterPos);
                    const rounded = [Math.round(normalized[0] * 100) / 100, Math.round(normalized[1] * 100) / 100, Math.round(normalized[2] * 100) / 100];

                    state.pathPoints.push(rounded);
                    state.interactionSignature.type = 'drag';
                    state.interactionSignature.path.push(rounded);
                }

                if (state.pathPoints.length > 500) state.pathPoints.shift();
                if (state.interactionSignature.path.length > 1000) state.interactionSignature.path.shift();
            }
        }
        function onMouseUp(e) { if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav') || e.target.closest('#connect-content-layer')) return; state.mouse.down = false; state.handle.active = false; const wasDragging = state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active && state.interactionSignature.type === 'drag'; state.interaction = { mode: 'none', hasTouchedSphere: false }; if (state.valueScrub.active) { state.valueScrub.active = false; return; } if (document.body.classList.contains('light-mode')) { const rect = state.canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; if (wasDragging) { const col = getSurfaceColor([0, 0, 1], [0, 0, 1], state.cones); const hex = rgbToHex(col[0], col[1], col[2]); state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [0, 0, 1], showHandle: false, targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))), shouldAutoEnter: false, fromUrl: false, hex: hex, notified: false, rotationAxis: [1, 0, 0], rotationAngle: 0 }; state.handle.color = [...col]; state.hasRotated = true; document.getElementById('color-hex').innerText = hex.toUpperCase(); const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white'; document.getElementById('login-card').style.color = textColor; document.getElementById('top-nav').style.setProperty('--nav-color', textColor); if (window.connectAndPreview) window.connectAndPreview(hex, false); setTimeout(() => { state.pathPoints = []; state.pathStartPos = null; }, 500); return; } if (Math.sqrt((mx - state.clickData.startX) ** 2 + (my - state.clickData.startY) ** 2) < 5 && Date.now() - state.clickData.startTime < 250) { for (let h of state.historyHandles) { const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation)); if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) { try { localStorage.setItem("lastSphereColor", h.hex); } catch (e) { } triggerLanding(h.pos, transformPos(h.pos, state.sphere.rotation), h.color, true); return; } } const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))); if (Vec3.dot(p, p) <= 1) { const hp = Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))); triggerLanding(Vec3.normalize(hp), hp, getSurfaceColor(hp, Vec3.normalize(hp)), false); } } } state.pathPoints = []; state.pathStartPos = null; }
        function triggerLanding(norm, pos, col, fromUrl = false) { state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [...pos], showHandle: !fromUrl, targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))), shouldAutoEnter: false, fromUrl: fromUrl }; const startWorldPos = transformPos(pos, state.landing.baseRotation); state.landing.offset = [0, 0]; state.handle.color = [...col]; state.hasRotated = true; const hex = rgbToHex(col[0], col[1], col[2]); window.parent.postMessage(hex, '*'); document.getElementById('color-hex').innerText = hex.toUpperCase(); const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white'; document.getElementById('login-card').style.color = textColor; document.getElementById('top-nav').style.setProperty('--nav-color', textColor); const cam = Vec3.normalize(state.cameraPos), axis = Vec3.cross(norm, cam), dot = Vec3.dot(norm, cam); state.landing.rotationAxis = Vec3.len(axis) < .001 ? [1, 0, 0] : Vec3.normalize(axis); state.landing.rotationAngle = Vec3.len(axis) < .001 ? (dot > 0 ? 0 : Math.PI) : Math.acos(Math.min(1, Math.max(-1, dot))); if (window.connectAndPreview) window.connectAndPreview(hex, fromUrl); setTimeout(() => { const btn = document.getElementById('freeze-btn'); btn.style.opacity = '0'; setTimeout(() => { btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>'; btn.style.opacity = '1'; }, 200); }, 1000); }
        function getResponsiveZ() { const aspect = state.canvas.width / state.canvas.height; return aspect < 1 ? 3.5 / aspect : 4; }
        function toggleFreeze() {
            const isZoomed = document.getElementById('dashboard-panel').classList.contains('active') ||
                document.getElementById('login-card').classList.contains('visible');

            if (isZoomed) {
                if (window.app && window.app.logout) window.app.logout();
                return;
            }

            const f = document.getElementById('flash-overlay'), isFrozen = document.body.classList.toggle('light-mode');
            state.landing = { active: false, showHandle: false };
            document.getElementById('login-card').classList.remove('visible');
            document.getElementById('dashboard-panel').classList.remove('active');
            state.cameraPos = [0, 0, getResponsiveZ()];
            f.style.backgroundColor = isFrozen ? 'white' : 'black';
            document.body.style.backgroundColor = '';
            f.classList.remove('active');
            void f.offsetWidth;
            f.classList.add('active');
            setTimeout(() => f.classList.remove('active'), 0);
            const btn = document.getElementById('freeze-btn');
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
            btn.style.opacity = '1';
        }
        function getSurfaceColor(p, n, cones = state.cones) { const getI = (i) => { if (!cones[i].active) return 0; const diff = Vec3.sub(cones[i].pos, p); const distSq = Vec3.dot(diff, diff); const L = Vec3.normalize(diff); const wrap = Math.max(Vec3.dot(n, L) + 1.0, 0.0) / 2.0; const spread = Math.pow(wrap, 1.25); return spread * (1.0 / (1.0 + distSq * 0.05)); }; const d = [getI(0), getI(1), getI(2)]; const c = cones.map(x => x.color); let l = Vec3.add(Vec3.add(Vec3.scale(c[0], d[0]), Vec3.scale(c[1], d[1])), Vec3.scale(c[2], d[2])); const boost = (i, j) => { const sumD = d[i] + d[j] + 0.001; const factor = (2.0 * d[i] * d[j] / sumD); return Vec3.scale(Vec3.add(c[i], c[j]), factor); }; l = Vec3.add(l, boost(0, 1)); l = Vec3.add(l, boost(1, 2)); l = Vec3.add(l, boost(2, 0)); const minD = Math.min(d[0], Math.min(d[1], d[2])); const maxD = Math.max(d[0], Math.max(d[1], d[2])); let t = (minD - 0.15) / (0.40 - 0.15); t = Math.max(0.0, Math.min(1.0, t)); const maskBase = t * t * (3.0 - 2.0 * t); const variance = maxD - minD; const roundness = Math.exp(-variance * 10.0); const finalMask = maskBase * roundness; const whiteTarget = [1.0, 1.0, 1.0]; l = [l[0] * (1.0 - finalMask) + whiteTarget[0] * finalMask, l[1] * (1.0 - finalMask) + whiteTarget[1] * finalMask, l[2] * (1.0 - finalMask) + whiteTarget[2] * finalMask]; l = l.map(x => x * 1.2); return l.map(x => { const val = Math.min(Math.max(x, 0), 1); return val * val * (3.0 - 2.0 * val); }); }
        function setupColorTooltip() { const t = document.createElement('div'); t.className = 'sphere-tooltip'; document.body.appendChild(t); window.addEventListener('mousemove', e => { if (!document.body.classList.contains('light-mode') || e.target.closest('#dashboard-panel') || e.target.closest('#login-card') || e.target.closest('#top-nav') || e.target.closest('#connect-content-layer')) { t.style.display = 'none'; return; } const rect = state.canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top; if (state.landing.showHandle && state.handle.pos) { const handleScreen = projectToScreen(state.handle.pos); if (handleScreen && Math.sqrt((mx - handleScreen.x) ** 2 + (my - handleScreen.y) ** 2) < 50) { t.style.display = 'none'; return; } } for (let h of state.historyHandles) { const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation)); if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) { t.innerHTML = `<span class="hex">${h.hex.toUpperCase()}</span><span class="${h.peerCount > 0 ? "meta online" : "meta"}">${h.peerCount > 0 ? `${h.peerCount} PEER${h.peerCount > 1 ? 'S' : ''} ONLINE` : "OFFLINE"}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${h.hex}`; return; } } const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))); if (Vec3.dot(p, p) > 1) { t.style.display = 'none'; return; } const hex = rgbToHex(...getSurfaceColor(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p)))), Vec3.normalize(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p))))))).toUpperCase(); t.innerHTML = `<span class="hex">${hex}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${hex}`; }); }
        window.resetSphereView = function (animateIn = false, keepRotation = false) {
            const m = state.sphere.rotation;
            const trace = m[0] + m[5] + m[10];
            let angle = Math.acos(Math.max(-1, Math.min(1, (trace - 1) / 2)));
            let axis = [1, 0, 0];
            const diff = [m[6] - m[9], m[8] - m[2], m[1] - m[4]];
            const sl = Math.sqrt(diff[0] ** 2 + diff[1] ** 2 + diff[2] ** 2);
            if (sl > 0.001) axis = [diff[0] / sl, diff[1] / sl, diff[2] / sl];

            const startDist = animateIn ? 15.0 : Vec3.len(state.cameraPos);

            state.returning = {
                active: true,
                progress: 0,
                baseRotation: m,
                rotationAxis: axis,
                rotationAngle: keepRotation ? 0 : -angle,
                keepRotation: keepRotation,
                startDist: startDist,
                targetDist: getResponsiveZ(),
                coneStartPositions: state.cones.map(c => [...c.pos])
            };
            state.landing.active = false;
            state.landing.showHandle = false;
        };
        function loop(ts) { const dt = Math.min((ts - state.lastTime) / 1000, 0.1); state.lastTime = ts; if (document.body.classList.contains('light-mode') && state.hasRotated) { document.body.style.backgroundColor = rgbToHex(...getSurfaceColor([0, 0, 1], [0, 0, 1])); } if (state.valueScrub.active && Math.abs(state.valueScrub.startY - state.mouse.y) > 5) { state.cones[state.valueScrub.coneIndex].pos[state.valueScrub.coordIndex] += Math.sign(state.valueScrub.startY - state.mouse.y) * Math.pow((Math.abs(state.valueScrub.startY - state.mouse.y) - 5) / 500, 3) * .05; } let manualCameraZ = null; if (state.mouse.down && state.interaction && state.interaction.mode === 'zoom') { let pathLength = 0; for (let i = 1; i < state.pathPoints.length; i++) { pathLength += Vec3.dist(state.pathPoints[i], state.pathPoints[i - 1]); } const zoomProgress = Math.min(1, pathLength / Math.PI); const startZ = state.interaction.startZ; const targetZ = 1.25; manualCameraZ = startZ - (startZ - targetZ) * zoomProgress; state.cameraPos = [0, 0, manualCameraZ]; } if (state.landing.active) { state.landing.progress = Math.min(state.landing.progress + dt * .5, 1); const t = state.landing.progress; if (t >= 1 && !state.landing.notified) { window.parent.postMessage({ type: 'zoom-complete', color: state.landing.hex }, '*'); state.landing.notified = true; } if (t >= 1) { const card = document.getElementById('login-card'); if (window.self === window.top && !card.classList.contains('visible')) { card.classList.add('visible'); card.style.opacity = ''; } if (state.landing.shouldAutoEnter) { if (window.enterRoomUI && window.self === window.top) window.enterRoomUI(); state.landing.shouldAutoEnter = false; } } const rot = Mat4.rotationAxis(state.landing.rotationAxis, state.landing.rotationAngle * t * t); if (state.landing.showHandle) { state.handle.pos = transformPos(state.landing.handleStartPos, rot); if (t >= 1) state.landing.showHandle = false; } state.sphere.rotation = Mat4.multiply(rot, state.landing.baseRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.landing.coneStartPositions[i], rot)); state.cameraPos = Vec3.scale(Vec3.normalize([0, 0, 4]), state.landing.startDist + (state.landing.targetDist - state.landing.startDist) * t * t * t); } if (state.returning && state.returning.active) { state.returning.progress = Math.min(state.returning.progress + dt * 1.5, 1); const t = state.returning.progress, ease = 1 - Math.pow(1 - t, 3), rot = Mat4.rotationAxis(state.returning.rotationAxis, state.returning.rotationAngle * ease); state.sphere.rotation = Mat4.multiply(rot, state.returning.baseRotation); state.cameraPos = [0, 0, state.returning.startDist + (state.returning.targetDist - state.returning.startDist) * ease]; state.cones.forEach((c, i) => c.pos = transformPos(state.returning.coneStartPositions[i], rot)); if (t >= 1) { state.returning.active = false; if (!state.returning.keepRotation) { state.hasRotated = false; state.sphere.rotation = Mat4.identity(); state.cones = defaultCones.map(c => ({ ...c, pos: [...c.pos], color: [...c.color] })); state.cameraPos = [0, 0, getResponsiveZ()]; document.body.style.backgroundColor = ''; document.getElementById('color-hex').innerText = "#FFFFFF"; document.getElementById('login-card').style.color = ''; document.getElementById('top-nav').style.removeProperty('--nav-color'); document.getElementById('login-card').style.opacity = ''; document.getElementById('login-card').style.transition = ''; } } } let renderBackgroundLayer = false; let bgCameraPos = [0, 0, 0]; if (manualCameraZ === null && state.peeking && (state.peeking.active || state.peeking.value > 0) && (!state.returning || !state.returning.active)) { const zoomedInZ = state.landing.targetDist || 1.25; const zoomedOutZ = state.landing.startDist || 4.0; const t = state.peeking.value; const ease = t * t * (3 - 2 * t); const currentZ = zoomedInZ + (zoomedOutZ - zoomedInZ) * ease; state.cameraPos = [0, 0, currentZ]; if (t > 0.01 && t < 0.99) { renderBackgroundLayer = true; bgCameraPos = [0, 0, zoomedInZ]; } } state.vpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(state.cameraPos, [0, 0, 0], [0, 1, 0])); if (!document.body.classList.contains('light-mode')) { state.cones.forEach((c, i) => { const cache = state.uiCache[i]; if (!cache) return; if (cache.lastActive !== c.active) { cache.title.style.color = c.active ? c.cssColor : 'grey'; cache.lastActive = c.active; } ['x', 'y', 'z'].forEach((ax, idx) => { if (Math.abs(c.pos[idx] - cache.lastPos[idx]) > 0.005) { cache[ax].innerText = c.pos[idx].toFixed(2); cache.lastPos[idx] = c.pos[idx]; } }); }); if (state.mouse.down) { const tp = getTargetPos(state.mouse.x, state.mouse.y); if (state.draggedConeIndex === -1 && tp) state.cones.forEach((c, i) => { if (c.active && Vec3.dist(c.pos, tp) < 0.8) state.draggedConeIndex = i; }); if (state.draggedConeIndex !== -1) { const np = calculateConePosition(state.mouse.x, state.mouse.y), c = state.cones[state.draggedConeIndex]; c.vel = Vec3.scale(Vec3.sub(np, c.pos), 1 / dt); c.pos = np; } } else state.draggedConeIndex = -1; state.cones.forEach(c => { if (state.draggedConeIndex === -1 || state.cones[state.draggedConeIndex] !== c) { if (Vec3.len(c.vel) > .001) { c.pos = Vec3.scale(Vec3.normalize(Vec3.add(c.pos, Vec3.scale(c.vel, dt))), 1.2); c.vel = Vec3.scale(c.vel, .95); } else c.pos = Vec3.scale(Vec3.normalize(c.pos), 1.2); } }); } else if (state.mouse.down && state.dragStart.active) { state.landing.active = false; state.landing.showHandle = false; document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active'); const tp = getTargetPos(state.mouse.x, state.mouse.y); if (tp) { state.handle.pos = tp; if (state.dragStart.lastTrackPos) { const axis = Vec3.cross(state.dragStart.lastTrackPos, tp); state.inertia = { active: false, axis: Vec3.len(axis) > 1e-5 ? Vec3.normalize(axis) : [1, 0, 0], val: Vec3.len(axis) }; } state.dragStart.lastTrackPos = tp; const a = Vec3.cross(state.dragStart.mouseDir, Vec3.normalize(tp)); if (Vec3.len(a) > .001) { const r = Mat4.rotationAxis(Vec3.normalize(a), Math.acos(Math.min(1, Math.max(-1, Vec3.dot(state.dragStart.mouseDir, Vec3.normalize(tp)))))); state.sphere.rotation = Mat4.multiply(r, state.dragStart.sphereRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.dragStart.conePositions[i], r)); } } } else { state.dragStart.active = false; state.handle.active = false; if (state.inertia.val > 0.0001) { const r = Mat4.rotationAxis(state.inertia.axis, state.inertia.val); state.sphere.rotation = Mat4.multiply(r, state.sphere.rotation); state.cones.forEach(c => c.pos = transformPos(c.pos, r)); state.inertia.val *= 0.95; } } if (state.device && state.pipelines.sphere && state.msaaTexture) { const drawSphere = (encoder, viewProjMatrix, loadOp, depthOp) => { state.uniforms.sphere.set(Mat4.multiply(viewProjMatrix, state.sphere.rotation), 0); state.uniforms.sphere.set(state.sphere.rotation, 16); state.uniforms.sphere.set(state.sphere.rotation, 32); state.uniforms.sphere.set(state.cameraPos, 48);[0, 1, 2].forEach(i => { state.uniforms.sphere.set(state.cones[i].pos, 52 + i * 8); state.uniforms.sphere.set(state.cones[i].active ? state.cones[i].color : [0, 0, 0], 56 + i * 8); }); state.uniforms.sphere[76] = state.debugMode ? 1.0 : 0.0; state.device.queue.writeBuffer(state.buffers.sphereUniform, 0, state.uniforms.sphere); const pass = encoder.beginRenderPass({ colorAttachments: [{ view: state.msaaTexture.createView(), resolveTarget: state.context.getCurrentTexture().createView(), clearValue: document.body.classList.contains('light-mode') ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, g: 0, b: 0, a: 1 }, loadOp: loadOp, storeOp: 'store' }], depthStencilAttachment: { view: state.depthTexture.createView(), depthClearValue: 1, depthLoadOp: 'clear', depthStoreOp: depthOp } }); pass.setPipeline(state.pipelines.sphere); pass.setBindGroup(0, state.bindGroups.sphere); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setVertexBuffer(1, state.buffers.sphereNormal); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16'); pass.drawIndexed(state.sphere.indexCount); return pass; }; const drawCones = (pass) => { pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, document.body.classList.contains('light-mode') ? state.buffers.sphereVertex : state.buffers.coneVertex); pass.setIndexBuffer(document.body.classList.contains('light-mode') ? state.buffers.sphereIndex : state.buffers.coneIndex, 'uint16'); if (!document.body.classList.contains('light-mode')) { state.cones.forEach((c, i) => { if (c.active) { let m; if (Vec3.len(Vec3.cross([0, 1, 0], c.pos)) > .001) { const y = Vec3.normalize(c.pos), x = Vec3.normalize(Vec3.cross(Vec3.len(Vec3.cross([0, 1, 0], y)) < .01 ? [0, 0, 1] : [0, 1, 0], y)), z = Vec3.cross(x, y); m = [x[0], x[1], x[2], 0, y[0], y[1], y[2], 0, z[0], z[1], z[2], 0, c.pos[0], c.pos[1], c.pos[2], 1]; } else m = Mat4.multiply(Mat4.translation(c.pos), c.pos[1] < 0 ? Mat4.rotationX(Math.PI) : Mat4.identity()); state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(m, Mat4.scale([.5, .5, .5]))), 0); state.uniforms.cone.set([...c.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, i * 256, state.uniforms.cone); pass.setBindGroup(0, state.bindGroups.cones[i]); pass.drawIndexed(state.coneIndexCount); } }); } else { let bindIdx = 4; if (state.handle.active || state.landing.showHandle) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(state.handle.pos), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...state.handle.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, 3 * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(3)); pass.drawIndexed(state.sphere.indexCount); } state.historyHandles.forEach(h => { const wp = transformPos(h.pos, state.sphere.rotation); if (wp[2] > -0.5) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(wp), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...h.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.drawIndexed(state.sphere.indexCount); bindIdx++; } }); if (state.pathPoints.length > 1 && (state.dragStart.active || state.landing.active || state.renderPath)) { const pathVerts = pathToVertices(state.pathPoints, state.sphere.rotation); if (pathVerts && pathVerts.length > 0) { if (!state.buffers.pathVertex || state.buffers.pathVertex.size < pathVerts.byteLength) { if (state.buffers.pathVertex) state.buffers.pathVertex.destroy(); state.buffers.pathVertex = state.device.createBuffer({ size: Math.max(pathVerts.byteLength, 1024 * 12), usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST }); } state.device.queue.writeBuffer(state.buffers.pathVertex, 0, pathVerts); state.uniforms.cone.set(state.vpMatrix, 0); state.uniforms.cone.set([1, 1, 1, 1], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setPipeline(state.pipelines.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.setVertexBuffer(0, state.buffers.pathVertex); pass.draw(pathVerts.length / 3); } } } }; if (renderBackgroundLayer) { const bgEncoder = state.device.createCommandEncoder(); const bgVpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(bgCameraPos, [0, 0, 0], [0, 1, 0])); const bgPass = drawSphere(bgEncoder, bgVpMatrix, 'clear', 'discard'); bgPass.end(); state.device.queue.submit([bgEncoder.finish()]); const fgEncoder = state.device.createCommandEncoder(); const fgPass = drawSphere(fgEncoder, state.vpMatrix, 'load', 'discard'); drawCones(fgPass); fgPass.end(); state.device.queue.submit([fgEncoder.finish()]); } else { const encoder = state.device.createCommandEncoder(); const pass = drawSphere(encoder, state.vpMatrix, 'clear', 'discard'); drawCones(pass); pass.end(); state.device.queue.submit([encoder.finish()]); } } requestAnimationFrame(loop); }
        init();
        window.updateVisitedFromDB = async function () { const rooms = await (new window.ColorDB()).getAllRooms(); state.historyHandles = []; if (rooms?.length) { rooms.forEach(r => { const p = findPositionFromColor('#' + r.hex); if (p) state.historyHandles.push({ pos: Vec3.normalize(p), color: hexToRgbNormalized('#' + r.hex), hex: '#' + r.hex, peerCount: 0 }); }); } };
        window.addEventListener("message", (e) => { if (e.data === "getSphereColor") e.source.postMessage(storageScope.getItem("lastSphereColor") || "#ff0000", e.origin); if (e.data?.type === 'handle-ready') { const hex = e.data.hex, pos = findPositionFromColor(hex); if (pos && !state.historyHandles.some(h => h.hex === hex)) { state.historyHandles.push({ pos: Vec3.normalize(pos), color: hexToRgbNormalized(hex), hex, peerCount: e.data.count }); const d = document.createElement('div'); d.className = 'debug-room-item ' + (e.data.count > 0 ? 'active' : ''); d.innerHTML = `<span>${hex}</span> <span class="count">${e.data.count} peer(s)</span>`; document.getElementById('debug-rooms').appendChild(d); } } });
        async function initStorageAccess() { if (window.self === window.top) return; const triggerZoomToColor = (hexColor) => { const matchPos = findPositionFromColor(hexColor); if (matchPos) { if (!document.body.classList.contains('light-mode')) { document.body.classList.add('light-mode'); } triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(hexColor), true); const checkLandingComplete = () => { if (state.landing.progress >= 1) { window.parent.postMessage({ type: 'zoom-done', color: hexColor }, "*"); } else if (state.landing.active) { requestAnimationFrame(checkLandingComplete); } }; requestAnimationFrame(checkLandingComplete); } }; const access = async (h) => { try { if (h?.localStorage) storageScope = h.localStorage; const c = storageScope.getItem("lastSphereColor"); if (c) { window.parent.postMessage(c, "*"); if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove(); document.body.style.backgroundColor = c; triggerZoomToColor(c); } else { window.parent.postMessage({ type: 'no-color' }, "*"); if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove(); } } catch (e) { } }; try { if (await document.hasStorageAccess()) try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { access(null); } else { const o = document.createElement('div'); o.id = 'saa-overlay'; Object.assign(o.style, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: '#fff', zIndex: 10000, display: 'flex', justifyContent: 'center', alignItems: 'center' }); const b = document.createElement("button"); b.innerText = "LOGIN"; Object.assign(b.style, { padding: "12px 24px", fontSize: "16px", cursor: "pointer", background: "#000", color: "#fff", border: "none", borderRadius: "8px" }); o.appendChild(b); document.body.appendChild(o); b.onclick = async () => { try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { o.innerHTML = "Access Denied"; } }; } } catch (e) { } }
        initStorageAccess();

        // Setup TURN server settings UI
        const turnAppNameEl = document.getElementById('turn-app-name');
        const turnApiKeyEl = document.getElementById('turn-api-key');

        turnAppNameEl.value = localStorage.getItem('turnAppName') || '';
        turnApiKeyEl.value = localStorage.getItem('turnApiKey') || '';

        turnAppNameEl.addEventListener('input', e => localStorage.setItem('turnAppName', e.target.value));
        turnApiKeyEl.addEventListener('input', e => localStorage.setItem('turnApiKey', e.target.value));
    </script>
</body>

</html>
