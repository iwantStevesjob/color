<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color</title>

    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --ui-bg: rgba(255, 255, 255, 0.1);
            --ui-border: rgba(255, 255, 255, 0.2);
            --nav-color: white;
            --tracker-bg: rgba(0, 0, 0, 0.75);
        }

        body.light-mode {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --ui-bg: rgba(0, 0, 0, 0.1);
            --ui-border: rgba(0, 0, 0, 0.2);
            --nav-color: black;
            --tracker-bg: transparent;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.1s linear;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        #flash-overlay.active {
            opacity: 1;
            transition: none;
        }

        /* --- LOGIN CARD --- */
        #login-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
            color: inherit;
        }

        #login-card.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #color-hex {
            font-size: 5rem;
            font-weight: 900;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            line-height: 1;
        }

        #room-status {
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            margin: 15px 0 25px 0;
            opacity: 0.7;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-height: 1.2em;
            font-weight: bold;
        }

        #login-btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 12px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-decoration: none;
        }

        #login-btn:hover {
            background: currentColor;
            opacity: 0.8;
        }

        #login-btn:hover span {
            filter: invert(1);
        }

        #login-btn.hidden {
            display: none;
        }

        /* --- UI OVERLAYS --- */
        #hover-trigger {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3vh;
            z-index: 300;
            display: none;
        }

        #top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 12vh;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            z-index: 150;
            transition: opacity 0.5s ease;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.4), transparent);
            opacity: 0;
            pointer-events: none;
        }

        #top-nav.active {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-item {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            opacity: 0.8;
            transition: 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--nav-color);
        }

        .nav-item:hover {
            opacity: 1;
            transform: translateY(2px);
        }

        /* --- DASHBOARD --- */
        #dashboard-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 98vh;
            background-color: white;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -20px 50px rgba(0, 0, 0, 0.2);
            padding: 0;
        }

        #dashboard-panel.active {
            transform: translateY(0);
        }

        #dashboard-panel.active.revealed {
            transform: translateY(12vh);
        }

        /* --- DEBUG & TOOLS --- */
        #debug-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 10px;
            z-index: 2000;
            color: #0f0;
            font-family: 'Menlo', monospace;
            font-size: 12px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
        }

        #debug-panel.visible {
            display: block;
        }

        #debug-rooms {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .debug-room-item {
            padding: 4px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .debug-room-item .count {
            color: #fff;
            font-weight: bold;
        }

        .debug-room-item.active {
            color: #00e676;
        }

        #debug-btn,
        #freeze-btn {
            position: absolute;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            z-index: 301;
        }

        #debug-btn {
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Menlo', monospace;
            font-size: 0.8rem;
        }

        #debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #debug-btn.active {
            background: rgba(255, 0, 0, 0.5);
            border-color: red;
            color: white;
        }

        #reset-btn {
            margin-top: 10px;
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
        }

        #reset-btn:hover {
            background: #900;
        }

        /* TOOLTIP */
        .sphere-tooltip {
            position: absolute;
            display: none;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-Family: monospace;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(15px, 15px);
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
        }

        .sphere-tooltip .hex {
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            margin-bottom: 2px;
            display: block;
        }

        .sphere-tooltip .meta {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sphere-tooltip .meta.online {
            color: #00e676;
            font-weight: bold;
        }

        /* CHAT UI */
        #chat-header {
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-family: -apple-system, system-ui, sans-serif;
            flex-shrink: 0;
            color: #1a1a1a;
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .dot.on {
            background: #00e676;
            box-shadow: 0 0 5px #00e676;
        }

        #user-badge {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #999;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #fff;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow-anchor: none;
        }

        #display {
            min-height: 100%;
            outline: none;
            padding: 40px 60px;
            font-size: 16px;
            line-height: 24px;
            position: relative;
        }

        .editor-line {
            min-height: 24px;
            display: block;
            padding-left: 5px;
            border-left: 4px solid transparent;
            white-space: pre-wrap;
            transition: border-left-color 0.4s ease;
        }

        .editor-line:hover,
        .editor-line.group-hover {
            border-left-color: var(--owner-color, transparent);
        }

        .locked-line {
            background-color: rgba(0, 0, 0, 0);
            border-left-width: 3px !important;
            border-left-color: var(--lock-color) !important;
        }

        .locked-tag {
            position: absolute;
            left: 0;
            top: 0;
            transform: translateX(-100%);
            height: 100%;
            background-color: var(--lock-color);
            color: transparent;
            font-family: sans-serif;
            font-size: 10px;
            white-space: nowrap;
            width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px 0 0 2px;
            pointer-events: auto;
            transition: width 0.3s, opacity 0.1s;
        }

        .locked-line:hover .locked-tag {
            width: 20px;
            opacity: 1;
            color: transparent;
        }

        .locked-line .locked-tag:hover {
            width: 60px !important;
            padding: 0 6px;
            color: #fff !important;
            z-index: 999;
            color: 0.4s ease-in;
        }

        #minimap {
            position: absolute;
            right: 5px;
            top: 60px;
            bottom: 0;
            width: 12px;
            z-index: 201;
            pointer-events: none;
        }

        .scroll-dot {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: top 0.1s ease-out;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        #tools {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 10px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 205;
        }

        #tools.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #tools button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
            font-weight: bold;
        }

        #freeze-btn {
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        #tracker {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 25px;
            background: var(--tracker-bg);
            border: 1px solid var(--ui-border);
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 10;
            pointer-events: none;
        }

        body.light-mode #tracker {
            display: none;
        }

        .cone-data {
            display: flex;
            gap: 8px;
            font-size: 11px;
            font-family: 'Menlo', monospace;
            color: rgba(255, 255, 255, 0.6);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
            pointer-events: auto;
            cursor: default;
        }

        .cone-data:last-child {
            border-right: none;
            padding-right: 0;
        }

        .cone-title {
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
        }

        .coord-val {
            color: white;
            min-width: 38px;
            cursor: ns-resize;
        }
        
        /* MOBILE ADJUSTMENTS */
        @media (max-width: 768px) {
            #tracker {
                flex-direction: column !important;
                height: auto !important;
                padding: 15px !important;
                border-radius: 20px !important;
                gap: 10px !important;
                align-items: center !important;
            }
            .cone-data {
                border-right: none !important;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                padding-right: 0 !important;
                padding-bottom: 8px;
                width: 100%;
                justify-content: space-between;
            }
            .cone-data:last-child {
                border-bottom: none;
            }
        }
    </style>
</head>

<body class="light-mode">
    <canvas id="gpu-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="hover-trigger"></div>

    <nav id="top-nav">
        <div class="nav-item">Settings</div>
        <div class="nav-item">Home</div>
    </nav>

    <div id="login-card">
        <div id="color-hex">#FFFFFF</div>
        <div id="room-status">Initializing...</div>
        <button id="login-btn"><span>LOGIN</span></button>
    </div>

    <button id="debug-btn">DEBUG OFF</button>
    <div id="debug-panel">
        <h3>System Tools</h3>
        <button id="reset-btn">WIPE ALL DATA</button>
        <h4>Discovered Rooms</h4>
        <div id="debug-rooms"></div>
    </div>

    <div id="dashboard-panel">
        <div id="chat-header">
            <div><span id="user-badge" title="Your Color"></span></div>
            <div class="status"><span class="dot"></span><span id="peer-count">Disconnected</span></div>
        </div>
        <div id="chat-container">
            <div id="display" contenteditable="true" spellcheck="false"></div>
        </div>
        <div id="minimap"></div>
    </div>

    <div id="tools">
        <button id="btn-bold">B</button>
        <button id="btn-italic">I</button>
        <button id="btn-link">ðŸ”—</button>
    </div>

    <div id="freeze-btn"><svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none"
            stroke-width="2">
            <path d="M9 18h6" />
            <path d="M10 22h4" />
            <path
                d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" />
        </svg></div>
    <div id="tracker">
        <div class="cone-data" id="data-0"></div>
        <div class="cone-data" id="data-1"></div>
        <div class="cone-data" id="data-2"></div>
    </div>

    <script type="module">
        import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

        class ColorDB {
            constructor() { this.name = 'color'; }
            async _open(hex = null) {
                return new Promise((resolve, reject) => {
                    let req = indexedDB.open(this.name);
                    req.onsuccess = (e) => {
                        const db = e.target.result;
                        if (hex && !db.objectStoreNames.contains(hex)) {
                            const v = db.version + 1;
                            db.close();
                            const upg = indexedDB.open(this.name, v);
                            upg.onupgradeneeded = (evt) => evt.target.result.createObjectStore(hex);
                            upg.onsuccess = (evt) => resolve(evt.target.result);
                            upg.onerror = reject;
                        } else resolve(db);
                    };
                    req.onerror = reject;
                });
            }
            async getRoom(hex) {
                const db = await this._open();
                if (!db.objectStoreNames.contains(hex)) return null;
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readonly').objectStore(hex);
                    const req = tx.getAllKeys();
                    req.onsuccess = () => {
                        const keys = req.result;
                        if (!keys.length) { res(null); return; }
                        tx.getAll().onsuccess = (e) => {
                            const vals = e.target.result;
                            const lookup = {};
                            keys.forEach((k, i) => lookup[k] = vals[i]);
                            const skeleton = lookup.__SKELETON__ || [];
                            const content = {};
                            skeleton.forEach(id => {
                                if (lookup[id] !== undefined) content[id] = `<div id="${id}" class="editor-line">${lookup[id]}</div>`;
                            });
                            res({ hex, skeleton, content });
                        }
                    }
                    req.onerror = () => res(null);
                });
            }
            async saveRoom(hex, skeleton, content) {
                const db = await this._open(hex);
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readwrite');
                    const store = tx.objectStore(hex);
                    store.clear();
                    store.put(skeleton, '__SKELETON__');
                    for (const [id, outer] of Object.entries(content)) {
                        const inner = outer.substring(outer.indexOf('>') + 1, outer.lastIndexOf('<'));
                        store.put(inner, id);
                    }
                    tx.oncomplete = () => res(true);
                    tx.onerror = () => res(false);
                });
            }
            async getAllRooms() {
                const db = await this._open();
                return Array.from(db.objectStoreNames).map(hex => ({ hex }));
            }
            init() { return this._open(); }
        }
        window.ColorDB = ColorDB;

        class EditorApp {
            constructor() {
                this.db = new ColorDB();
                this.db.init();

                this.ui = Object.fromEntries([
                    'display', 'chat-container', 'minimap', 'peer-count', 'tools', 'room-status',
                    'login-btn', 'user-badge', 'login-card', 'dashboard-panel', 'hover-trigger', 'top-nav'
                ].map(id => [id.replace(/-./g, x => x[1].toUpperCase()), document.getElementById(id)]));
                this.ui.dot = document.querySelector('.dot');

                const savedColor = localStorage.getItem('lastSphereColor');
                this.user = { id: 'user_' + this.makeId().replace('line-', ''), color: savedColor || '#ffffff' };
                this.visitedRooms = [];
                this.peerColors = {};
                this.anonCounter = 1;

                this.db.getAllRooms().then(rooms => {
                        this.visitedRooms = rooms.map(r => 'doc-infinite-' + r.hex);
                        if (!window.location.hash || window.location.hash.length < 2) {
                            this.runSequencedScan();
                        } else {
                            this.tryAutoConnectFromHash();
                        }
                    });

                this.room = null;
                this.roomId = null;
                this.actions = {};
                this.activeLocks = {};
                this.currentLineId = null;
                this.isFresh = true;
                this.saveTimeout = null;
                this.statusTimeoutAttempts = 20;
                this.lastLineCount = 0;

                this.bindEvents();
                this.setupGlobalExposure();

                if (!window.location.hash || window.location.hash.length < 2) {
                    setTimeout(() => this.runSequencedScan(), 100);
                }
                else this.tryAutoConnectFromHash();
            }

            makeId() { return 'line-' + Math.random().toString(36).substr(2, 9); }
            tryAutoConnectFromHash() { if (window.location.hash.length > 1) this.connectAndPreview(window.location.hash, true); }

            joinNetwork(mode = 'standard') {
                try { this.room = joinRoom({ appId: 'doc-infinite-v5-idb', trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io'] }, this.roomId); } catch (e) { return; }
                const actions = ['skeleton', 'fragment', 'lock', 'req', 'identity'];
                const [sendSkeleton, getSkeleton] = this.room.makeAction('skeleton');
                this.actions = Object.assign({ sendSkeleton }, ...actions.slice(1).map(k => ({ [`send${k.charAt(0).toUpperCase() + k.slice(1)}`]: this.room.makeAction(k)[0] })));
                const [_, getFragment] = this.room.makeAction('fragment');
                const [__, getLock] = this.room.makeAction('lock');
                const [___, getReqSync] = this.room.makeAction('req');
                const [____, getIdentity] = this.room.makeAction('identity');

                this.actions.reqSync = this.room.makeAction('req')[0];

                getIdentity((data, pid) => this.handlePeerIdentity(data, pid));

                getSkeleton((ids, peerId) => {
                    if (mode === 'conflict' && ids) {
                        const myIds = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                        if (JSON.stringify(myIds.slice(0, 10)) !== JSON.stringify(ids.slice(0, 10)) && this.ui.display.innerText.trim().length > 10) {
                            if (confirm(`Remote content differs. Sync?`)) { this.handleRemoteSkeleton(ids); this.actions.reqSync(null); }
                            else { this.room.leave(); this.room = null; this.actions = {}; this.ui.peerCount.innerText = "Offline (by choice)"; this.ui.dot.classList.remove('on'); }
                        } else this.handleRemoteSkeleton(ids);
                    } else this.handleRemoteSkeleton(ids);
                });

                getFragment((fragMap) => this.handleRemoteFragments(fragMap));
                getLock((data, pid) => this.handleRemoteLock(data, pid));
                getReqSync((_, pid) => {
                    const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                    if (ids.length) { this.actions.sendSkeleton(ids, pid); const frags = this.getFragments(false); if (Object.keys(frags).length) this.actions.sendFragment(frags, pid); }
                });

                this.room.onPeerJoin(id => { this.handlePeerJoin(id); this.updateStatus(); });
                this.room.onPeerLeave(() => { this.updateStatus(); this.reapplyVisualLocks(); });

                let attempts = 0;
                const poll = setInterval(() => {
                    attempts++; if (!this.room) { clearInterval(poll); return; }
                    this.updateStatus(Object.keys(this.room.getPeers()).length, attempts);
                    if ((mode === 'conflict' && attempts === 2) || (this.ui.display.innerText.trim().length < 5 && attempts % 4 === 0)) this.actions.reqSync(null);
                    if (attempts > 120) clearInterval(poll);
                }, 250);
                setTimeout(() => { if (this.room) this.actions.reqSync(null); }, 500);
            }

            setupGlobalExposure() { window.connectAndPreview = (hex, u) => this.connectAndPreview(hex, u); window.enterRoomUI = () => this.enterRoomUI(); }

            connectAndPreview(hex, fromUrl = false) {
                this.statusTimeoutAttempts = fromUrl ? 20 : 2;
                const cleanHex = hex.replace('#', '');
                this.roomId = 'doc-infinite-' + cleanHex;
                this.user.color = '#' + cleanHex;
                this.ui.userBadge.style.backgroundColor = this.user.color;

                if (this.room) { try { this.room.leave(); } catch (e) { } this.room = null; }

                this.db.getRoom(cleanHex).then(data => {
                    if (data?.skeleton?.length) {
                        this.ui.roomStatus.innerText = "Loading..."; this.ui.loginBtn.classList.remove('hidden');
                        this.renderFromLocalDB(data).then(() => { 
                            this.ui.roomStatus.innerText = "READY"; 
                            this.joinNetwork('conflict'); 
                        });
                    } else {
                        this.ui.roomStatus.innerText = "Checking Network..."; this.ui.loginBtn.classList.remove('hidden');
                        this.joinNetwork('standard');
                        setTimeout(() => { if (!this.ui.display.querySelector('.editor-line')) { this.ui.display.innerHTML = this.createLines(101); this.isFresh = true; this.ui.roomStatus.innerText = "COLOR AVAILABLE"; } }, 3000);
                    }
                });
            }

            async renderFromLocalDB(data) {
                this.ui.display.innerHTML = data.skeleton.length ? data.skeleton.map(id => data.content[id] || `<div id="${id}" class="editor-line"><br></div>`).join('') : this.createLines(101);
                this.isFresh = !data.skeleton.length;
                this.ensureStructure();
            }

            enterRoomUI() {
                if (this.ui.dashboardPanel.classList.contains('active')) return;
                if (!this.visitedRooms.includes(this.roomId)) {
                    this.visitedRooms.push(this.roomId);
                    this.db._open(this.roomId.replace('doc-infinite-', '')); 
                }
                this.ui.loginBtn.classList.add('hidden'); this.ui.loginCard.classList.remove('visible');
                
                // Immediate Slide up
                this.ui.dashboardPanel.classList.add('active'); 
                this.ui.hoverTrigger.style.display = 'block'; 
                this.ui.topNav.classList.add('active');

                // Delayed Icon Switch
                setTimeout(() => {
                    document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                }, 2000);

                window.location.hash = this.roomId.replace('doc-infinite-', '');
                if (!this.ui.display.querySelector('.editor-line')) { this.ui.display.innerHTML = this.createLines(101); this.isFresh = true; }
                this.isFresh || this.ui.display.innerText.trim().length < 5 ? this.focusCenter() : this.ui.display.focus();
            }

            async runSequencedScan() {
                for (const rId of this.visitedRooms) {
                    if (!rId) continue;
                    try {
                        const r = joinRoom({ appId: 'doc-infinite-v4', trackerUrls: ['wss://tracker.webtorrent.dev'] }, rId);
                        await new Promise(res => setTimeout(() => {
                            window.postMessage({ type: 'handle-ready', hex: rId.replace('doc-infinite-', '#'), count: Object.keys(r.getPeers()).length }, '*'); r.leave(); res();
                        }, 1000));
                    } catch (e) { }
                }
            }

            createLines(count) { return Array.from({ length: count }, () => `<div id="${this.makeId()}" class="editor-line"><br></div>`).join(''); }

            focusCenter() {
                let attempts = 0;
                const i = setInterval(() => {
                    attempts++;
                    const mid = this.ui.display.children[50];
                    if (mid) {
                        mid.scrollIntoView({ block: 'center', behavior: 'auto' });
                        const r = document.createRange(); const s = window.getSelection(); r.selectNodeContents(mid); r.collapse(true); s.removeAllRanges(); s.addRange(r);
                        this.ui.display.focus(); this.currentLineId = mid.id;
                        if (document.activeElement === this.ui.display || attempts > 20) clearInterval(i);
                    } else clearInterval(i);
                }, 50);
            }

            ensureStructure() {
                Array.from(this.ui.display.children).forEach(child => {
                    if (child.tagName !== 'DIV' || !child.id) child.outerHTML = `<div id="${this.makeId()}" class="editor-line">${child.innerHTML || '<br>'}</div>`;
                    if (!child.classList.contains('editor-line')) child.classList.add('editor-line');
                });
            }

            checkBuffers() {
                if (this.bufferCheckPending) return;
                this.bufferCheckPending = true;
                requestAnimationFrame(() => {
                    this.bufferCheckPending = false;
                    const c = this.ui.chatContainer;
                    const { scrollTop: st, scrollHeight: sh, clientHeight: ch } = c;
                    let upd = false;
                    if (st < 100) { const oh = sh; this.ui.display.insertAdjacentHTML('afterbegin', this.createLines(10)); if (c.scrollHeight > 0) c.scrollTop = st + (c.scrollHeight - oh); upd = true; }
                    if (sh - st - ch < 100) { this.ui.display.insertAdjacentHTML('beforeend', this.createLines(10)); upd = true; }

                    const children = Array.from(this.ui.display.children);
                    if (children.length > 150) {
                        const lines = children;
                        let firstC = -1, lastC = -1;
                        for (let i = 0; i < lines.length; i++) { if (lines[i].textContent.trim()) { if (firstC === -1) firstC = i; lastC = i; } }

                        const topE = c.scrollTop, botE = topE + ch;
                        let firstV = -1, lastV = -1;
                        for (let i = 0; i < lines.length; i++) {
                            const t = lines[i].offsetTop, h = lines[i].offsetHeight;
                            if (t + h > topE && t < botE) { if (firstV === -1) firstV = i; lastV = i; }
                            else if (t > botE && firstV !== -1) break;
                        }
                        if (firstV === -1) { firstV = 0; lastV = lines.length - 1; }

                        const B = 50;
                        const kStart = Math.min(Math.max(0, firstV - B), firstC !== -1 ? Math.max(0, firstC - B) : Infinity);
                        const kEnd = Math.max(Math.min(lines.length - 1, lastV + B), lastC !== -1 ? Math.min(lines.length - 1, lastC + B) : -Infinity);

                        if (kStart > 0) {
                            let remH = 0;
                            for (let i = 0; i < kStart; i++) { remH += lines[i].offsetHeight; lines[i].remove(); }
                            c.scrollTop = Math.max(0, c.scrollTop - remH);
                            upd = true;
                        }
                        if (kEnd < lines.length - 1) {
                            for (let i = kEnd + 1; i < lines.length; i++) lines[i].remove();
                            upd = true;
                        }
                    }
                    if (upd) { this.renderMinimap(); this.broadcastSkeleton(); }
                });
            }

            broadcastSkeleton() { if (this.room && this.actions.sendSkeleton) this.actions.sendSkeleton(Array.from(this.ui.display.children).map(el => el.id).filter(id => id)); }

            async logout() {
                if (window.resetSphereView) window.resetSphereView();
                this.ui.dashboardPanel.classList.remove('active', 'revealed'); this.ui.loginCard.classList.remove('visible');
                this.ui.loginBtn.classList.remove('hidden'); this.ui.hoverTrigger.style.display = 'none'; this.ui.topNav.classList.remove('active');
                
                // Revert Icon
                document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';

                window.location.hash = ''; if (this.room) { try { this.room.leave(); } catch (e) { } this.room = null; }
                this.ui.display.innerHTML = ''; this.ui.minimap.innerHTML = ''; this.activeLocks = {};
                this.ui.peerCount.innerText = "Disconnected"; this.ui.dot.classList.remove('on');
                if (window.updateVisitedFromDB) await window.updateVisitedFromDB();
            }

            updateStatus(peers = 0, attempts = 0) {
                if (!this.room) return;
                if (peers > 0) { this.ui.roomStatus.innerText = `${peers} PEER${peers > 1 ? 'S' : ''} ONLINE`; this.ui.peerCount.innerText = `${peers} visitors(s)`; this.ui.dot.classList.add('on'); return; }
                if (attempts < this.statusTimeoutAttempts) { this.ui.roomStatus.innerText = "SEARCHING..."; this.ui.peerCount.innerText = "Connecting..."; }
                else { this.ui.roomStatus.innerText = "COLOR AVAILABLE"; this.ui.peerCount.innerText = "Offline"; }
                this.ui.dot.classList.remove('on');
            }

            getFragments(visibleOnly = false) {
                const d = {}, top = this.ui.chatContainer.scrollTop - 500, bot = top + this.ui.chatContainer.clientHeight + 1000;
                Array.from(this.ui.display.children).forEach(el => { if (el.id && (!visibleOnly || (el.offsetTop + el.offsetHeight > top && el.offsetTop < bot))) d[el.id] = el.outerHTML; });
                return d;
            }

            async handleRemoteSkeleton(ids) {
                const map = Object.fromEntries(Array.from(this.ui.display.children).map(el => [el.id, el]));
                this.ui.display.innerHTML = ids.map(id => map[id] ? map[id].outerHTML : `<div id="${id}" class="editor-line"><br></div>`).join('');
                await this.triggerSave(null);
            }

            async handleRemoteFragments(fragMap) {
                const temp = document.createElement('div');
                for (const [id, html] of Object.entries(fragMap)) {
                    temp.innerHTML = html; const newEl = temp.firstElementChild, el = document.getElementById(id);
                    if (newEl && el) {
                        Object.assign(el.dataset, newEl.dataset);
                        el.style.cssText = newEl.style.cssText;
                        el.contentEditable = (el.dataset.owner && el.dataset.owner !== this.user.id) ? "false" : "true";
                        if (el.innerHTML !== newEl.innerHTML && document.activeElement !== el) el.innerHTML = newEl.innerHTML;
                    }
                }
                await this.triggerSave(null);
            }

            handlePeerJoin(id) {
                const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                if (ids.length) { this.actions.sendSkeleton(ids, id); const frags = this.getFragments(false); if (Object.keys(frags).length) this.actions.sendFragment(frags, id); }
                if (this.currentLineId && this.actions.sendLock) this.actions.sendLock({ lineId: this.currentLineId, userColor: this.user.color }, id);
                if (this.actions.sendIdentity) this.actions.sendIdentity({ color: this.user.color }, id);
            }

            handlePeerIdentity(data, pid) {
                let color = data && data.color ? data.color : null;
                if (!color || color === '#ffffff') {
                    color = '#ffffff' + (this.anonCounter > 0 ? this.anonCounter : '');
                    this.anonCounter++;
                }
                this.peerColors[pid] = color;
            }

            handleRemoteLock(data, pid) { this.activeLocks[pid] = { lineId: data.lineId, ts: Date.now(), color: data.userColor }; this.reapplyVisualLocks(); }

            reapplyVisualLocks() {
                document.querySelectorAll('.locked-line').forEach(el => {
                    el.classList.remove('locked-line'); el.style.removeProperty('--lock-color'); el.querySelector('.locked-tag')?.remove();
                    el.contentEditable = (el.dataset.owner && el.dataset.owner !== this.user.id) ? "false" : "true";
                });
                const now = Date.now();
                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000 || pid === selfId) continue;
                    const el = document.getElementById(lock.lineId);
                    if (el) { el.classList.add('locked-line'); el.style.setProperty('--lock-color', lock.color); el.contentEditable = "false"; el.insertAdjacentHTML('beforeend', `<div class="locked-tag">${lock.color}</div>`); }
                }
                this.renderMinimap();
            }

            renderMinimap() {
                const h = this.ui.chatContainer.scrollHeight, now = Date.now();
                this.ui.minimap.innerHTML = Object.entries(this.activeLocks).filter(([pid, lock]) => now - lock.ts <= 60000 && pid !== selfId).map(([_, lock]) => {
                    const el = document.getElementById(lock.lineId);
                    return el ? `<div class="scroll-dot" style="background:${lock.color};top:${(el.offsetTop / h) * 100}%" onclick="document.getElementById('${lock.lineId}').scrollIntoView({block:'center',behavior:'smooth'})"></div>` : '';
                }).join('');
            }

            async triggerSave(changedLineId = null) {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                const ids = Array.from(this.ui.display.children).map(el => el.id).filter(id => id);
                await this.db.saveRoom(this.user.color.replace('#', ''), ids, Object.fromEntries(ids.map(id => [id, document.getElementById(id)?.outerHTML])));
                if (changedLineId && this.room && this.actions.sendFragment) this.actions.sendFragment({ [changedLineId]: document.getElementById(changedLineId).outerHTML });
            }

            bindEvents() {
                this.ui.chatContainer.addEventListener('scroll', () => this.checkBuffers());
                window.addEventListener('resize', () => this.renderMinimap());
                
                // Logout Logic
                document.getElementById('freeze-btn').addEventListener('click', (e) => {
                    if (this.ui.dashboardPanel.classList.contains('active')) {
                        e.stopImmediatePropagation();
                        this.logout();
                    }
                });

                // Hover Logic
                const btn = document.getElementById('freeze-btn');
                const isSafe = (t) => t?.closest?.('#top-nav') || t?.closest?.('#freeze-btn') || t === this.ui.hoverTrigger;

                this.ui.hoverTrigger.addEventListener('mouseenter', () => this.ui.dashboardPanel.classList.add('revealed'));
                this.ui.hoverTrigger.addEventListener('mouseleave', (e) => { if (!isSafe(e.relatedTarget)) this.ui.dashboardPanel.classList.remove('revealed'); });

                this.ui.topNav.addEventListener('mouseenter', () => this.ui.dashboardPanel.classList.add('revealed'));
                this.ui.topNav.addEventListener('mouseleave', (e) => { if (!isSafe(e.relatedTarget)) this.ui.dashboardPanel.classList.remove('revealed'); });

                btn.addEventListener('mouseenter', () => this.ui.dashboardPanel.classList.add('revealed'));
                btn.addEventListener('mouseleave', (e) => { if (!isSafe(e.relatedTarget)) this.ui.dashboardPanel.classList.remove('revealed'); });

                this.ui.display.addEventListener('input', () => {
                    this.isFresh = false;
                    if (this.ui.display.children.length !== this.lastLineCount) { this.lastLineCount = this.ui.display.children.length; this.broadcastSkeleton(); }
                    for (let child of this.ui.display.children) if (!child.id || !child.classList.contains('editor-line')) { if (!child.id) child.id = this.makeId(); child.classList.add('editor-line'); }
                    const n = window.getSelection().anchorNode, line = (n.nodeType === 3 ? n.parentNode : n).closest('.editor-line');
                    if (line) { line.dataset.owner = this.user.id; line.style.setProperty('--owner-color', this.user.color); line.contentEditable = "true"; }
                    clearTimeout(this.saveTimeout); this.saveTimeout = setTimeout(() => this.triggerSave(line?.id), 500);
                });

                document.addEventListener('selectionchange', () => {
                    const s = window.getSelection(); if (!s.rangeCount) return;
                    const line = (s.anchorNode.nodeType === 3 ? s.anchorNode.parentNode : s.anchorNode).closest('.editor-line');
                    if (line && line.id) {
                        this.currentLineId = line.id; document.querySelectorAll('.my-line').forEach(e => e.classList.remove('my-line')); line.classList.add('my-line');
                        this.ui.tools.classList.toggle('visible', s.toString().length > 0);
                        if (this.actions.sendLock) this.actions.sendLock({ lineId: line.id, userColor: this.user.color });
                    }
                });
                ['bold', 'italic'].forEach(c => document.getElementById('btn-' + c).onclick = () => document.execCommand(c));
                document.getElementById('btn-link').onclick = () => { const u = prompt("URL:"); if (u) document.execCommand('createLink', false, u); };
            }
        }
        window.app = new EditorApp();
    </script>

<script type="module">
        let storageScope = window.localStorage;
        document.getElementById('login-btn').addEventListener('click', async () => {
            try { storageScope.setItem("lastSphereColor", document.getElementById('color-hex').innerText); } catch (e) { }
            if (window.enterRoomUI) window.enterRoomUI();
        });

        const Vec3 = { create: () => [0, 0, 0], add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s], dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2], cross: (a, b) => [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]], len: v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]), normalize: v => { const l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); return l > 0 ? [v[0] / l, v[1] / l, v[2] / l] : [0, 0, 0] }, dist: (a, b) => Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) };
        const Mat4 = {
            perspective: (f, a, n, fr) => { const nf = 1 / (n - fr), f_t = 1 / Math.tan(f / 2); return [f_t / a, 0, 0, 0, 0, f_t, 0, 0, 0, 0, (fr + n) * nf, -1, 0, 0, 2 * fr * n * nf, 0] },
            lookAt: (e, c, u) => { const z = Vec3.normalize(Vec3.sub(e, c)), x = Vec3.normalize(Vec3.cross(u, z)), y = Vec3.cross(z, x); return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -Vec3.dot(x, e), -Vec3.dot(y, e), -Vec3.dot(z, e), 1] },
            multiply: (a, b) => [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]],
            rotationX: r => [1, 0, 0, 0, 0, Math.cos(r), Math.sin(r), 0, 0, -Math.sin(r), Math.cos(r), 0, 0, 0, 0, 1],
            translation: v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1],
            scale: v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1],
            rotationAxis: (a, r) => { const c = Math.cos(r), s = Math.sin(r), t = 1 - c, x = a[0], y = a[1], z = a[2]; return [t * x * x + c, t * x * y + z * s, t * x * z - y * s, 0, t * x * y - z * s, t * y * y + c, t * y * z + x * s, 0, t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0, 0, 0, 0, 1] },
            identity: () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
        };

        const state = { canvas: null, device: null, context: null, pipelines: { sphere: null, cone: null }, buffers: {}, bindGroups: { sphere: null, cones: [] }, cameraPos: [0, 0, 4], sphere: { rotation: Mat4.identity(), indexCount: 0 }, cones: [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }], historyHandles: [], hasRotated: false, mouse: { x: 0, y: 0, down: false }, draggedConeIndex: -1, valueScrub: { active: false, coneIndex: -1, coordIndex: 0, startY: 0 }, lastTime: 0, clickData: { startX: 0, startY: 0, startTime: 0 }, landing: { active: false, progress: 0, rotationAxis: [1, 0, 0], rotationAngle: 0, baseRotation: Mat4.identity(), coneStartPositions: [], handleStartPos: [0, 0, 0], showHandle: false, startDist: 4.0, targetDist: 1.25, shouldAutoEnter: false }, dragStart: { active: false, mouseDir: [0, 0, 1], sphereRotation: null, conePositions: [], lastTrackPos: null }, inertia: { active: false, axis: [1, 0, 0], val: 0 }, handle: { active: false, pos: [0, 0, 0], color: [1, 1, 1] }, msaaTexture: null, depthTexture: null, sampleCount: 4, presentationFormat: null, debugMode: false, uiCache: [], vpMatrix: Mat4.identity(), returning: null, uniforms: { sphere: new Float32Array(80), cone: new Float32Array(20) } };

        function rgbToHex(r, g, b) { return '#' + [r, g, b].map(x => Math.round(Math.min(1, Math.max(0, x)) * 255).toString(16).padStart(2, '0')).join(''); }
        function hexToRgbNormalized(hex) { const bigint = parseInt(hex.replace(/^#/, '').replace(/^([a-f\d])([a-f\d])([a-f\d])$/i, '$1$1$2$2$3$3'), 16); return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255]; }

        const sphereShaderWGSL = `struct Uniforms{mvp:mat4x4<f32>,model:mat4x4<f32>,normalMatrix:mat4x4<f32>,viewPos:vec3<f32>,l1:vec3<f32>,c1:vec3<f32>,l2:vec3<f32>,c2:vec3<f32>,l3:vec3<f32>,c3:vec3<f32>,debug:f32,};@group(0) @binding(0) var<uniform> u:Uniforms;struct VI{@location(0) p:vec3<f32>,@location(1) n:vec3<f32>};struct VO{@builtin(position) P:vec4<f32>,@location(0) vP:vec3<f32>,@location(1) vN:vec3<f32>};@vertex fn vs_main(i:VI)->VO{var o:VO;o.P=u.mvp*vec4<f32>(i.p,1.0);o.vP=(u.model*vec4<f32>(i.p,1.0)).xyz;o.vN=(u.normalMatrix*vec4<f32>(i.n,0.0)).xyz;return o;}fn ACES(x:vec3<f32>)->vec3<f32>{let a=2.51;let b=0.03;let c=2.43;let d=0.59;let e=0.14;return clamp((x*(a*x+b))/(x*(c*x+d)+e),vec3<f32>(0.0),vec3<f32>(1.0));}fn getI(lp:vec3<f32>,N:vec3<f32>,fp:vec3<f32>)->f32{let L=normalize(lp-fp);let distSq=dot(lp-fp,lp-fp);return pow(max(dot(N,L)+1.0,0.0)/2.0,2.5)*(1.0/(1.0+distSq*0.05));}@fragment fn fs_main(i:VO)->@location(0) vec4<f32>{let N=normalize(i.vN);if(u.debug > 0.5){let L1=normalize(u.l1-i.vP);let L2=normalize(u.l2-i.vP);let L3=normalize(u.l3-i.vP);if(dot(N,L1)>0.0 && dot(N,L2)>0.0 && dot(N,L3)>0.0){return vec4<f32>(1.0,0.0,0.0,1.0);}}let d1=getI(u.l1,N,i.vP);let d2=getI(u.l2,N,i.vP);let d3=getI(u.l3,N,i.vP);var l=(u.c1*d1)+(u.c2*d2)+(u.c3*d3);let ep=0.001;l=l+((u.c1+u.c2)*2.0*d1*d2/(d1+d2+ep)*1.8)+((u.c2+u.c3)*2.0*d2*d3/(d2+d3+ep)*1.8)+((u.c3+u.c1)*2.0*d3*d1/(d3+d1+ep)*1.8);let m=pow(min(d1,min(d2,d3)),6.0);l=l+(vec3<f32>(1.0)*m*80.0);l=max(l-vec3<f32>(0.01),vec3<f32>(0.0))*2.0;return vec4<f32>(pow(ACES(l),vec3<f32>(1.0/2.2)),1.0);}`;
        const coneShaderWGSL = `struct U{mvp:mat4x4<f32>,c:vec3<f32>};@group(0) @binding(0) var<uniform> u:U;@vertex fn vs_main(@location(0) p:vec3<f32>)->@builtin(position) vec4<f32>{return u.mvp*vec4<f32>(p,1.0);}@fragment fn fs_main()->@location(0) vec4<f32>{return vec4<f32>(u.c,1.0);}`;
        const defaultCones = [{ color: [1, 0, 0], pos: [0, .98, .69], active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], active: true }];

        function findPositionFromColor(targetHex) {
            const t = hexToRgbNormalized(targetHex); let bd = Infinity, bp = null;
            for (let la = 0; la <= 30; la++) for (let lo = 0; lo <= 30; lo++) {
                const th = la * Math.PI / 30, ph = lo * 2 * Math.PI / 30, pos = [Math.cos(ph) * Math.sin(th), Math.cos(th), Math.sin(ph) * Math.sin(th)];
                const c = getSurfaceColor(pos, pos, defaultCones), d = Math.sqrt((c[0] - t[0]) ** 2 + (c[1] - t[1]) ** 2 + (c[2] - t[2]) ** 2);
                if (d < bd) { bd = d; bp = pos; }
                if (d < 0.05) return bp;
            } return bp;
        }

        async function init() {
            state.canvas = document.getElementById('gpu-canvas');
            if (!navigator.gpu) return alert("WebGPU not supported!");
            const adapter = await navigator.gpu.requestAdapter(); state.device = await adapter.requestDevice();
            state.context = state.canvas.getContext('webgpu'); state.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            state.context.configure({ device: state.device, format: state.presentationFormat, alphaMode: 'premultiplied' });

            const rooms = await (new window.ColorDB()).getAllRooms();
           
            state.historyHandles = [];
            await createAssets();
            window.addEventListener('resize', onResize); onResize();
            state.canvas.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
            state.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e.changedTouches[0]) });
            document.getElementById('freeze-btn').addEventListener('click', toggleFreeze);

            document.getElementById('debug-btn').onclick = function () {
                state.debugMode = !state.debugMode; this.classList.toggle('active', state.debugMode);
                this.innerText = state.debugMode ? "DEBUG ON" : "DEBUG OFF"; document.getElementById('debug-panel').classList.toggle('visible', state.debugMode);
            };
            document.getElementById('reset-btn').onclick = async () => { if (confirm("Permanently wipe all local data?")) { localStorage.clear(); try { const dbs = await window.indexedDB.databases(); for (const db of dbs) { await window.indexedDB.deleteDatabase(db.name); } } catch (e) { } window.location.reload(); } };

            state.cones.forEach((c, i) => {
                const el = document.getElementById(`data-${i}`);
                if (!el) return;
                el.innerHTML = `<span class="cone-title" id="title-${i}">${c.name}</span> <span style="color:#666">X</span> <span class="coord-val" id="x-${i}">0.00</span> <span style="color:#666">Y</span> <span class="coord-val" id="y-${i}">0.00</span> <span style="color:#666">Z</span> <span class="coord-val" id="z-${i}">0.00</span>`;
                const title = document.getElementById(`title-${i}`);
                title.addEventListener('click', (e) => { if (!document.body.classList.contains('light-mode')) { e.stopPropagation(); state.cones[i].active = !state.cones[i].active; } });
                ['x', 'y', 'z'].forEach((ax, idx) => document.getElementById(`${ax}-${i}`).addEventListener('mousedown', (e) => { if (!document.body.classList.contains('light-mode')) { e.preventDefault(); e.stopPropagation(); state.valueScrub = { active: true, coneIndex: i, coordIndex: idx, startY: e.clientY }; } }));
                state.uiCache[i] = { title, x: document.getElementById(`x-${i}`), y: document.getElementById(`y-${i}`), z: document.getElementById(`z-${i}`), lastPos: [null, null, null], lastActive: null };
            });

            setupColorTooltip();
            if (window.location.hash && window.location.hash.length > 1) { const matchPos = findPositionFromColor(window.location.hash); if (matchPos) triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(window.location.hash), true); }
            requestAnimationFrame(loop);
        }

        async function createAssets() {
            const dev = state.device, sphereGeo = createSphere(1.0, 128, 128), coneGeo = createCone(0.1, 0.3, 64);
            state.buffers.sphereVertex = createBuffer(dev, sphereGeo.p, GPUBufferUsage.VERTEX); state.buffers.sphereNormal = createBuffer(dev, sphereGeo.n, GPUBufferUsage.VERTEX); state.buffers.sphereIndex = createBuffer(dev, sphereGeo.i, GPUBufferUsage.INDEX); state.sphere.indexCount = sphereGeo.i.length;
            state.buffers.coneVertex = createBuffer(dev, coneGeo.p, GPUBufferUsage.VERTEX); state.buffers.coneIndex = createBuffer(dev, coneGeo.i, GPUBufferUsage.INDEX); state.coneIndexCount = coneGeo.i.length;
            state.buffers.sphereUniform = dev.createBuffer({ size: 320, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            state.buffers.coneUniform = dev.createBuffer({ size: 65536, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const sm = dev.createShaderModule({ code: sphereShaderWGSL }), cm = dev.createShaderModule({ code: coneShaderWGSL });
            state.pipelines.sphere = dev.createRenderPipeline({ layout: 'auto', vertex: { module: sm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }, { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }] }, fragment: { module: sm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } });
            state.pipelines.cone = dev.createRenderPipeline({ layout: 'auto', vertex: { module: cm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }] }, fragment: { module: cm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } });
            state.bindGroups.sphere = dev.createBindGroup({ layout: state.pipelines.sphere.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.sphereUniform } }] });
            state.getBindGroupForHandle = (idx) => dev.createBindGroup({ layout: state.pipelines.cone.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.coneUniform, offset: idx * 256, size: 80 } }] });
            state.bindGroups.cones = [0, 1, 2, 3].map(i => state.getBindGroupForHandle(i));
        }

        function createBuffer(dev, data, usage) { const buf = dev.createBuffer({ size: data.byteLength, usage: usage | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); (data instanceof Float32Array ? new Float32Array(buf.getMappedRange()) : new Uint16Array(buf.getMappedRange())).set(data); buf.unmap(); return buf; }
        function createSphere(r, latB, longB) { const p = [], n = [], idx = []; for (let la = 0; la <= latB; la++) for (let lo = 0; lo <= longB; lo++) { const th = la * Math.PI / latB, ph = lo * 2 * Math.PI / longB, x = Math.cos(ph) * Math.sin(th), y = Math.cos(th), z = Math.sin(ph) * Math.sin(th); n.push(x, y, z); p.push(r * x, r * y, r * z); } for (let la = 0; la < latB; la++) for (let lo = 0; lo < longB; lo++) { const f = (la * (longB + 1)) + lo, s = f + longB + 1; idx.push(f, f + 1, s, s, f + 1, s + 1); } return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function createCone(r, h, s) { const p = [0, h, 0], n = [0, 1, 0], idx = []; for (let i = 0; i <= s; i++) { const th = i * 2 * Math.PI / s, x = r * Math.cos(th), z = r * Math.sin(th); p.push(x, 0, z); const nv = Vec3.normalize([x, .5, z]); n.push(nv[0], nv[1], nv[2]); } p.push(0, 0, 0); n.push(0, -1, 0); const bc = p.length / 3 - 1; for (let i = 1; i <= s; i++) idx.push(0, i, i + 1, bc, i + 1, i); return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        
        function onResize() {
            if (!state.device) return;
            const w = state.canvas.clientWidth;
            const h = state.canvas.clientHeight;
            state.canvas.width = w; state.canvas.height = h;
            if (state.msaaTexture) state.msaaTexture.destroy();
            if (state.depthTexture) state.depthTexture.destroy();
            state.msaaTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: state.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT });
            state.depthTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: 'depth24plus', usage: GPUTextureUsage.RENDER_ATTACHMENT });

            const aspect = w / h;
            const newZ = aspect < 1 ? 3.5 / aspect : 4;
            
            if (!state.landing.active && (!state.returning || !state.returning.active)) {
                state.cameraPos = [0, 0, newZ];
            }
            if (state.returning) state.returning.targetDist = newZ;
        }

        function getMouseRay(x, y) { const aspect = state.canvas.width / state.canvas.height, ndcX = (x / state.canvas.width) * 2 - 1, ndcY = -(y / state.canvas.height) * 2 + 1; const dir = Vec3.normalize([ndcX * aspect * Math.tan(Math.PI / 8), ndcY * Math.tan(Math.PI / 8), -1]); return { o: state.cameraPos, d: dir }; }
        function getTargetPos(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)); return Vec3.dot(p, p) <= 1 ? Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))) : Vec3.scale(Vec3.normalize(p), 1); }
        function calculateConePosition(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)), dist = Math.sqrt(Vec3.dot(p, p)), R = 1.2; if (dist <= R) return Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(R * R - Vec3.dot(p, p)))); const axis = Vec3.cross(Vec3.normalize(r.o), r.d); return Vec3.scale(transformPos(Vec3.normalize(r.o), Mat4.rotationAxis(Vec3.normalize(Vec3.len(axis) < .001 ? [1, 0, 0] : axis), Math.acos(R / Vec3.len(r.o)) + (dist - R))), R); }
        function transformPos(p, m) { return [m[0] * p[0] + m[4] * p[1] + m[8] * p[2] + m[12], m[1] * p[0] + m[5] * p[1] + m[9] * p[2] + m[13], m[2] * p[0] + m[6] * p[1] + m[10] * p[2] + m[14]]; }
        function projectToScreen(worldPos) { const m = state.vpMatrix, x = worldPos[0], y = worldPos[1], z = worldPos[2], clipX = x * m[0] + y * m[4] + z * m[8] + m[12], clipY = x * m[1] + y * m[5] + z * m[9] + m[13], clipW = x * m[3] + y * m[7] + z * m[11] + m[15]; if (clipW <= 0) return null; return { x: (clipX / clipW + 1) * state.canvas.width / 2, y: (1 - clipY / clipW) * state.canvas.height / 2 }; }

        function onMouseDown(e) {
            if (state.valueScrub.active) return;
            const rect = state.canvas.getBoundingClientRect();
            state.mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top, down: true };
            state.clickData = { startX: state.mouse.x, startY: state.mouse.y, startTime: Date.now() };
            if (document.body.classList.contains('light-mode')) {
                state.inertia.val = 0; 
                const p = getTargetPos(state.mouse.x, state.mouse.y), r = getMouseRay(state.mouse.x, state.mouse.y);
                if (Vec3.dot(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))), Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)))) <= 1) {
                    state.dragStart = { active: true, mouseDir: Vec3.normalize(p), sphereRotation: [...state.sphere.rotation], conePositions: state.cones.map(c => [...c.pos]), lastTrackPos: p };
                    state.handle = { active: true, pos: p, color: getSurfaceColor(p, Vec3.normalize(p)) };
                    state.hasRotated = true;
                }
            }
        }
        function onMouseMove(e) { const r = state.canvas.getBoundingClientRect(); state.mouse.x = e.clientX - r.left; state.mouse.y = e.clientY - r.top; }
       function onMouseUp(e) {
            state.mouse.down = false;
            state.handle.active = false;
            if (state.valueScrub.active) {
                state.valueScrub.active = false;
                return;
            }
            if (document.body.classList.contains('light-mode')) {
                const rect = state.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;
                if (Math.sqrt((mx - state.clickData.startX) ** 2 + (my - state.clickData.startY) ** 2) < 5 && Date.now() - state.clickData.startTime < 250) {
                    for (let h of state.historyHandles) {
                        const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                        if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 30) {
                            try { localStorage.setItem("lastSphereColor", h.hex); } catch (e) { }
                            triggerLanding(h.pos, transformPos(h.pos, state.sphere.rotation), h.color, true);
                            return;
                        }
                    }
                    const r = getMouseRay(mx, my),
                        p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)));
                    if (Vec3.dot(p, p) <= 1) {
                        const hp = Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p))));
                        triggerLanding(Vec3.normalize(hp), hp, getSurfaceColor(hp, Vec3.normalize(hp)), false);
                    }
                }
            }
        }

        function triggerLanding(norm, pos, col, fromUrl = false) {
            state.landing = { active: true, progress: 0, baseRotation: [...state.sphere.rotation], startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]), handleStartPos: [...pos], showHandle: true, targetDist: 1.25, shouldAutoEnter: fromUrl }; state.handle.color = [...col]; state.hasRotated = true;
            const hex = rgbToHex(col[0], col[1], col[2]); document.getElementById('color-hex').innerText = hex.toUpperCase();
            const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white';
            document.getElementById('login-card').style.color = textColor; document.getElementById('top-nav').style.setProperty('--nav-color', textColor);
            const cam = Vec3.normalize(state.cameraPos), axis = Vec3.cross(norm, cam), dot = Vec3.dot(norm, cam);
            state.landing.rotationAxis = Vec3.len(axis) < .001 ? [1, 0, 0] : Vec3.normalize(axis); state.landing.rotationAngle = Vec3.len(axis) < .001 ? (dot > 0 ? 0 : Math.PI) : Math.acos(Math.min(1, Math.max(-1, dot)));
            if (window.connectAndPreview) window.connectAndPreview(hex, fromUrl);
        }

        function getResponsiveZ() {
            const aspect = state.canvas.width / state.canvas.height;
            return aspect < 1 ? 3.5 / aspect : 4;
        }

        function toggleFreeze() {
            if (document.getElementById('dashboard-panel').classList.contains('active')) return;

            const f = document.getElementById('flash-overlay'), isFrozen = document.body.classList.toggle('light-mode');
            state.landing = { active: false, showHandle: false };
            document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active');
            state.cameraPos = [0, 0, getResponsiveZ()];
            f.style.backgroundColor = isFrozen ? 'white' : 'black'; document.body.style.backgroundColor = '';
            f.classList.remove('active'); void f.offsetWidth; f.classList.add('active'); setTimeout(() => f.classList.remove('active'), 0);
        }

        function getSurfaceColor(p, n, cones = state.cones) {
            const getI = (i) => cones[i].active ? Math.pow(Math.max(Vec3.dot(n, Vec3.normalize(Vec3.sub(cones[i].pos, p))) + 1, 0) / 2, 2.5) * (1 / (1 + Vec3.dot(Vec3.sub(cones[i].pos, p), Vec3.sub(cones[i].pos, p)) * .05)) : 0;
            const d = [getI(0), getI(1), getI(2)], c = cones.map(x => x.color);
            let l = Vec3.add(Vec3.add(Vec3.scale(c[0], d[0]), Vec3.scale(c[1], d[1])), Vec3.scale(c[2], d[2])), m = Math.pow(Math.min(d[0], Math.min(d[1], d[2])), 6);
            l = Vec3.add(l, Vec3.add(Vec3.scale(Vec3.add(c[0], c[1]), 2 * d[0] * d[1] / (d[0] + d[1] + .001) * 1.8), Vec3.add(Vec3.scale(Vec3.add(c[1], c[2]), 2 * d[1] * d[2] / (d[1] + d[2] + .001) * 1.8), Vec3.scale(Vec3.add(c[2], c[0]), 2 * d[2] * d[0] / (d[2] + d[0] + .001) * 1.8))));
            l = Vec3.scale(Vec3.add(l, [m * 80, m * 80, m * 80]), 2);
            const r = (x) => (x * (2.51 * x + .03)) / (x * (2.43 * x + .59) + .14); return [Math.pow(r(Math.max(l[0] - .01, 0)), 1 / 2.2), Math.pow(r(Math.max(l[1] - .01, 0)), 1 / 2.2), Math.pow(r(Math.max(l[2] - .01, 0)), 1 / 2.2)];
        }

        function setupColorTooltip() {
            const t = document.createElement('div'); t.className = 'sphere-tooltip'; document.body.appendChild(t);
            window.addEventListener('mousemove', e => {
                if (!document.body.classList.contains('light-mode') || e.target.closest('#dashboard-panel') || e.target.closest('#login-card') || e.target.closest('#top-nav')) { t.style.display = 'none'; return; }
                const rect = state.canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top;
                for (let h of state.historyHandles) {
                    const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                    if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 30) {
                        t.innerHTML = `<span class="hex">${h.hex.toUpperCase()}</span><span class="${h.peerCount > 0 ? "meta online" : "meta"}">${h.peerCount > 0 ? `${h.peerCount} PEER${h.peerCount > 1 ? 'S' : ''} ONLINE` : "OFFLINE"}</span>`;
                        t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${h.hex}`; return;
                    }
                }
                const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)));
                if (Vec3.dot(p, p) > 1) { t.style.display = 'none'; return; }
                const hex = rgbToHex(...getSurfaceColor(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p)))), Vec3.normalize(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p))))))).toUpperCase();
                t.innerHTML = `<span class="hex">${hex}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${hex}`;
            });
        }

        window.resetSphereView = function () {
            const m = state.sphere.rotation, trace = m[0] + m[5] + m[10];
            let angle = Math.acos(Math.max(-1, Math.min(1, (trace - 1) / 2))), axis = [1, 0, 0], diff = [m[6] - m[9], m[8] - m[2], m[1] - m[4]], sl = Math.sqrt(diff[0] ** 2 + diff[1] ** 2 + diff[2] ** 2);
            if (sl > 0.001) axis = [diff[0] / sl, diff[1] / sl, diff[2] / sl];
            state.returning = { active: true, progress: 0, baseRotation: m, rotationAxis: axis, rotationAngle: -angle, startDist: Vec3.len(state.cameraPos), targetDist: getResponsiveZ(), coneStartPositions: state.cones.map(c => [...c.pos]) };
            state.landing.active = false;
        };

        function loop(ts) {
            const dt = Math.min((ts - state.lastTime) / 1000, 0.1); state.lastTime = ts;
            if (document.body.classList.contains('light-mode') && state.hasRotated) document.body.style.backgroundColor = rgbToHex(...getSurfaceColor([0, 0, 1], [0, 0, 1]));
            if (state.valueScrub.active && Math.abs(state.valueScrub.startY - state.mouse.y) > 5) state.cones[state.valueScrub.coneIndex].pos[state.valueScrub.coordIndex] += Math.sign(state.valueScrub.startY - state.mouse.y) * Math.pow((Math.abs(state.valueScrub.startY - state.mouse.y) - 5) / 500, 3) * .05;

            if (state.landing.active) {
                state.landing.progress = Math.min(state.landing.progress + dt * .5, 1);
                if (state.landing.progress >= 1) { 
                    document.getElementById('login-card').classList.add('visible'); 
                    state.landing.showHandle = false; 
                    if (state.landing.shouldAutoEnter) {
                        if (window.enterRoomUI) window.enterRoomUI();
                        state.landing.shouldAutoEnter = false;
                    }
                }
                const t = state.landing.progress, rot = Mat4.rotationAxis(state.landing.rotationAxis, state.landing.rotationAngle * t * t);
                state.sphere.rotation = Mat4.multiply(rot, state.landing.baseRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.landing.coneStartPositions[i], rot));
                if (state.landing.showHandle) state.handle.pos = transformPos(state.landing.handleStartPos, rot);
                state.cameraPos = Vec3.scale(Vec3.normalize([0, 0, 4]), state.landing.startDist + (state.landing.targetDist - state.landing.startDist) * t * t * t);
            }
            if (state.returning && state.returning.active) {
                state.returning.progress = Math.min(state.returning.progress + dt * 1.5, 1);
                const t = state.returning.progress, ease = 1 - Math.pow(1 - t, 3), rot = Mat4.rotationAxis(state.returning.rotationAxis, state.returning.rotationAngle * ease);
                state.sphere.rotation = Mat4.multiply(rot, state.returning.baseRotation); state.cameraPos = [0, 0, state.returning.startDist + (state.returning.targetDist - state.returning.startDist) * ease];
                state.cones.forEach((c, i) => c.pos = transformPos(state.returning.coneStartPositions[i], rot));
                if (t >= 1) {
                    state.returning.active = false; state.hasRotated = false; state.sphere.rotation = Mat4.identity();
                    state.cones = [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }];
                    state.cameraPos = [0, 0, getResponsiveZ()]; document.body.style.backgroundColor = ''; document.getElementById('color-hex').innerText = "#FFFFFF";
                    document.getElementById('login-card').style.color = ''; document.getElementById('top-nav').style.removeProperty('--nav-color');
                }
            }

            state.vpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .1, 100), Mat4.lookAt(state.cameraPos, [0, 0, 0], [0, 1, 0]));
            if (!document.body.classList.contains('light-mode')) {
                state.cones.forEach((c, i) => { const cache = state.uiCache[i]; if (!cache) return; if (cache.lastActive !== c.active) { cache.title.style.color = c.active ? c.cssColor : 'grey'; cache.lastActive = c.active; } ['x', 'y', 'z'].forEach((ax, idx) => { if (Math.abs(c.pos[idx] - cache.lastPos[idx]) > 0.005) { cache[ax].innerText = c.pos[idx].toFixed(2); cache.lastPos[idx] = c.pos[idx]; } }); });
                if (state.mouse.down) {
                    const tp = getTargetPos(state.mouse.x, state.mouse.y);
                    if (state.draggedConeIndex === -1 && tp) state.cones.forEach((c, i) => { if (c.active && Vec3.dist(c.pos, tp) < 0.8) state.draggedConeIndex = i; });
                    if (state.draggedConeIndex !== -1) { const np = calculateConePosition(state.mouse.x, state.mouse.y), c = state.cones[state.draggedConeIndex]; c.vel = Vec3.scale(Vec3.sub(np, c.pos), 1 / dt); c.pos = np; }
                } else state.draggedConeIndex = -1;
                state.cones.forEach(c => { if (state.draggedConeIndex === -1 || state.cones[state.draggedConeIndex] !== c) { if (Vec3.len(c.vel) > .001) { c.pos = Vec3.scale(Vec3.normalize(Vec3.add(c.pos, Vec3.scale(c.vel, dt))), 1.2); c.vel = Vec3.scale(c.vel, .95); } else c.pos = Vec3.scale(Vec3.normalize(c.pos), 1.2); } });
            } else if (state.mouse.down && state.dragStart.active) {
                state.landing.active = false; state.landing.showHandle = false; document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active');
                const tp = getTargetPos(state.mouse.x, state.mouse.y);
                if (tp) { 
                    state.handle.pos = tp; 
                    if(state.dragStart.lastTrackPos) {
                        const axis = Vec3.cross(state.dragStart.lastTrackPos, tp);
                        state.inertia = { active: false, axis: Vec3.len(axis) > 1e-5 ? Vec3.normalize(axis) : [1,0,0], val: Vec3.len(axis) };
                    }
                    state.dragStart.lastTrackPos = tp;

                    const a = Vec3.cross(state.dragStart.mouseDir, Vec3.normalize(tp)); if (Vec3.len(a) > .001) { const r = Mat4.rotationAxis(Vec3.normalize(a), Math.acos(Math.min(1, Math.max(-1, Vec3.dot(state.dragStart.mouseDir, Vec3.normalize(tp)))))); state.sphere.rotation = Mat4.multiply(r, state.dragStart.sphereRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.dragStart.conePositions[i], r)); } 
                }
            } else { 
                state.dragStart.active = false; state.handle.active = false; 
                if (state.inertia.val > 0.0001) {
                    const r = Mat4.rotationAxis(state.inertia.axis, state.inertia.val);
                    state.sphere.rotation = Mat4.multiply(r, state.sphere.rotation);
                    state.cones.forEach(c => c.pos = transformPos(c.pos, r));
                    state.inertia.val *= 0.95; // CHANGE THIS NUMBER to adjust stickiness
                }
            }

            if (state.device && state.pipelines.sphere && state.msaaTexture) {
                const enc = state.device.createCommandEncoder(), pass = enc.beginRenderPass({ colorAttachments: [{ view: state.msaaTexture.createView(), resolveTarget: state.context.getCurrentTexture().createView(), clearValue: document.body.classList.contains('light-mode') ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, g: 0, b: 0, a: 1 }, loadOp: 'clear', storeOp: 'discard' }], depthStencilAttachment: { view: state.depthTexture.createView(), depthClearValue: 1, depthLoadOp: 'clear', depthStoreOp: 'discard' } });
                state.uniforms.sphere.set(Mat4.multiply(state.vpMatrix, state.sphere.rotation), 0); state.uniforms.sphere.set(state.sphere.rotation, 16); state.uniforms.sphere.set(state.sphere.rotation, 32); state.uniforms.sphere.set(state.cameraPos, 48);
                [0, 1, 2].forEach(i => { state.uniforms.sphere.set(state.cones[i].pos, 52 + i * 8); state.uniforms.sphere.set(state.cones[i].active ? state.cones[i].color : [0, 0, 0], 56 + i * 8); });
                state.uniforms.sphere[76] = state.debugMode ? 1.0 : 0.0;
                state.device.queue.writeBuffer(state.buffers.sphereUniform, 0, state.uniforms.sphere);
                pass.setPipeline(state.pipelines.sphere); pass.setBindGroup(0, state.bindGroups.sphere); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setVertexBuffer(1, state.buffers.sphereNormal); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16'); pass.drawIndexed(state.sphere.indexCount);

                pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, document.body.classList.contains('light-mode') ? state.buffers.sphereVertex : state.buffers.coneVertex); pass.setIndexBuffer(document.body.classList.contains('light-mode') ? state.buffers.sphereIndex : state.buffers.coneIndex, 'uint16');

                if (!document.body.classList.contains('light-mode')) {
                    state.cones.forEach((c, i) => {
                        if (c.active) {
                            let m; if (Vec3.len(Vec3.cross([0, 1, 0], c.pos)) > .001) { const y = Vec3.normalize(c.pos), x = Vec3.normalize(Vec3.cross(Vec3.len(Vec3.cross([0, 1, 0], y)) < .01 ? [0, 0, 1] : [0, 1, 0], y)), z = Vec3.cross(x, y); m = [x[0], x[1], x[2], 0, y[0], y[1], y[2], 0, z[0], z[1], z[2], 0, c.pos[0], c.pos[1], c.pos[2], 1]; } else m = Mat4.multiply(Mat4.translation(c.pos), c.pos[1] < 0 ? Mat4.rotationX(Math.PI) : Mat4.identity());
                            state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(m, Mat4.scale([.5, .5, .5]))), 0); state.uniforms.cone.set(c.color, 16);
                            state.device.queue.writeBuffer(state.buffers.coneUniform, i * 256, state.uniforms.cone); pass.setBindGroup(0, state.bindGroups.cones[i]); pass.drawIndexed(state.coneIndexCount);
                        }
                    });
                } else {
                    let bindIdx = 4;
                    if (state.handle.active || state.landing.showHandle) {
                        state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(state.handle.pos), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set(state.handle.color, 16);
                        state.device.queue.writeBuffer(state.buffers.coneUniform, 3 * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(3)); pass.drawIndexed(state.sphere.indexCount);
                    }
                    state.historyHandles.forEach(h => {
                        const wp = transformPos(h.pos, state.sphere.rotation);
                        if (wp[2] > -0.5) {
                            state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(wp), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set(h.color, 16);
                            state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.drawIndexed(state.sphere.indexCount); bindIdx++;
                        }
                    });
                }
                pass.end(); state.device.queue.submit([enc.finish()]);
            }
            requestAnimationFrame(loop);
        }
        init();

        window.updateVisitedFromDB = async function () {
            const rooms = await (new window.ColorDB()).getAllRooms();
            state.historyHandles = [];
            if (rooms?.length) {
                rooms.forEach(r => { const p = findPositionFromColor('#' + r.hex); if (p) state.historyHandles.push({ pos: Vec3.normalize(p), color: hexToRgbNormalized('#' + r.hex), hex: '#' + r.hex, peerCount: 0 }); });
            }
        };

        window.addEventListener("message", (e) => {
            if (e.data === "getSphereColor") e.source.postMessage(storageScope.getItem("lastSphereColor") || "#ff0000", e.origin);
            if (e.data?.type === 'handle-ready') {
                const hex = e.data.hex, pos = findPositionFromColor(hex);
                if (pos && !state.historyHandles.some(h => h.hex === hex)) {
                    state.historyHandles.push({ pos: Vec3.normalize(pos), color: hexToRgbNormalized(hex), hex, peerCount: e.data.count });
                    const d = document.createElement('div'); d.className = 'debug-room-item ' + (e.data.count > 0 ? 'active' : ''); d.innerHTML = `<span>${hex}</span> <span class="count">${e.data.count} peer(s)</span>`; document.getElementById('debug-rooms').appendChild(d);
                }
            }
        });

        async function initStorageAccess() {
            if (window.self === window.top) return;
            const access = async (h) => {
                try {
                    if (h?.localStorage) storageScope = h.localStorage;
                    const c = storageScope.getItem("lastSphereColor");
                    if (c) { window.parent.postMessage(c, "*"); if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').innerHTML = `<div style="font-family:sans-serif; color:green; font-weight:bold; text-align:center;">Synced: ${c}</div>`; document.body.style.backgroundColor = c; }
                    else if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove();
                } catch (e) { }
            };
            try {
                if (await document.hasStorageAccess()) try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { access(null); }
                else {
                    const o = document.createElement('div'); o.id = 'saa-overlay'; Object.assign(o.style, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: '#fff', zIndex: 10000, display: 'flex', justifyContent: 'center', alignItems: 'center' });
                    const b = document.createElement("button"); b.innerText = "ðŸ”Œ Connect to Sphere"; Object.assign(b.style, { padding: "12px 24px", fontSize: "16px", cursor: "pointer", background: "#000", color: "#fff", border: "none", borderRadius: "8px" });
                    o.appendChild(b); document.body.appendChild(o); b.onclick = async () => { try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { o.innerHTML = "Access Denied"; } };
                }
            } catch (e) { }
        }
        initStorageAccess();
    </script>
</body>

</html>
