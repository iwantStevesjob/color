<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Color</title>

    <style>
        :root {
            --bg-color: #000;
            --text-color: #fff;
            --ui-bg: rgba(255, 255, 255, 0.1);
            --ui-border: rgba(255, 255, 255, 0.2);
            --nav-color: white;
            --tracker-bg: rgba(0, 0, 0, 0.75);
            --nav-height: 90px;
            --sub-nav-height: 150px;
            --sliver-height: 10px;
        }

        body.light-mode {
            --bg-color: #f0f0f0;
            --text-color: #000;
            --ui-bg: rgba(0, 0, 0, 0.1);
            --ui-border: rgba(0, 0, 0, 0.2);
            --nav-color: black;
            --tracker-bg: transparent;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.1s linear;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            /* Important for touch events */
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease-out;
        }

        #flash-overlay.active {
            opacity: 1;
            transition: none;
        }

        #login-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.5s ease, visibility 0s linear 0.5s;
            color: inherit;
        }

        #login-card.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.5s ease;
        }

        #color-hex {
            font-size: 5rem;
            font-weight: 900;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: -2px;
            line-height: 1;
        }

        #room-status {
            font-family: 'Menlo', monospace;
            font-size: 0.9rem;
            margin: 15px 0 25px 0;
            opacity: 0.7;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-height: 1.2em;
            font-weight: bold;
        }

        #login-btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 12px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            text-decoration: none;
        }

        #login-btn:hover {
            background: currentColor;
            opacity: 0.8;
        }

        #login-btn:hover span {
            filter: invert(1);
        }

        #login-btn.hidden {
            display: none;
        }

        #hover-trigger {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--sliver-height);
            z-index: 300;
            display: none;
        }

        #top-nav {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--nav-height);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            z-index: 150;
            opacity: 0;
            pointer-events: none;
        }

        #top-nav.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-item {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            opacity: 0.5;
            transition: 0.2s;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--nav-color);
            border-bottom: 2px solid transparent;
            padding-bottom: 2px;
        }

        .nav-item:hover,
        .nav-item.active {
            opacity: 1;
        }

        .nav-item.active {
            border-bottom-color: var(--nav-color);
        }

        #sub-nav-layer {
            position: fixed;
            top: var(--nav-height);
            left: 0;
            width: 100%;
            height: var(--sub-nav-height);
            z-index: 140;
            pointer-events: none;
        }

        .sub-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 10px 40px 0 40px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            opacity: 0;
            transition: opacity 0s;
        }

        .sub-header.active {
            opacity: 1;
            pointer-events: auto;
        }

        .page-title {
            font-size: 3rem;
            font-weight: 900;
            margin: 0 0 15px 0;
            letter-spacing: -1px;
            color: var(--text-color);
        }

        .tabs-row {
            display: flex;
            gap: 2px;
            width: 100%;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .tabs-row::-webkit-scrollbar {
            display: none;
        }

        .sub-tab {
            padding: 12px 24px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.2s ease;
            user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .sub-tab:hover {
            color: white;
            background: rgba(0, 0, 0, 0.7);
        }

        .sub-tab.active {
            background: white;
            color: black;
            cursor: default;
        }

        #dashboard-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 200;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            will-change: transform;
        }

        #dashboard-panel.active {
            transform: translateY(var(--sliver-height));
        }

        #dashboard-panel.active.revealed {
            transform: translateY(var(--nav-height));
        }

        #dashboard-panel.active.step-down {
            transform: translateY(calc(var(--nav-height) + var(--sub-nav-height)));
        }

        /* Peek Mode logic */
        #dashboard-panel.active.peek-mode {
            transform: translateY(calc(100% - 50px));
            /* Leaves header visible */
        }

        .content-view {
            flex: 1;
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .content-view.active {
            display: flex;
        }

        .settings-pane,
        .apps-pane {
            display: none;
            padding: 40px;
            color: #333;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        .settings-pane.active,
        .apps-pane.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #tools {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            padding: 10px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 205;
        }

        #tools.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #tools button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            background: #444;
            color: white;
            font-weight: bold;
        }

        #debug-btn,
        #freeze-btn {
            position: absolute;
            background: var(--ui-bg);
            color: var(--text-color);
            border: 1px solid var(--ui-border);
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            z-index: 180;
        }

        #debug-btn {
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Menlo', monospace;
            font-size: 0.8rem;
        }

        #debug-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #debug-btn.active {
            background: rgba(255, 0, 0, 0.5);
            border-color: red;
            color: white;
        }

        #freeze-btn {
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        #debug-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 10px;
            z-index: 2000;
            color: #0f0;
            font-family: 'Menlo', monospace;
            font-size: 12px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 300px;
        }

        #debug-panel.visible {
            display: block;
        }

        #debug-rooms {
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }

        .debug-room-item {
            padding: 4px 0;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
        }

        .debug-room-item .count {
            color: #fff;
            font-weight: bold;
        }

        .debug-room-item.active {
            color: #00e676;
        }

        #reset-btn {
            margin-top: 10px;
            width: 100%;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
        }

        #reset-btn:hover {
            background: #900;
        }

        .sphere-tooltip {
            position: absolute;
            display: none;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-Family: monospace;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1000;
            transform: translate(15px, 15px);
            text-align: left;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
        }

        .sphere-tooltip .hex {
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            margin-bottom: 2px;
            display: block;
        }

        .sphere-tooltip .meta {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sphere-tooltip .meta.online {
            color: #00e676;
            font-weight: bold;
        }

        #chat-header {
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-family: -apple-system, system-ui, sans-serif;
            flex-shrink: 0;
            color: #1a1a1a;
            cursor: ns-resize;
            /* Indicating it can be dragged/clicked */
        }

        .status {
            font-size: 0.8rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 10px;
            transition: background 0.2s;
        }

        .status:hover {
            background: #eee;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
            transition: background 0.3s;
        }

        .dot.on {
            background: #00e676;
            box-shadow: 0 0 5px #00e676;
        }

        #user-badge {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #999;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #fff;
            color: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow-anchor: none;
        }

        #display {
            min-height: 100%;
            outline: none;
            padding: 40px 60px;
            font-size: 16px;
            line-height: 24px;
            position: relative;
        }

        .editor-line {
            min-height: 24px;
            display: block;
            padding-left: 5px;
            border-left: 4px solid transparent;
            white-space: pre-wrap;
            transition: border-left-color 0.4s ease;
        }

        .editor-line:hover,
        .editor-line.group-hover {
            border-left-color: var(--owner-color, transparent);
        }

        .locked-line {
            position: relative;
        }

        .locked-line::before {
            content: attr(data-lock-owner);
            position: absolute;
            left: 0;
            top: 0;
            transform: translateX(-100%);
            height: 100%;
            background-color: var(--lock-color);
            color: transparent;
            font-family: sans-serif;
            font-size: 10px;
            white-space: nowrap;
            width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px 0 0 2px;
            pointer-events: auto;
            transition: width 0.3s, opacity 0.1s;
            z-index: 10;
        }

        .locked-line:hover::before {
            width: 20px;
            opacity: 1;
            color: transparent;
        }

        .locked-line::before:hover {
            width: 60px !important;
            padding: 0 6px;
            color: #fff !important;
            z-index: 999;
        }

        #minimap {
            position: absolute;
            right: 5px;
            top: 60px;
            bottom: 0;
            width: 12px;
            z-index: 201;
            pointer-events: none;
        }

        .scroll-dot {
            position: absolute;
            right: 0;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: top 0.1s ease-out;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        #tracker {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            padding: 10px 25px;
            background: var(--tracker-bg);
            border: 1px solid var(--ui-border);
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 10;
            pointer-events: none;
        }

        body.light-mode #tracker {
            display: none;
        }

        .cone-data {
            display: flex;
            gap: 8px;
            font-size: 11px;
            font-family: 'Menlo', monospace;
            color: rgba(255, 255, 255, 0.6);
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            padding-right: 20px;
            pointer-events: auto;
            cursor: default;
        }

        .cone-data:last-child {
            border-right: none;
            padding-right: 0;
        }

        .cone-title {
            text-transform: uppercase;
            font-weight: bold;
            cursor: pointer;
        }

        .coord-val {
            color: white;
            min-width: 38px;
            cursor: ns-resize;
        }

        @media (max-width: 768px) {
            .sub-header {
                padding-right: 0 !important;
            }

            #tracker {
                flex-direction: column !important;
                height: auto !important;
                padding: 15px !important;
                border-radius: 20px !important;
                gap: 10px !important;
                align-items: center !important;
            }

            .cone-data {
                border-right: none !important;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                padding-right: 0 !important;
                padding-bottom: 8px;
                width: 100%;
                justify-content: space-between;
            }

            .cone-data:last-child {
                border-bottom: none;
            }
        }

        .dummy-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #333;
            font-weight: 900;
            font-size: 3rem;
            letter-spacing: -1px;
        }
    </style>
</head>

<body class="light-mode">
    <canvas id="gpu-canvas"></canvas>
    <div id="flash-overlay"></div>
    <div id="hover-trigger"></div>

    <nav id="top-nav">
        <div class="nav-item active" data-target="home">Home</div>
        <div class="nav-item" data-target="apps">Apps</div>
        <div class="nav-item" data-target="settings">Settings</div>
    </nav>

    <div id="login-card">
        <div id="color-hex">#FFFFFF</div>
        <div id="room-status">Initializing...</div>
        <button id="login-btn"><span>LOGIN</span></button>
    </div>

    <button id="debug-btn">DEBUG OFF</button>
    <div id="debug-panel">
        <h3>System Tools</h3>
        <button id="reset-btn">WIPE ALL DATA</button>
        <h4>Discovered Rooms</h4>
        <div id="debug-rooms"></div>
    </div>

    <div id="sub-nav-layer">
        <div id="header-apps" class="sub-header">
            <h1 class="page-title">APPS</h1>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="discover" data-group="apps">DISCOVER</div>
                <div class="sub-tab" data-tab="installed" data-group="apps">INSTALLED</div>
                <div class="sub-tab" data-tab="updates" data-group="apps">UPDATES</div>
            </div>
        </div>
        <div id="header-settings" class="sub-header">
            <h1 class="page-title">SETTINGS</h1>
            <div class="tabs-row">
                <div class="sub-tab active" data-tab="general" data-group="settings">GENERAL</div>
                <div class="sub-tab" data-tab="connections" data-group="settings">CONNECTIONS</div>
                <div class="sub-tab" data-tab="signatures" data-group="settings">SIGNATURES</div>
                <div class="sub-tab" data-tab="raw" data-group="settings">RAW DATA</div>
            </div>
        </div>
    </div>

    <div id="dashboard-panel">
        <div id="view-home" class="content-view active">
            <div id="chat-header">
                <div><span id="user-badge" title="Your Color"></span></div>
                <div class="status" id="status-toggle"><span class="dot"></span><span
                        id="peer-count">Disconnected</span></div>
            </div>
            <div id="chat-container">
                <div id="display" contenteditable="true" spellcheck="false"></div>
            </div>
            <div id="minimap"></div>
        </div>
        <div id="view-apps" class="content-view">
            <div id="tab-discover" class="apps-pane active">
                <h2>Discover Apps</h2>
                <p>Find new tools for your space.</p>
                <div class="dummy-content">APPS STORE</div>
            </div>
            <div id="tab-installed" class="apps-pane">
                <h2>Installed</h2>
                <p>Manage your active plugins.</p>
            </div>
            <div id="tab-updates" class="apps-pane">
                <h2>Updates</h2>
                <p>Everything is up to date.</p>
            </div>
        </div>
        <div id="view-settings" class="content-view">
            <div id="tab-general" class="settings-pane active">
                <h2>General Settings</h2>
                <p>Customize your experience.</p>
            </div>
            <div id="tab-connections" class="settings-pane">
                <h2>Network Connections</h2>
                <p>Manage P2P peers and trackers.</p>
            </div>
            <div id="tab-signatures" class="settings-pane">
                <h2>Cryptographic Signatures</h2>
                <p>Verify identity keys.</p>
            </div>
            <div id="tab-raw" class="settings-pane">
                <h2>Raw Data Inspector</h2>
                <p>View underlying structure.</p>
            </div>
        </div>
    </div>

    <div id="tools">
        <button id="btn-bold">B</button>
        <button id="btn-italic">I</button>
        <button id="btn-link">ðŸ”—</button>
    </div>

    <div id="freeze-btn"><svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none"
            stroke-width="2">
            <path d="M9 18h6" />
            <path d="M10 22h4" />
            <path
                d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" />
        </svg></div>
    <div id="tracker">
        <div class="cone-data" id="data-0"></div>
        <div class="cone-data" id="data-1"></div>
        <div class="cone-data" id="data-2"></div>
    </div>

    <script type="module">
        import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

        class ColorDB {
            constructor() { this.name = 'color'; }
            async _open(hex = null) {
                return new Promise((resolve, reject) => {
                    let req = indexedDB.open(this.name);

                    req.onupgradeneeded = (e) => {
                        // Initial setup if needed
                    };

                    req.onsuccess = (e) => {
                        const db = e.target.result;
                        if (hex && !db.objectStoreNames.contains(hex)) {
                            const v = db.version + 1;
                            db.close();
                            const upg = indexedDB.open(this.name, v);
                            upg.onupgradeneeded = (evt) => {
                                const d = evt.target.result;
                                if (!d.objectStoreNames.contains(hex)) {
                                    const store = d.createObjectStore(hex);
                                    store.createIndex('owner', 'owner', { unique: false });
                                }
                            };
                            upg.onsuccess = (evt) => resolve(evt.target.result);
                            upg.onerror = reject;
                        } else resolve(db);
                    };
                    req.onerror = reject;
                });
            }

            async saveLine(hex, index, content, ownerHex) {
                const db = await this._open(hex);
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readwrite');
                    const store = tx.objectStore(hex);
                    store.put(parseInt(index), "cursor");
                    const data = { content: content, owner: ownerHex, updated: Date.now() };
                    if (!content || content.trim() === '') { store.delete(parseInt(index)); } else { store.put(data, parseInt(index)); }
                    tx.oncomplete = () => res(true); tx.onerror = () => res(false);
                });
            }

            async getCursor(hex) {
                const db = await this._open(hex);
                if (!db.objectStoreNames.contains(hex)) return 0;
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readonly').objectStore(hex);
                    const req = tx.get("cursor");
                    req.onsuccess = () => res(req.result || 0);
                    req.onerror = () => res(0);
                });
            }

            async getRange(hex, min, max) {
                const db = await this._open(hex);
                if (!db.objectStoreNames.contains(hex)) return {};
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readonly').objectStore(hex);
                    const range = IDBKeyRange.bound(min, max);
                    const req = tx.openCursor(range);
                    const result = {};
                    req.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) { result[cursor.key] = cursor.value; cursor.continue(); } else { res(result); }
                    };
                    req.onerror = () => res({});
                });
            }

            async getSpecific(hex, keys) {
                const db = await this._open(hex);
                if (!db.objectStoreNames.contains(hex)) return {};
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readonly').objectStore(hex);
                    const results = {};
                    let pending = keys.length;
                    if (pending === 0) return res({});
                    keys.forEach(k => {
                        const idx = parseInt(k.replace(hex, ''), 10);
                        if (isNaN(idx)) { pending--; return; }
                        const req = tx.get(idx);
                        req.onsuccess = () => { if (req.result) results[idx] = req.result; pending--; if (pending === 0) res(results); }
                        req.onerror = () => { pending--; if (pending === 0) res(results); }
                    });
                });
            }

            async getAllRooms() {
                const db = await this._open();
                return Array.from(db.objectStoreNames).map(hex => ({ hex }));
            }

            async saveSignature(hex, signature) {
                const db = await this._open(hex);
                return new Promise(res => {
                    const tx = db.transaction([hex], 'readwrite');
                    const store = tx.objectStore(hex);
                    store.put({ ...signature, created: Date.now() }, 'signature');
                    tx.oncomplete = () => res(true);
                    tx.onerror = () => res(false);
                });
            }

            init() { return this._open(); }
        }
        window.ColorDB = ColorDB;

        class EditorApp {
            constructor() {
                this.db = new ColorDB();
                this.db.init();

                this.ui = Object.fromEntries([
                    'display', 'chat-container', 'minimap', 'peer-count', 'tools', 'room-status',
                    'login-btn', 'user-badge', 'login-card', 'dashboard-panel', 'hover-trigger', 'top-nav', 'sub-nav-layer'
                ].map(id => [id.replace(/-./g, x => x[1].toUpperCase()), document.getElementById(id)]));
                this.ui.dot = document.querySelector('.dot');

                let savedColor = localStorage.getItem('lastSphereColor');
                if (!savedColor) {
                    savedColor = '#ffffff';
                    localStorage.setItem('lastSphereColor', savedColor);
                }

                const cleanUserHex = savedColor.replace('#', '');
                this.user = { id: 'user_' + cleanUserHex, color: savedColor };

                this.visitedRooms = [];
                this.peerColors = {};
                this.anonCounter = 1;
                this.latestKey = null;

                this.db.getAllRooms().then(rooms => {
                    this.visitedRooms = rooms.map(r => 'color-' + r.hex);
                    if (!window.location.hash || window.location.hash.length < 2) {
                        this.runSequencedScan();
                    } else {
                        this.tryAutoConnectFromHash();
                    }
                });

                this.room = null;
                this.roomId = null;
                this.actions = {};
                this.activeLocks = {};
                this.currentLineId = null;
                this.isFresh = true;
                this.saveTimeout = null;
                this.statusTimeoutAttempts = 20;
                this.lastLineCount = 0;

                // Peek mode tracking
                this.peeking = false;

                this.bindEvents();
                this.setupGlobalExposure();

                if (!window.location.hash || window.location.hash.length < 2) {
                    setTimeout(() => this.runSequencedScan(), 100);
                } else {
                    this.tryAutoConnectFromHash();
                }
            }

            makeId(index) { const roomHex = this.roomId ? this.roomId.replace('color-', '') : 'null'; return roomHex + index; }

            parseId(id) {
                if (!id) return null;
                const roomHex = this.roomId.replace('color-', '');
                if (id.startsWith(roomHex)) {
                    const idxStr = id.slice(roomHex.length);
                    const idx = parseInt(idxStr, 10);
                    if (!isNaN(idx)) return { index: idx, owner: roomHex };
                }
                return null;
            }

            reconstructLine(id, content, ownerHex) {
                const myHex = this.user.color.replace('#', '');
                const effectiveOwner = ownerHex || this.roomId.replace('color-', '');
                const isEmpty = !content || content === '<br>' || content.trim() === '';
                const amOwner = (effectiveOwner === myHex);
                const isEditable = (isEmpty || amOwner) ? 'true' : 'false';
                return `<div id="${id}" class="editor-line" contenteditable="${isEditable}">${content || '<br>'}</div>`;
            }

            createRow(index) { return this.reconstructLine(this.makeId(index), null, null); }
            tryAutoConnectFromHash() { if (window.location.hash.length > 1) this.connectAndPreview(window.location.hash, true); }

            joinNetwork(mode = 'standard') {
                try { this.room = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69', trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io'] }, this.roomId); } catch (e) { return; }
                const actions = ['fragment', 'lock', 'req', 'identity'];
                this.actions = Object.assign({}, ...actions.map(k => ({ [`send${k.charAt(0).toUpperCase() + k.slice(1)}`]: this.room.makeAction(k)[0] })));
                const [getFragment] = this.room.makeAction('fragment').slice(1);
                const [getLock] = this.room.makeAction('lock').slice(1);
                const [getReqSync] = this.room.makeAction('req').slice(1);
                const [getIdentity] = this.room.makeAction('identity').slice(1);

                this.actions.reqSync = this.room.makeAction('req')[0];
                getIdentity((data, pid) => this.handlePeerIdentity(data, pid));
                getFragment((fragMap) => this.handleRemoteFragments(fragMap));
                getLock((data, pid) => this.handleRemoteLock(data, pid));
                getReqSync(async (reqKeys, pid) => {
                    if (reqKeys && Array.isArray(reqKeys)) {
                        const roomHex = this.roomId.replace('color-', '');
                        const payload = {};
                        const indices = reqKeys.map(k => parseInt(k.replace(roomHex, ''), 10)).filter(n => !isNaN(n));
                        if (indices.length > 0) {
                            const dbData = await this.db.getSpecific(roomHex, reqKeys);
                            Object.assign(payload, dbData);
                        }
                        if (Object.keys(payload).length) this.actions.sendFragment(payload, pid);

                    } else {
                        const frags = this.getFragments(false);
                        if (Object.keys(frags).length) this.actions.sendFragment(frags, pid);
                    }
                });
                this.room.onPeerJoin(id => { this.handlePeerJoin(id); this.updateStatus(); });
                this.room.onPeerLeave(() => { this.updateStatus(); this.reapplyVisualLocks(); });

                let attempts = 0;
                const poll = setInterval(() => {
                    attempts++; if (!this.room) { clearInterval(poll); return; }
                    this.updateStatus(Object.keys(this.room.getPeers()).length, attempts);
                    if (attempts > 120) clearInterval(poll);
                }, 250);
                setTimeout(() => { if (this.room) this.actions.reqSync(null); }, 500);
            }

            setupGlobalExposure() { window.connectAndPreview = (hex, u) => this.connectAndPreview(hex, u); window.enterRoomUI = () => this.enterRoomUI(); }

            async connectAndPreview(hex, fromUrl = false) {
                this.statusTimeoutAttempts = fromUrl ? 20 : 2;
                const cleanHex = hex.replace('#', '').toLowerCase();
                this.roomId = 'color-' + cleanHex;

                this.user.color = localStorage.getItem('lastSphereColor') || '#ffffff';
                this.ui.userBadge.style.backgroundColor = this.user.color;
                this.user.id = 'user_' + this.user.color.replace('#', '');

                if (this.room) { try { this.room.leave(); } catch (e) { } this.room = null; }

                const db = await this.db._open();
                const exists = db.objectStoreNames.contains(cleanHex);

                this.ui.loginBtn.classList.remove('hidden');

                if (exists) {
                    this.ui.roomStatus.innerText = "Loading...";
                    const centerIndex = await this.db.getCursor(cleanHex);
                    const data = await this.db.getRange(cleanHex, centerIndex - 50, centerIndex + 50);
                    await this.renderFromLocalDB(data, centerIndex);
                    this.ui.roomStatus.innerText = "READY";
                    if (fromUrl && window.state?.landing) {
                        window.state.landing.shouldAutoEnter = true;
                        if (window.state.landing.progress >= 1 && window.enterRoomUI) {
                            window.enterRoomUI();
                        }
                    }
                    this.joinNetwork('conflict');
                } else {
                    this.ui.roomStatus.innerText = "Checking Network...";
                    this.joinNetwork('standard');
                    setTimeout(() => {
                        if (!this.ui.display.querySelector('.editor-line')) {
                            this.renderInitialState({}, 0);
                            if (this.ui.loginBtn.innerText !== "JOIN") this.ui.roomStatus.innerText = "COLOR AVAILABLE";
                        }
                    }, 3000);
                }
            }

            async renderFromLocalDB(data, centerIndex) {
                this.renderInitialState(data, centerIndex);
                this.isFresh = false;
            }

            renderInitialState(data = {}, centerIndex = 0) {
                let html = '';
                const roomHex = this.roomId.replace('color-', '');
                for (let i = centerIndex - 50; i <= centerIndex + 50; i++) {
                    const row = data[i];
                    const content = row ? row.content : null;
                    const owner = row ? row.owner : roomHex;
                    const domId = roomHex + i;
                    html += this.reconstructLine(domId, content, owner);
                }
                this.ui.display.innerHTML = html;
                setTimeout(() => this.focusLine(centerIndex), 0);
            }


            async enterRoomUI() {
                if (window.state) { window.state.landing.active = false; window.state.landing.showHandle = false; }
                if (this.ui.dashboardPanel.classList.contains('active')) return;

                const roomHex = this.roomId.replace('color-', '');

                // 1. UPDATE VISUALS FIRST (Instant feedback)
                if (this.ui.loginBtn.innerText === "LOGIN") {
                    this.user.color = '#' + roomHex;
                    this.ui.userBadge.style.backgroundColor = this.user.color;
                    localStorage.setItem('lastSphereColor', this.user.color);
                    this.user.id = 'user_' + this.user.color.replace('#', '');
                }

                this.ui.loginBtn.classList.add('hidden');
                this.ui.loginCard.classList.remove('visible');
                this.ui.dashboardPanel.classList.add('active');
                this.triggerSave(null);
                this.ui.hoverTrigger.style.display = 'block';

                // 2. DO DATABASE WORK AFTER UI IS UPDATED
                if (window.state && window.state.interactionSignature) {
                    // We don't strictly need to await this for the UI to continue
                    this.db.saveSignature(roomHex, window.state.interactionSignature);
                }

                if (!this.visitedRooms.includes(this.roomId)) {
                    this.visitedRooms.push(this.roomId);
                    this.db._open(roomHex);
                }

                setTimeout(() => {
                    document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                }, 300);

                window.location.hash = roomHex;

                if (!this.ui.display.querySelector('.editor-line')) {
                    this.ui.display.innerHTML = this.createLines(101);
                    this.isFresh = true;
                } else {
                    this.db.getCursor(roomHex).then(idx => {
                        this.focusLine(idx);
                    });
                }
            }

            async runSequencedScan() {
                for (const rId of this.visitedRooms) {
                    if (!rId) continue;
                    try {
                        const r = joinRoom({ appId: 'planet-r0.00,0.98,0.69g-0.85,-0.49,0.69b0.85,-0.49,0.69', trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io'] }, rId);
                        await new Promise(res => setTimeout(() => {
                            window.postMessage({ type: 'handle-ready', hex: rId.replace('color-', '#'), count: Object.keys(r.getPeers()).length }, '*'); r.leave(); res();
                        }, 1000));
                    } catch (e) { }
                }
            }

            createLines(count) {
                let html = '';
                for (let i = 0; i < count; i++) {
                    html += this.createRow(i);
                }
                return html;
            }

            focusLine(index) {
                let attempts = 0;
                const i = setInterval(() => {
                    attempts++;
                    const roomHex = this.roomId.replace('color-', '');
                    let target = document.getElementById(roomHex + index);
                    if (target) {
                        target.scrollIntoView({ block: 'center', behavior: 'auto' });
                        const r = document.createRange(); const s = window.getSelection(); r.selectNodeContents(target); r.collapse(true); s.removeAllRanges(); s.addRange(r);
                        this.ui.display.focus(); this.currentLineId = target.id;
                        if (document.activeElement === this.ui.display || attempts > 20) clearInterval(i);
                    } else if (attempts > 20) clearInterval(i);
                }, 50);
            }

            focusCenter() { this.focusLine(0); }

            checkBuffers() {
                if (this.bufferCheckPending) return;
                this.bufferCheckPending = true;
                requestAnimationFrame(async () => {
                    const c = this.ui.chatContainer;
                    const { scrollTop: st, scrollHeight: sh, clientHeight: ch } = c;
                    const children = this.ui.display.children;
                    if (children.length === 0) { this.bufferCheckPending = false; return; }

                    const firstEl = children[0];
                    const lastEl = children[children.length - 1];
                    const firstMeta = this.parseId(firstEl.id);
                    const lastMeta = this.parseId(lastEl.id);

                    if (!firstMeta || !lastMeta) { this.bufferCheckPending = false; return; }

                    const firstIndex = firstMeta.index;
                    const lastIndex = lastMeta.index;
                    const dbName = this.roomId.replace('color-', '');
                    const roomHex = dbName;

                    if (st < 100) {
                        const oh = sh;
                        const start = firstIndex - 10;
                        const end = firstIndex - 1;
                        const dbData = await this.db.getRange(dbName, start, end);
                        let html = '';
                        for (let i = start; i <= end; i++) {
                            const row = dbData[i];
                            const content = row ? row.content : null;
                            const owner = row ? row.owner : null;
                            html += this.reconstructLine(roomHex + i, content, owner);
                        }
                        this.ui.display.insertAdjacentHTML('afterbegin', html);
                        if (c.scrollHeight > 0) c.scrollTop = st + (c.scrollHeight - oh);
                        if (this.room) {
                            const missing = [];
                            for (let i = start; i <= end; i++) { if (!dbData[i]) missing.push(roomHex + i); }
                            if (missing.length) this.actions.sendReq(missing);
                        }
                    }

                    if (sh - st - ch < 100) {
                        const start = lastIndex + 1;
                        const end = lastIndex + 10;
                        const dbData = await this.db.getRange(dbName, start, end);
                        let html = '';
                        for (let i = start; i <= end; i++) {
                            const row = dbData[i];
                            const content = row ? row.content : null;
                            const owner = row ? row.owner : null;
                            html += this.reconstructLine(roomHex + i, content, owner);
                        }
                        this.ui.display.insertAdjacentHTML('beforeend', html);
                        if (this.room) {
                            const missing = [];
                            for (let i = start; i <= end; i++) { if (!dbData[i]) missing.push(roomHex + i); }
                            if (missing.length) this.actions.sendReq(missing);
                        }
                    }

                    if (children.length > 200) {
                        if (children.length > 250) {
                            if (st > sh / 2) { for (let i = 0; i < 50; i++) children[0].remove(); }
                            else { for (let i = 0; i < 50; i++) children[children.length - 1].remove(); }
                        }
                    }
                    this.bufferCheckPending = false;
                });
            }

            async logout() {
                if (window.resetSphereView) window.resetSphereView();
                this.ui.dashboardPanel.classList.remove('active', 'revealed', 'step-down', 'peek-mode');
                this.ui.dashboardPanel.style.transform = '';
                this.peeking = false;
                if (window.state && window.state.peeking) {
                    window.state.peeking.active = false;
                    window.state.peeking.value = 0;
                }
                this.ui.loginCard.classList.remove('visible');
                this.ui.topNav.classList.remove('visible');
                this.ui.subNavLayer.classList.remove('visible');
                document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                this.ui.hoverTrigger.style.display = 'none';
                this.ui.loginBtn.classList.remove('hidden');
                document.getElementById('freeze-btn').innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
                history.pushState("", document.title, window.location.pathname + window.location.search);
                if (this.room) { try { this.room.leave(); } catch (e) { } this.room = null; }
                this.ui.display.innerHTML = '';
                this.ui.minimap.innerHTML = '';
                this.activeLocks = {};
                this.ui.peerCount.innerText = "Disconnected";
                this.ui.dot.classList.remove('on');
                this.latestKey = null;
                if (window.updateVisitedFromDB) await window.updateVisitedFromDB();
            }

            updateStatus(peers = 0, attempts = 0) {
                if (!this.room) return;
                if (peers > 0) {
                    this.ui.loginBtn.innerHTML = "<span>JOIN</span>";
                    this.ui.loginBtn.classList.remove('hidden');
                    this.ui.roomStatus.innerText = `${peers} PEER${peers > 1 ? 'S' : ''} ONLINE`;
                    this.ui.peerCount.innerText = `${peers} visitors(s)`;
                    this.ui.dot.classList.add('on');
                    return;
                } else {
                    if (this.ui.roomStatus.innerText !== "READY") this.ui.loginBtn.innerText = "LOGIN";
                }
                if (attempts < this.statusTimeoutAttempts) {
                    this.ui.roomStatus.innerText = "SEARCHING...";
                    this.ui.peerCount.innerText = "Connecting...";
                } else {
                    this.ui.roomStatus.innerText = "COLOR AVAILABLE";
                    this.ui.peerCount.innerText = "Offline";
                    if (this.ui.loginBtn.innerText !== "JOIN") this.ui.loginBtn.innerHTML = "<span>LOGIN</span>";
                }
                this.ui.dot.classList.remove('on');
            }

            getFragments(visibleOnly = false) {
                const d = {}, top = this.ui.chatContainer.scrollTop - 500, bot = top + this.ui.chatContainer.clientHeight + 1000;
                const roomHex = this.roomId.replace('color-', '');
                Array.from(this.ui.display.children).forEach(el => {
                    if (el.id && (!visibleOnly || (el.offsetTop + el.offsetHeight > top && el.offsetTop < bot))) {
                        const meta = this.parseId(el.id);
                        if (meta) {
                            d[meta.index] = {
                                content: el.innerHTML,
                                owner: el.getAttribute('data-lock-owner') || roomHex
                            };
                        }
                    }
                });
                return d;
            }

            sanitize(str) {
                const temp = document.createElement('div');
                temp.innerHTML = str;
                const allowed = ['B', 'I', 'U', 'A', 'BR', 'DIV', 'SPAN'];
                function clean(node) {
                    if (node.nodeType === 1) {
                        if (!allowed.includes(node.tagName)) {
                            const text = document.createTextNode(node.innerText);
                            node.parentNode.replaceChild(text, node);
                        } else {
                            Array.from(node.attributes).forEach(attr => {
                                if (attr.name.startsWith('on') || attr.name === 'style') {
                                    node.removeAttribute(attr.name);
                                }
                                if (node.tagName === 'A' && attr.name === 'href') {
                                    if (attr.value.startsWith('javascript:')) node.removeAttribute('href');
                                }
                            });
                            Array.from(node.childNodes).forEach(clean);
                        }
                    }
                }
                clean(temp);
                return temp.innerHTML;
            }

            async handleRemoteFragments(fragMap) {
                const roomHex = this.roomId.replace('color-', '');
                for (const [indexStr, data] of Object.entries(fragMap)) {
                    const index = parseInt(indexStr, 10);
                    const domId = roomHex + index;
                    const newContent = (typeof data === 'string') ? data : data.content;
                    const newOwner = data.owner || roomHex;
                    let el = document.getElementById(domId);
                    if (document.activeElement === el) continue;
                    if (!el) {
                        const temp = document.createElement('div');
                        temp.innerHTML = this.reconstructLine(domId, newContent, newOwner);
                        const newEl = temp.firstElementChild;
                        const children = Array.from(this.ui.display.children);
                        let ref = null;
                        for (let i = 0; i < children.length; i++) {
                            const cMeta = this.parseId(children[i].id);
                            if (cMeta && cMeta.index > index) { ref = children[i]; break; }
                        }
                        this.ui.display.insertBefore(newEl, ref);
                        el = newEl;
                    }
                    if (el) {
                        if (el.innerHTML !== newContent) el.innerHTML = this.sanitize(newContent || '<br>');
                        const myHex = this.user.color.replace('#', '');
                        const isEmpty = !newContent || newContent.trim() === '';
                        const amOwner = (newOwner === myHex);
                        el.contentEditable = (isEmpty || amOwner) ? 'true' : 'false';
                    }
                    await this.db.saveLine(roomHex, index, newContent, newOwner);
                }
            }

            handlePeerJoin(id) {
                if (this.isFresh) return;
                const frags = this.getFragments(true);
                if (Object.keys(frags).length) this.actions.sendFragment(frags, id);
                if (this.currentLineId && this.actions.sendLock) this.actions.sendLock({ lineId: this.currentLineId, userColor: this.user.color }, id);
                if (this.actions.sendIdentity) this.actions.sendIdentity({ color: this.user.color }, id);
            }

            handlePeerIdentity(data, pid) {
                let color = data && data.color ? data.color : null;
                if (!color || color === '#ffffff') {
                    color = '#ffffff' + (this.anonCounter > 0 ? this.anonCounter : '');
                    this.anonCounter++;
                }
                this.peerColors[pid] = color;
            }

            handleRemoteLock(data, pid) { this.activeLocks[pid] = { lineId: data.lineId, ts: Date.now(), color: data.userColor }; this.reapplyVisualLocks(); }

            reapplyVisualLocks() {
                document.querySelectorAll('.locked-line').forEach(el => {
                    el.classList.remove('locked-line');
                    el.style.removeProperty('--lock-color');
                    el.removeAttribute('data-lock-owner');
                });
                const now = Date.now();
                for (const [pid, lock] of Object.entries(this.activeLocks)) {
                    if (now - lock.ts > 60000 || pid === selfId) continue;
                    const el = document.getElementById(lock.lineId);
                    if (el) {
                        el.classList.add('locked-line');
                        el.style.setProperty('--lock-color', lock.color);
                        el.contentEditable = "false";
                        el.setAttribute('data-lock-owner', lock.color);
                    }
                }
                this.renderMinimap();
            }
            renderMinimap() {
                const h = this.ui.chatContainer.scrollHeight, now = Date.now();
                this.ui.minimap.innerHTML = Object.entries(this.activeLocks).filter(([pid, lock]) => now - lock.ts <= 60000 && pid !== selfId).map(([_, lock]) => {
                    const el = document.getElementById(lock.lineId);
                    return el ? `<div class="scroll-dot" style="background:${lock.color};top:${(el.offsetTop / h) * 100}%" onclick="document.getElementById('${lock.lineId}').scrollIntoView({block:'center',behavior:'smooth'})"></div>` : '';
                }).join('');
            }

            async triggerSave(changedLineId = null) {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;
                const dbName = this.roomId.replace('color-', '');
                const getLineIndex = (domId) => { const meta = this.parseId(domId); return meta ? meta.index : null; }
                if (changedLineId) {
                    const el = document.getElementById(changedLineId);
                    const index = getLineIndex(changedLineId);
                    if (index === null) return;
                    const content = el.innerText.trim().length > 0 ? el.innerHTML : null;
                    const owner = this.user.color.replace('#', '');
                    await this.db.saveLine(dbName, index, content, owner);
                    if (this.room && this.actions.sendFragment) {
                        this.actions.sendFragment({ [index]: { content: content, owner: owner, updated: Date.now() } });
                    }
                }
            }

            togglePeek() {
                if (!this.ui.dashboardPanel.classList.contains('active')) return;

                this.peeking = !this.peeking;
                if (this.peeking) {
                    this.ui.dashboardPanel.classList.add('peek-mode');
                    // Update WebGPU state
                    if (window.state && window.state.peeking) {
                        window.state.peeking.active = true;

                        // Animate value
                        const start = window.state.peeking.value;
                        const animate = (t) => {
                            if (!window.state.peeking.active) return;
                            const step = 0.02; // Reduced speed for smoother easing
                            if (window.state.peeking.value < 1.0) {
                                window.state.peeking.value = Math.min(1.0, window.state.peeking.value + step);
                                requestAnimationFrame(animate);
                            }
                        };
                        animate();
                    }
                } else {
                    this.ui.dashboardPanel.classList.remove('peek-mode');
                    if (window.state && window.state.peeking) {
                        const animate = (t) => {
                            const step = 0.02; // Reduced speed for smoother easing
                            if (window.state.peeking.value > 0) {
                                window.state.peeking.value = Math.max(0.0, window.state.peeking.value - step);
                                requestAnimationFrame(animate);
                            } else {
                                window.state.peeking.active = false;
                            }
                        };
                        animate();
                    }
                }
            }

            bindEvents() {
                this.ui.chatContainer.addEventListener('scroll', () => this.checkBuffers());
                window.addEventListener('resize', () => this.renderMinimap());

                // Toggle Peek on Status Click
                document.getElementById('status-toggle').addEventListener('click', (e) => {
                    this.togglePeek();
                });

                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const targetId = item.getAttribute('data-target');
                        if (!targetId) return;
                        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                        item.classList.add('active');
                        document.querySelectorAll('.content-view').forEach(cv => cv.classList.remove('active'));
                        document.getElementById('view-' + targetId).classList.add('active');
                        if (targetId === 'home') {
                            this.ui.dashboardPanel.classList.remove('step-down');
                            this.ui.dashboardPanel.classList.add('revealed');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                        } else {
                            this.ui.dashboardPanel.classList.add('step-down');
                            document.querySelectorAll('.sub-header').forEach(sh => sh.classList.remove('active'));
                            const subHeader = document.getElementById('header-' + targetId);
                            if (subHeader) subHeader.classList.add('active');
                        }
                    });
                });

                document.querySelectorAll('.sub-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const group = tab.getAttribute('data-group');
                        const target = tab.getAttribute('data-tab');
                        document.querySelectorAll(`.sub-tab[data-group="${group}"]`).forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        const activeView = document.querySelector(`.content-view.active`);
                        if (activeView) {
                            activeView.querySelectorAll('.settings-pane, .apps-pane').forEach(pane => pane.classList.remove('active'));
                            const targetPane = activeView.querySelector(`#tab-${target}`);
                            if (targetPane) targetPane.classList.add('active');
                        }
                    });
                });

                window.addEventListener('mousemove', (e) => {
                    if (!this.ui.dashboardPanel.classList.contains('active') ||
                        this.ui.dashboardPanel.classList.contains('revealed') ||
                        this.ui.dashboardPanel.classList.contains('step-down') ||
                        this.ui.dashboardPanel.classList.contains('peek-mode')) {
                        if (!this.peeking) this.ui.dashboardPanel.style.transform = '';
                        return;
                    }
                    const sliverSize = 10;
                    const buffer = 23;
                    const maxGrowth = 23;
                    if (e.clientY < sliverSize + buffer) {
                        const dist = Math.max(0, e.clientY - sliverSize);
                        const progress = 1 - (dist / buffer);
                        const ease = progress * progress;
                        const growth = maxGrowth * ease;
                        const currentVisualHeight = sliverSize + growth;
                        if (e.clientY <= currentVisualHeight) {
                            this.ui.dashboardPanel.classList.add('revealed');
                            this.ui.topNav.classList.add('visible');
                            this.ui.dashboardPanel.style.transform = '';
                        } else {
                            this.ui.dashboardPanel.style.transform = `translateY(${currentVisualHeight}px)`;
                        }
                    } else {
                        this.ui.dashboardPanel.style.transform = '';
                    }
                });

                let touchStartY = 0;
                let isDraggingPanel = false;

                window.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                    // Check if we are at top of list
                    const isAtTop = this.ui.chatContainer.scrollTop === 0;
                    if (this.ui.dashboardPanel.classList.contains('active') && isAtTop) {
                        // Allow potential drag if near header
                        if (touchStartY < 150 || this.peeking) {
                            isDraggingPanel = true;
                        }
                    }
                }, { passive: true });

                window.addEventListener('touchmove', (e) => {
                    if (!this.ui.dashboardPanel.classList.contains('active') || !isDraggingPanel) return;

                    const currentY = e.touches[0].clientY;
                    const delta = currentY - touchStartY;

                    if (delta > 0) {
                        // Dragging Down
                        // Prevent default scroll if we are handling UI transform
                        if (this.ui.dashboardPanel.classList.contains('peek-mode') || !this.peeking) {
                            const navHeight = 90;
                            const maxDrag = window.innerHeight - 50;

                            // Calculate offset
                            let offset = delta;
                            if (this.peeking) {
                                // Already down
                            } else {
                                // Normal state, dragging down
                                if (offset > 0) {
                                    this.ui.dashboardPanel.style.transform = `translateY(${offset}px)`;

                                    // Calculate peek progress for sphere
                                    if (offset > navHeight) {
                                        const range = maxDrag - navHeight;
                                        const prog = Math.min(1, (offset - navHeight) / range);
                                        if (window.state && window.state.peeking) {
                                            window.state.peeking.active = true;
                                            window.state.peeking.value = prog;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Dragging Up
                        if (this.peeking) {
                            const maxDrag = window.innerHeight - 50;
                            // visual offset from bottom
                            const realY = maxDrag + delta; // delta is negative
                            this.ui.dashboardPanel.style.transform = `translateY(${realY}px)`;

                            const range = maxDrag - 90;
                            const prog = Math.max(0, (realY - 90) / range);
                            if (window.state && window.state.peeking) {
                                window.state.peeking.active = true;
                                window.state.peeking.value = prog;
                            }
                        }
                    }
                }, { passive: true });

                window.addEventListener('touchend', (e) => {
                    if (!isDraggingPanel) return;
                    isDraggingPanel = false;

                    // Snap logic
                    const threshold = window.innerHeight * 0.3;
                    const transform = this.ui.dashboardPanel.style.transform;
                    let currentY = 0;
                    if (transform && transform.indexOf('translateY') !== -1) {
                        currentY = parseInt(transform.replace(/[^\d.]/g, ''), 10);
                    }

                    // Reset inline style to let CSS class take over
                    this.ui.dashboardPanel.style.transform = '';

                    if (this.peeking) {
                        // Was peeking. If dragged up significantly, go full screen
                        if (currentY < window.innerHeight * 0.7) {
                            // Restore full screen
                            this.peeking = false;
                            this.ui.dashboardPanel.classList.remove('peek-mode');
                            this.updatePeekState(0);
                        } else {
                            // Stay peeking
                            this.ui.dashboardPanel.classList.add('peek-mode');
                            this.updatePeekState(1);
                        }
                    } else {
                        // Was full screen. If dragged down enough, go peek
                        if (currentY > threshold) {
                            this.peeking = true;
                            this.ui.dashboardPanel.classList.add('peek-mode');
                            this.updatePeekState(1);
                        } else {
                            this.peeking = false;
                            this.ui.dashboardPanel.classList.remove('peek-mode');
                            this.updatePeekState(0);
                        }
                    }

                    // Reveal nav logic from original code
                    const lastY = e.changedTouches[0].clientY;
                    if (touchStartY < window.innerHeight * 0.15 && (lastY - touchStartY > 30) && !this.peeking) {
                        this.ui.dashboardPanel.classList.add('revealed');
                        this.ui.topNav.classList.add('visible');
                    }
                });

                document.getElementById('freeze-btn').addEventListener('click', (e) => {
                    if (this.ui.dashboardPanel.classList.contains('active') || window.state.landing.active) {
                        e.stopImmediatePropagation();
                        window.parent.postMessage({ type: 'cancel-color' }, '*');
                        this.logout();
                    }
                });

                const btn = document.getElementById('freeze-btn');
                const isSafe = (t) => t?.closest?.('#top-nav') || t?.closest?.('#freeze-btn') || t === this.ui.hoverTrigger || t?.closest?.('#sub-nav-layer');

                this.ui.hoverTrigger.addEventListener('mouseenter', () => {
                    this.ui.dashboardPanel.classList.add('revealed');
                    this.ui.topNav.classList.add('visible');
                });
                this.ui.hoverTrigger.addEventListener('mouseleave', (e) => {
                    if (!isSafe(e.relatedTarget) && !this.ui.dashboardPanel.classList.contains('step-down')) {
                        this.ui.dashboardPanel.classList.remove('revealed');
                        this.ui.topNav.classList.remove('visible');
                    }
                });
                this.ui.topNav.addEventListener('mouseenter', () => {
                    this.ui.dashboardPanel.classList.add('revealed');
                    this.ui.topNav.classList.add('visible');
                });
                this.ui.topNav.addEventListener('mouseleave', (e) => {
                    if (!isSafe(e.relatedTarget) && !this.ui.dashboardPanel.classList.contains('step-down')) {
                        this.ui.dashboardPanel.classList.remove('revealed');
                        this.ui.topNav.classList.remove('visible');
                    }
                });
                btn.addEventListener('mouseenter', () => { this.ui.dashboardPanel.classList.add('revealed'); });
                btn.addEventListener('mouseleave', (e) => {
                    if (!isSafe(e.relatedTarget) && !this.ui.dashboardPanel.classList.contains('step-down')) {
                        this.ui.dashboardPanel.classList.remove('revealed');
                        this.ui.topNav.classList.remove('visible');
                    }
                });

                this.ui.display.addEventListener('input', () => {
                    this.isFresh = false;
                    const n = window.getSelection().anchorNode, line = (n.nodeType === 3 ? n.parentNode : n).closest('.editor-line');
                    if (line) {
                        clearTimeout(this.saveTimeout); this.saveTimeout = setTimeout(() => this.triggerSave(line?.id), 500);
                    }
                });

                this.ui.display.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace') {
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const anchor = sel.anchorNode;
                            const currentLine = (anchor.nodeType === 3 ? anchor.parentNode : anchor).closest('.editor-line');
                            if (currentLine) {
                                const isAtStart = range.collapsed && range.startOffset === 0 &&
                                    (anchor === currentLine || anchor === currentLine.firstChild);
                                if (isAtStart) {
                                    const prevLine = currentLine.previousElementSibling;
                                    if (prevLine && prevLine.isContentEditable === false) {
                                        e.preventDefault();
                                        return;
                                    }
                                }
                            }
                        }
                    }

                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const sel = window.getSelection();
                        if (sel.rangeCount) {
                            const range = sel.getRangeAt(0);
                            const br = document.createElement('br');
                            range.deleteContents();
                            range.insertNode(br);
                            range.setStartAfter(br);
                            range.setEndAfter(br);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }
                });

                document.addEventListener('selectionchange', () => {
                    const s = window.getSelection(); if (!s.rangeCount) return;
                    const line = (s.anchorNode.nodeType === 3 ? s.anchorNode.parentNode : s.anchorNode).closest('.editor-line');
                    if (line && line.id) {
                        this.currentLineId = line.id; document.querySelectorAll('.my-line').forEach(e => e.classList.remove('my-line')); line.classList.add('my-line');
                        this.ui.tools.classList.toggle('visible', s.toString().length > 0);
                        if (this.actions.sendLock) this.actions.sendLock({ lineId: line.id, userColor: this.user.color });
                    }
                });
                ['bold', 'italic'].forEach(c => document.getElementById('btn-' + c).onclick = () => document.execCommand(c));
                document.getElementById('btn-link').onclick = () => { const u = prompt("URL:"); if (u) document.execCommand('createLink', false, u); };
            }

            updatePeekState(val) {
                if (window.state && window.state.peeking) {
                    window.state.peeking.active = val > 0;
                    window.state.peeking.value = val;
                }
            }
        }

        window.app = new EditorApp();
    </script>

    <script type="module">
        let storageScope = window.localStorage;
        document.getElementById('login-btn').addEventListener('click', async () => {
            if (document.getElementById('login-btn').innerText === 'LOGIN') {
                try {
                    storageScope.setItem("lastSphereColor", document.getElementById('color-hex').innerText);
                } catch (e) { }
            }
            if (window.enterRoomUI) window.enterRoomUI();
        });

        const Vec3 = { create: () => [0, 0, 0], add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]], sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]], scale: (v, s) => [v[0] * s, v[1] * s, v[2] * s], dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2], cross: (a, b) => [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]], len: v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]), normalize: v => { const l = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); return l > 0 ? [v[0] / l, v[1] / l, v[2] / l] : [0, 0, 0] }, dist: (a, b) => Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) };
        const Mat4 = {
            perspective: (f, a, n, fr) => { const nf = 1 / (n - fr), f_t = 1 / Math.tan(f / 2); return [f_t / a, 0, 0, 0, 0, f_t, 0, 0, 0, 0, (fr + n) * nf, -1, 0, 0, 2 * fr * n * nf, 0] },
            lookAt: (e, c, u) => { const z = Vec3.normalize(Vec3.sub(e, c)), x = Vec3.normalize(Vec3.cross(u, z)), y = Vec3.cross(z, x); return [x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -Vec3.dot(x, e), -Vec3.dot(y, e), -Vec3.dot(z, e), 1] },
            multiply: (a, b) => [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]],
            rotationX: r => [1, 0, 0, 0, 0, Math.cos(r), Math.sin(r), 0, 0, -Math.sin(r), Math.cos(r), 0, 0, 0, 0, 1],
            translation: v => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1],
            scale: v => [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1],
            rotationAxis: (a, r) => { const c = Math.cos(r), s = Math.sin(r), t = 1 - c, x = a[0], y = a[1], z = a[2]; return [t * x * x + c, t * x * y + z * s, t * x * z - y * s, 0, t * x * y - z * s, t * y * y + c, t * y * z + x * s, 0, t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0, 0, 0, 0, 1] },
            identity: () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
        };

        const state = { canvas: null, device: null, context: null, pipelines: { sphere: null, cone: null }, buffers: {}, bindGroups: { sphere: null, cones: [] }, cameraPos: [0, 0, 4], sphere: { rotation: Mat4.identity(), indexCount: 0 }, cones: [{ color: [1, 0, 0], pos: [0, .98, .69], vel: [0, 0, 0], name: "RED", cssColor: "#ff4444", active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], vel: [0, 0, 0], name: "GREEN", cssColor: "#44ff44", active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], vel: [0, 0, 0], name: "BLUE", cssColor: "#4444ff", active: true }], historyHandles: [], hasRotated: false, mouse: { x: 0, y: 0, down: false }, draggedConeIndex: -1, valueScrub: { active: false, coneIndex: -1, coordIndex: 0, startY: 0 }, lastTime: 0, clickData: { startX: 0, startY: 0, startTime: 0 }, landing: { active: false, progress: 0, rotationAxis: [1, 0, 0], rotationAngle: 0, baseRotation: Mat4.identity(), coneStartPositions: [], handleStartPos: [0, 0, 0], showHandle: false, startDist: 4.0, targetDist: 1.25, shouldAutoEnter: false }, dragStart: { active: false, mouseDir: [0, 0, 1], sphereRotation: null, conePositions: [], lastTrackPos: null }, inertia: { active: false, axis: [1, 0, 0], val: 0 }, handle: { active: false, pos: [0, 0, 0], color: [1, 1, 1] }, msaaTexture: null, depthTexture: null, sampleCount: 4, presentationFormat: null, debugMode: false, uiCache: [], vpMatrix: Mat4.identity(), returning: null, uniforms: { sphere: new Float32Array(80), cone: new Float32Array(20) }, peeking: { active: false, value: 0 }, interaction: { mode: 'none', hasTouchedSphere: false }, pathPoints: [], pathStartPos: null, interactionSignature: { type: 'click', path: [] } };
        window.state = state;

        function rgbToHex(r, g, b) { return '#' + [r, g, b].map(x => Math.round(Math.min(1, Math.max(0, x)) * 255).toString(16).padStart(2, '0')).join(''); }
        function hexToRgbNormalized(hex) { const bigint = parseInt(hex.replace(/^#/, '').replace(/^([a-f\d])([a-f\d])([a-f\d])$/i, '$1$1$2$2$3$3'), 16); return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255]; }

        const gradientShaderWGSL = `
struct Uniforms {
    mvp: mat4x4<f32>,
    model: mat4x4<f32>,
    normalMatrix: mat4x4<f32>,
    viewPos: vec3<f32>,
    l1: vec3<f32>, c1: vec3<f32>,
    l2: vec3<f32>, c2: vec3<f32>,
    l3: vec3<f32>, c3: vec3<f32>,
    debug: f32,
};
@group(0) @binding(0) var<uniform> u: Uniforms;
struct VI { @location(0) p: vec3<f32>, @location(1) n: vec3<f32> };
struct VO { @builtin(position) P: vec4<f32>, @location(0) vP: vec3<f32>, @location(1) vN: vec3<f32> };
@vertex fn vs_main(i: VI) -> VO { var o: VO; o.P = u.mvp * vec4<f32>(i.p, 1.0); o.vP = (u.model * vec4<f32>(i.p, 1.0)).xyz; o.vN = (u.normalMatrix * vec4<f32>(i.n, 0.0)).xyz; return o; }
fn Contrast(x: vec3<f32>) -> vec3<f32> { return x * x * (3.0 - 2.0 * x); }
fn getI(lp: vec3<f32>, N: vec3<f32>, fp: vec3<f32>) -> f32 { let distSq = dot(lp - fp, lp - fp); let L = normalize(lp - fp); let wrap = max(dot(N, L) + 1.0, 0.0) / 2.0; let spread = pow(wrap, 1.25); return spread * (1.0 / (1.0 + distSq * 0.05)); }
@fragment fn fs_main(i: VO) -> @location(0) vec4<f32> { let N = normalize(i.vN); let raw_d1 = getI(u.l1, N, i.vP); let raw_d2 = getI(u.l2, N, i.vP); let raw_d3 = getI(u.l3, N, i.vP); let d1 = raw_d1 * max(u.c1.r, max(u.c1.g, u.c1.b)); let d2 = raw_d2 * max(u.c2.r, max(u.c2.g, u.c2.b)); let d3 = raw_d3 * max(u.c3.r, max(u.c3.g, u.c3.b)); var l = (u.c1 * d1) + (u.c2 * d2) + (u.c3 * d3); let ep = 0.001; l = l + ((u.c1 + u.c2) * 2.0 * d1 * d2 / (d1 + d2 + ep)); l = l + ((u.c2 + u.c3) * 2.0 * d2 * d3 / (d2 + d3 + ep)); l = l + ((u.c3 + u.c1) * 2.0 * d3 * d1 / (d3 + d1 + ep)); let min_i = min(d1, min(d2, d3)); let max_i = max(d1, max(d2, d3)); let mask_base = smoothstep(0.15, 0.40, min_i); let variance = max_i - min_i; let roundness = exp(-variance * 10.0); let final_mask = mask_base * roundness; l = mix(l, vec3(1.0), final_mask); l = l * 1.2; let contrasty = Contrast(clamp(l, vec3(0.0), vec3(1.0))); return vec4<f32>(contrasty, 1.0); }
`;
        const solidShaderWGSL = `struct U{mvp:mat4x4<f32>,c:vec4<f32>};@group(0) @binding(0) var<uniform> u:U;@vertex fn vs_main(@location(0) p:vec3<f32>)->@builtin(position) vec4<f32>{return u.mvp*vec4<f32>(p,1.0);}@fragment fn fs_main()->@location(0) vec4<f32>{return u.c;}`;

        const defaultCones = [{ color: [1, 0, 0], pos: [0, .98, .69], active: true }, { color: [0, 1, 0], pos: [-.85, -.49, .69], active: true }, { color: [0, 0, 1], pos: [.85, -.49, .69], active: true }];

        function findPositionFromColor(targetHex) {
            const t = hexToRgbNormalized(targetHex); let bd = Infinity, bp = null;
            for (let la = 0; la <= 30; la++) for (let lo = 0; lo <= 30; lo++) {
                const th = la * Math.PI / 30, ph = lo * 2 * Math.PI / 30, pos = [Math.cos(ph) * Math.sin(th), Math.cos(th), Math.sin(ph) * Math.sin(th)];
                const c = getSurfaceColor(pos, pos, defaultCones), d = Math.sqrt((c[0] - t[0]) ** 2 + (c[1] - t[1]) ** 2 + (c[2] - t[2]) ** 2);
                if (d < bd) { bd = d; bp = pos; }
                if (d < 0.05) return bp;
            } return bp;
        }

        async function init() {
            if (window.self !== window.top) document.getElementById('debug-btn').style.display = 'none';
            state.canvas = document.getElementById('gpu-canvas');
            if (!navigator.gpu) return alert("WebGPU not supported!");
            const adapter = await navigator.gpu.requestAdapter(); state.device = await adapter.requestDevice();
            state.context = state.canvas.getContext('webgpu'); state.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            state.context.configure({ device: state.device, format: state.presentationFormat, alphaMode: 'premultiplied' });

            const rooms = await (new window.ColorDB()).getAllRooms();

            state.historyHandles = [];
            await createAssets();
            window.addEventListener('resize', onResize); onResize();
            state.canvas.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
            state.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onMouseDown(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove(e.touches[0]) }, { passive: false });
            state.canvas.addEventListener('touchend', (e) => { e.preventDefault(); onMouseUp(e.changedTouches[0]) });
            document.getElementById('freeze-btn').addEventListener('click', toggleFreeze);

            document.getElementById('debug-btn').onclick = function () {
                state.debugMode = !state.debugMode; this.classList.toggle('active', state.debugMode);
                this.innerText = state.debugMode ? "DEBUG ON" : "DEBUG OFF"; document.getElementById('debug-panel').classList.toggle('visible', state.debugMode);
            };
            document.getElementById('reset-btn').onclick = async () => { if (confirm("Permanently wipe all local data?")) { localStorage.clear(); try { const dbs = await window.indexedDB.databases(); for (const db of dbs) { await window.indexedDB.deleteDatabase(db.name); } } catch (e) { } window.location.reload(); } };

            state.cones.forEach((c, i) => {
                const el = document.getElementById(`data-${i}`);
                if (!el) return;
                el.innerHTML = `<span class="cone-title" id="title-${i}">${c.name}</span> <span style="color:#666">X</span> <span class="coord-val" id="x-${i}">0.00</span> <span style="color:#666">Y</span> <span class="coord-val" id="y-${i}">0.00</span> <span style="color:#666">Z</span> <span class="coord-val" id="z-${i}">0.00</span>`;
                const title = document.getElementById(`title-${i}`);
                title.addEventListener('click', (e) => { if (!document.body.classList.contains('light-mode')) { e.stopPropagation(); state.cones[i].active = !state.cones[i].active; } });
                ['x', 'y', 'z'].forEach((ax, idx) => document.getElementById(`${ax}-${i}`).addEventListener('mousedown', (e) => { if (!document.body.classList.contains('light-mode')) { e.preventDefault(); e.stopPropagation(); state.valueScrub = { active: true, coneIndex: i, coordIndex: idx, startY: e.clientY }; } }));
                state.uiCache[i] = { title, x: document.getElementById(`x-${i}`), y: document.getElementById(`y-${i}`), z: document.getElementById(`z-${i}`), lastPos: [null, null, null], lastActive: null };
            });

            setupColorTooltip();
            if (window.location.hash && window.location.hash.length > 1) { const matchPos = findPositionFromColor(window.location.hash); if (matchPos) triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(window.location.hash), true); }
            requestAnimationFrame(loop);
        }

        async function createAssets() {
            const dev = state.device, sphereGeo = createSphere(1.0, 128, 128), coneGeo = createCone(0.1, 0.3, 64);
            state.buffers.sphereVertex = createBuffer(dev, sphereGeo.p, GPUBufferUsage.VERTEX); state.buffers.sphereNormal = createBuffer(dev, sphereGeo.n, GPUBufferUsage.VERTEX); state.buffers.sphereIndex = createBuffer(dev, sphereGeo.i, GPUBufferUsage.INDEX); state.sphere.indexCount = sphereGeo.i.length;
            state.buffers.coneVertex = createBuffer(dev, coneGeo.p, GPUBufferUsage.VERTEX); state.buffers.coneIndex = createBuffer(dev, coneGeo.i, GPUBufferUsage.INDEX); state.coneIndexCount = coneGeo.i.length;
            state.buffers.sphereUniform = dev.createBuffer({ size: 320, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            state.buffers.coneUniform = dev.createBuffer({ size: 65536, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            const sm = dev.createShaderModule({ code: gradientShaderWGSL }), cm = dev.createShaderModule({ code: solidShaderWGSL });
            state.pipelines.sphere = dev.createRenderPipeline({ layout: 'auto', vertex: { module: sm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }, { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }] }, fragment: { module: sm, entryPoint: 'fs_main', targets: [{ format: state.presentationFormat }] }, primitive: { cullMode: 'back' }, depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }, multisample: { count: 4 } });
            state.pipelines.cone = dev.createRenderPipeline({
                layout: 'auto',
                vertex: { module: cm, entryPoint: 'vs_main', buffers: [{ arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] }] },
                fragment: {
                    module: cm,
                    entryPoint: 'fs_main',
                    targets: [{
                        format: state.presentationFormat
                    }]
                },
                primitive: { cullMode: 'back' },
                depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' },
                multisample: { count: 4 }
            });
            state.bindGroups.sphere = dev.createBindGroup({ layout: state.pipelines.sphere.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.sphereUniform } }] });
            state.getBindGroupForHandle = (idx) => dev.createBindGroup({ layout: state.pipelines.cone.getBindGroupLayout(0), entries: [{ binding: 0, resource: { buffer: state.buffers.coneUniform, offset: idx * 256, size: 80 } }] });
            state.bindGroups.cones = [0, 1, 2, 3].map(i => state.getBindGroupForHandle(i));
        }

        function createBuffer(dev, data, usage) { const buf = dev.createBuffer({ size: data.byteLength, usage: usage | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); (data instanceof Float32Array ? new Float32Array(buf.getMappedRange()) : new Uint16Array(buf.getMappedRange())).set(data); buf.unmap(); return buf; }
        function createSphere(r, latB, longB) { const p = [], n = [], idx = []; for (let la = 0; la <= latB; la++) for (let lo = 0; lo <= longB; lo++) { const th = la * Math.PI / latB, ph = lo * 2 * Math.PI / longB, x = Math.cos(ph) * Math.sin(th), y = Math.cos(th), z = Math.sin(ph) * Math.sin(th); n.push(x, y, z); p.push(r * x, r * y, r * z); } for (let la = 0; la < latB; la++) for (let lo = 0; lo < longB; lo++) { const f = (la * (longB + 1)) + lo, s = f + longB + 1; idx.push(f, f + 1, s, s, f + 1, s + 1); } return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }
        function createCone(r, h, s) { const p = [0, h, 0], n = [0, 1, 0], idx = []; for (let i = 0; i <= s; i++) { const th = i * 2 * Math.PI / s, x = r * Math.cos(th), z = r * Math.sin(th); p.push(x, 0, z); const nv = Vec3.normalize([x, .5, z]); n.push(nv[0], nv[1], nv[2]); } p.push(0, 0, 0); n.push(0, -1, 0); const bc = p.length / 3 - 1; for (let i = 1; i <= s; i++) idx.push(0, i, i + 1, bc, i + 1, i); return { p: new Float32Array(p), n: new Float32Array(n), i: new Uint16Array(idx) }; }

        // Create ribbon geometry from path points (adapted from old path_to_mesh)
        function pathToVertices(pathPoints, sphereRotation) {
            if (pathPoints.length < 2) return null;

            const WIDTH = 0.015; // Half-width of the ribbon
            const PROTRUDE = 1.02; // Slightly above sphere surface

            // Transform path from local to world space
            const path = pathPoints.map(p => {
                const wp = transformPos(p, sphereRotation);
                return Vec3.scale(Vec3.normalize(wp), PROTRUDE);
            });

            // Calculate tangent vectors at each point
            const tangents = [];
            for (let i = 0; i < path.length; i++) {
                let dir;
                if (i === 0) {
                    dir = Vec3.sub(path[1], path[0]);
                } else if (i === path.length - 1) {
                    dir = Vec3.sub(path[i], path[i - 1]);
                } else {
                    dir = Vec3.sub(path[i + 1], path[i - 1]);
                }
                // Tangent is perpendicular to both direction and radial vector
                const radial = Vec3.normalize(path[i]);
                let tangent = Vec3.cross(dir, radial);
                const tLen = Vec3.len(tangent);
                if (tLen < 0.001) {
                    // Fallback for degenerate case
                    tangent = Vec3.cross(dir, [0, 1, 0]);
                    if (Vec3.len(tangent) < 0.001) tangent = Vec3.cross(dir, [1, 0, 0]);
                }
                tangents.push(Vec3.scale(Vec3.normalize(tangent), WIDTH));
            }

            // Create triangle vertices for the ribbon (4 triangles per segment)
            const vertices = [];
            for (let i = 1; i < path.length; i++) {
                const p0 = path[i - 1], p1 = path[i];
                const t0 = tangents[i - 1], t1 = tangents[i];

                // Four corners of the ribbon segment
                const v0p = Vec3.add(p0, t0), v0m = Vec3.sub(p0, t0);
                const v1p = Vec3.add(p1, t1), v1m = Vec3.sub(p1, t1);

                // Top face (2 triangles)
                vertices.push(...v1p, ...v1m, ...v0m);
                vertices.push(...v1p, ...v0m, ...v0p);
            }

            return new Float32Array(vertices);
        }

        function onResize() {
            if (!state.device) return;
            const w = state.canvas.clientWidth;
            const h = state.canvas.clientHeight;
            state.canvas.width = w; state.canvas.height = h;
            if (state.msaaTexture) state.msaaTexture.destroy();
            if (state.depthTexture) state.depthTexture.destroy();
            state.msaaTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: state.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT });
            state.depthTexture = state.device.createTexture({ size: [w, h], sampleCount: 4, format: 'depth24plus', usage: GPUTextureUsage.RENDER_ATTACHMENT });
            const aspect = w / h;
            const newZ = aspect < 1 ? 3.5 / aspect : 4;
            if (!state.landing.active && (!state.returning || !state.returning.active)) { state.cameraPos = [0, 0, newZ]; }
            if (state.returning) state.returning.targetDist = newZ;
        }

        function getMouseRay(x, y) { const aspect = state.canvas.width / state.canvas.height, ndcX = (x / state.canvas.width) * 2 - 1, ndcY = -(y / state.canvas.height) * 2 + 1; const dir = Vec3.normalize([ndcX * aspect * Math.tan(Math.PI / 8), ndcY * Math.tan(Math.PI / 8), -1]); return { o: state.cameraPos, d: dir }; }
        function getTargetPos(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)); return Vec3.dot(p, p) <= 1 ? Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p)))) : Vec3.scale(Vec3.normalize(p), 1); }
        function calculateConePosition(x, y) { const r = getMouseRay(x, y), t = Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d), p = Vec3.add(r.o, Vec3.scale(r.d, t)), dist = Math.sqrt(Vec3.dot(p, p)), R = 1.2; if (dist <= R) return Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(R * R - Vec3.dot(p, p)))); const axis = Vec3.cross(Vec3.normalize(r.o), r.d); return Vec3.scale(transformPos(Vec3.normalize(r.o), Mat4.rotationAxis(Vec3.normalize(Vec3.len(axis) < .001 ? [1, 0, 0] : axis), Math.acos(R / Vec3.len(r.o)) + (dist - R))), R); }
        function transformPos(p, m) { return [m[0] * p[0] + m[4] * p[1] + m[8] * p[2] + m[12], m[1] * p[0] + m[5] * p[1] + m[9] * p[2] + m[13], m[2] * p[0] + m[6] * p[1] + m[10] * p[2] + m[14]]; }
        function projectToScreen(worldPos) { const m = state.vpMatrix, x = worldPos[0], y = worldPos[1], z = worldPos[2], clipX = x * m[0] + y * m[4] + z * m[8] + m[12], clipY = x * m[1] + y * m[5] + z * m[9] + m[13], clipW = x * m[3] + y * m[7] + z * m[11] + m[15]; if (clipW <= 0) return null; return { x: (clipX / clipW + 1) * state.canvas.width / 2, y: (1 - clipY / clipW) * state.canvas.height / 2 }; }

        function onMouseDown(e) {
            if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav')) return;

            if (state.valueScrub.active) return;
            const rect = state.canvas.getBoundingClientRect();
            state.mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top, down: true };
            state.clickData = { startX: state.mouse.x, startY: state.mouse.y, startTime: Date.now() };

            // Reset signature for new interaction
            state.interactionSignature = { type: 'click', path: [] };
            state.pathPoints = [];
            state.pathStartPos = null;

            if (document.body.classList.contains('light-mode')) {
                state.inertia.val = 0;
                let clickedExisting = false;
                for (let h of state.historyHandles) {
                    const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                    if (sp && Math.sqrt((state.mouse.x - sp.x) ** 2 + (state.mouse.y - sp.y) ** 2) < 20) {
                        clickedExisting = true;
                        break;
                    }
                }

                const p = getTargetPos(state.mouse.x, state.mouse.y);
                const r = getMouseRay(state.mouse.x, state.mouse.y);
                const hit = Vec3.dot(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d))), Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)))) <= 1;

                if (hit) {
                    // Start ON sphere -> Zoom Mode
                    state.interaction = {
                        mode: 'zoom',
                        hasTouchedSphere: true,
                        startZ: state.cameraPos[2],
                        startMouse: { x: state.mouse.x, y: state.mouse.y }
                    };
                    // Initialize path from current center position in LOCAL sphere coordinates
                    const m = state.sphere.rotation;
                    const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]); // [0,0,1] * R^T
                    const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100];
                    state.pathPoints = [rounded];
                    state.interactionSignature.path = [rounded];
                    startDragLogic(p, clickedExisting);
                } else {
                    // Start OFF sphere -> Wait Mode
                    state.interaction = { mode: 'waiting', hasTouchedSphere: false };
                    state.handle.active = false;
                    state.dragStart.active = false;
                }

                state.hasRotated = true;
            }
        }

        function startDragLogic(p, clickedExisting) {
            state.dragStart = {
                active: true,
                mouseDir: Vec3.normalize(p),
                sphereRotation: [...state.sphere.rotation],
                conePositions: state.cones.map(c => [...c.pos]),
                lastTrackPos: p
            };
            if (!clickedExisting) {
                state.handle = {
                    active: true,
                    pos: p,
                    color: getSurfaceColor(p, Vec3.normalize(p))
                };
            }
        }

        function onMouseMove(e) {
            const r = state.canvas.getBoundingClientRect();
            state.mouse.x = e.clientX - r.left;
            state.mouse.y = e.clientY - r.top;

            // Wait Mode Logic: Check if finger crossed onto sphere
            if (state.mouse.down && state.interaction && state.interaction.mode === 'waiting') {
                const ray = getMouseRay(state.mouse.x, state.mouse.y);
                const closest = Vec3.add(ray.o, Vec3.scale(ray.d, Vec3.dot(Vec3.sub([0, 0, 0], ray.o), ray.d)));
                const onSphere = Vec3.dot(closest, closest) <= 1;

                if (onSphere) {
                    const p = getTargetPos(state.mouse.x, state.mouse.y);
                    state.interaction.mode = 'normal';
                    state.interaction.hasTouchedSphere = true;
                    state.interactionSignature.type = 'drag';
                    // Initialize path from current center position in LOCAL sphere coordinates
                    const m = state.sphere.rotation;
                    const initialLocalCenter = Vec3.normalize([m[2], m[6], m[10]]); // [0,0,1] * R^T
                    const rounded = [Math.round(initialLocalCenter[0] * 100) / 100, Math.round(initialLocalCenter[1] * 100) / 100, Math.round(initialLocalCenter[2] * 100) / 100];
                    state.pathPoints = [rounded];
                    state.interactionSignature.path = [rounded];
                    startDragLogic(p, false);
                }
            }

            // Track path during drag - record CENTER of view in local sphere coordinates
            // The center (what camera sees) changes as sphere rotates - this is what sets background color
            if (state.mouse.down && state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active) {
                // The center in WORLD space is always [0, 0, 1] (pointing at camera)
                // To get the LOCAL sphere coordinate, apply inverse rotation (transpose for orthogonal)
                const m = state.sphere.rotation;
                // Center point [0, 0, 1] transformed by inverse rotation
                const localCenterPos = [m[2], m[6], m[10]]; // Third column of rotation matrix transposed = [0,0,1] * R^T

                // Only add point if it moved enough from last point (avoid cluttering with tiny movements)
                const lastPoint = state.pathPoints[state.pathPoints.length - 1];
                if (!lastPoint || Vec3.dist(localCenterPos, lastPoint) > 0.01) {
                    const normalized = Vec3.normalize(localCenterPos);
                    const rounded = [Math.round(normalized[0] * 100) / 100, Math.round(normalized[1] * 100) / 100, Math.round(normalized[2] * 100) / 100];
                    state.pathPoints.push(rounded);
                    state.interactionSignature.type = 'drag';
                    state.interactionSignature.path.push(rounded);
                }
                // Limit path size
                if (state.pathPoints.length > 500) state.pathPoints.shift();
                if (state.interactionSignature.path.length > 500) state.interactionSignature.path.shift();
            }
        }

        function onMouseUp(e) {
            if (e.target.closest('#login-card') || e.target.closest('#dashboard-panel') || e.target.closest('#top-nav')) return;

            state.mouse.down = false;
            state.handle.active = false;

            // Check if we were dragging - trigger landing at current visual center
            const wasDragging = state.interaction && state.interaction.hasTouchedSphere && state.dragStart.active && state.interactionSignature.type === 'drag';

            state.interaction = { mode: 'none', hasTouchedSphere: false };

            if (state.valueScrub.active) {
                state.valueScrub.active = false;
                return;
            }

            if (document.body.classList.contains('light-mode')) {
                const rect = state.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left, my = e.clientY - rect.top;

                // If we were dragging, just zoom in without rotating - keep current sphere orientation
                if (wasDragging) {
                    // Get color at the current CENTER of view
                    // Use state.cones (which have been rotated) to match the background color calculation
                    const col = getSurfaceColor([0, 0, 1], [0, 0, 1], state.cones);
                    const hex = rgbToHex(col[0], col[1], col[2]);

                    // Set up landing but with ZERO rotation (keep current orientation)
                    state.landing = {
                        active: true, progress: 0, baseRotation: [...state.sphere.rotation],
                        startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]),
                        handleStartPos: [0, 0, 1], showHandle: false,
                        targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))),
                        shouldAutoEnter: false, fromUrl: false,
                        hex: hex,
                        notified: false,
                        rotationAxis: [1, 0, 0], rotationAngle: 0 // No rotation!
                    };
                    state.handle.color = [...col];
                    state.hasRotated = true;
                    document.getElementById('color-hex').innerText = hex.toUpperCase();
                    const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white';
                    document.getElementById('login-card').style.color = textColor;
                    document.getElementById('top-nav').style.setProperty('--nav-color', textColor);
                    if (window.connectAndPreview) window.connectAndPreview(hex, false);

                    // Keep path for a moment then clear
                    setTimeout(() => {
                        state.pathPoints = [];
                        state.pathStartPos = null;
                    }, 500);
                    return;
                }

                if (Math.sqrt((mx - state.clickData.startX) ** 2 + (my - state.clickData.startY) ** 2) < 5 && Date.now() - state.clickData.startTime < 250) {
                    for (let h of state.historyHandles) {
                        const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                        if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) {
                            try { localStorage.setItem("lastSphereColor", h.hex); } catch (e) { }
                            triggerLanding(h.pos, transformPos(h.pos, state.sphere.rotation), h.color, true);
                            return;
                        }
                    }
                    const r = getMouseRay(mx, my),
                        p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)));
                    if (Vec3.dot(p, p) <= 1) {
                        const hp = Vec3.sub(p, Vec3.scale(r.d, Math.sqrt(1 - Vec3.dot(p, p))));
                        triggerLanding(Vec3.normalize(hp), hp, getSurfaceColor(hp, Vec3.normalize(hp)), false);
                    }
                }
            }

            // Clear path on mouse up
            state.pathPoints = [];
            state.pathStartPos = null;
        }

        function triggerLanding(norm, pos, col, fromUrl = false) {
            state.landing = {
                active: true, progress: 0, baseRotation: [...state.sphere.rotation],
                startDist: Vec3.len(state.cameraPos), coneStartPositions: state.cones.map(c => [...c.pos]),
                handleStartPos: [...pos], showHandle: !fromUrl,
                targetDist: 1.0 + (0.25 * ((state.canvas.width / state.canvas.height) < 1 ? 1 : (1.2 / (state.canvas.width / state.canvas.height)))),
                shouldAutoEnter: false, fromUrl: fromUrl
            };
            const startWorldPos = transformPos(pos, state.landing.baseRotation);
            state.landing.offset = [0, 0];
            state.handle.color = [...col];
            state.hasRotated = true;
            const hex = rgbToHex(col[0], col[1], col[2]);
            document.getElementById('color-hex').innerText = hex.toUpperCase();
            const textColor = (0.299 * col[0] + 0.587 * col[1] + 0.114 * col[2]) > 0.5 ? 'black' : 'white';
            document.getElementById('login-card').style.color = textColor;
            document.getElementById('top-nav').style.setProperty('--nav-color', textColor);
            const cam = Vec3.normalize(state.cameraPos), axis = Vec3.cross(norm, cam), dot = Vec3.dot(norm, cam);
            state.landing.rotationAxis = Vec3.len(axis) < .001 ? [1, 0, 0] : Vec3.normalize(axis);
            state.landing.rotationAngle = Vec3.len(axis) < .001 ? (dot > 0 ? 0 : Math.PI) : Math.acos(Math.min(1, Math.max(-1, dot)));
            if (window.connectAndPreview) window.connectAndPreview(hex, fromUrl);

            // UI Refinement: Swap freeze button to X with delay
            setTimeout(() => {
                const btn = document.getElementById('freeze-btn');
                btn.style.opacity = '0';
                setTimeout(() => {
                    btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                    btn.style.opacity = '1';
                }, 200);
            }, 1000);
        }
        function getResponsiveZ() { const aspect = state.canvas.width / state.canvas.height; return aspect < 1 ? 3.5 / aspect : 4; }

        function toggleFreeze() {
            if (document.getElementById('dashboard-panel').classList.contains('active')) return;
            const f = document.getElementById('flash-overlay'), isFrozen = document.body.classList.toggle('light-mode');
            state.landing = { active: false, showHandle: false };
            document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active');
            state.cameraPos = [0, 0, getResponsiveZ()];
            f.style.backgroundColor = isFrozen ? 'white' : 'black'; document.body.style.backgroundColor = '';
            f.classList.remove('active'); void f.offsetWidth; f.classList.add('active'); setTimeout(() => f.classList.remove('active'), 0);

            // Restore Lightbulb icon
            const btn = document.getElementById('freeze-btn');
            btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" fill="none" stroke-width="2"><path d="M9 18h6" /><path d="M10 22h4" /><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z" /></svg>';
            btn.style.opacity = '1';
        }
        function getSurfaceColor(p, n, cones = state.cones) {
            const getI = (i) => {
                if (!cones[i].active) return 0;
                const diff = Vec3.sub(cones[i].pos, p);
                const distSq = Vec3.dot(diff, diff);
                const L = Vec3.normalize(diff);
                const wrap = Math.max(Vec3.dot(n, L) + 1.0, 0.0) / 2.0;
                const spread = Math.pow(wrap, 1.25);
                return spread * (1.0 / (1.0 + distSq * 0.05));
            };
            const d = [getI(0), getI(1), getI(2)];
            const c = cones.map(x => x.color);
            let l = Vec3.add(Vec3.add(Vec3.scale(c[0], d[0]), Vec3.scale(c[1], d[1])), Vec3.scale(c[2], d[2]));
            const boost = (i, j) => {
                const sumD = d[i] + d[j] + 0.001;
                const factor = (2.0 * d[i] * d[j] / sumD);
                return Vec3.scale(Vec3.add(c[i], c[j]), factor);
            };
            l = Vec3.add(l, boost(0, 1));
            l = Vec3.add(l, boost(1, 2));
            l = Vec3.add(l, boost(2, 0));
            const minD = Math.min(d[0], Math.min(d[1], d[2]));
            const maxD = Math.max(d[0], Math.max(d[1], d[2]));
            let t = (minD - 0.15) / (0.40 - 0.15);
            t = Math.max(0.0, Math.min(1.0, t));
            const maskBase = t * t * (3.0 - 2.0 * t);
            const variance = maxD - minD;
            const roundness = Math.exp(-variance * 10.0);
            const finalMask = maskBase * roundness;
            const whiteTarget = [1.0, 1.0, 1.0];
            l = [l[0] * (1.0 - finalMask) + whiteTarget[0] * finalMask, l[1] * (1.0 - finalMask) + whiteTarget[1] * finalMask, l[2] * (1.0 - finalMask) + whiteTarget[2] * finalMask];
            l = l.map(x => x * 1.2);
            return l.map(x => {
                const val = Math.min(Math.max(x, 0), 1);
                return val * val * (3.0 - 2.0 * val);
            });
        }


        function setupColorTooltip() {
            const t = document.createElement('div'); t.className = 'sphere-tooltip'; document.body.appendChild(t);
            window.addEventListener('mousemove', e => {
                if (!document.body.classList.contains('light-mode') || e.target.closest('#dashboard-panel') || e.target.closest('#login-card') || e.target.closest('#top-nav')) { t.style.display = 'none'; return; }
                const rect = state.canvas.getBoundingClientRect(), mx = e.clientX - rect.left, my = e.clientY - rect.top;
                if (state.landing.showHandle && state.handle.pos) {
                    const handleScreen = projectToScreen(state.handle.pos);
                    if (handleScreen && Math.sqrt((mx - handleScreen.x) ** 2 + (my - handleScreen.y) ** 2) < 50) { t.style.display = 'none'; return; }
                }
                for (let h of state.historyHandles) {
                    const sp = projectToScreen(transformPos(h.pos, state.sphere.rotation));
                    if (sp && Math.sqrt((mx - sp.x) ** 2 + (my - sp.y) ** 2) < 20) {
                        t.innerHTML = `<span class="hex">${h.hex.toUpperCase()}</span><span class="${h.peerCount > 0 ? "meta online" : "meta"}">${h.peerCount > 0 ? `${h.peerCount} PEER${h.peerCount > 1 ? 'S' : ''} ONLINE` : "OFFLINE"}</span>`;
                        t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${h.hex}`; return;
                    }
                }
                const r = getMouseRay(mx, my), p = Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d)));
                if (Vec3.dot(p, p) > 1) { t.style.display = 'none'; return; }
                const hex = rgbToHex(...getSurfaceColor(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p)))), Vec3.normalize(Vec3.add(r.o, Vec3.scale(r.d, Vec3.dot(Vec3.sub([0, 0, 0], r.o), r.d) - Math.sqrt(1 - Vec3.dot(p, p))))))).toUpperCase();
                t.innerHTML = `<span class="hex">${hex}</span>`; t.style.display = 'block'; t.style.left = e.clientX + 'px'; t.style.top = e.clientY + 'px'; t.style.border = `1px solid ${hex}`;
            });
        }

        window.resetSphereView = function () {
            const m = state.sphere.rotation, trace = m[0] + m[5] + m[10];
            let angle = Math.acos(Math.max(-1, Math.min(1, (trace - 1) / 2))), axis = [1, 0, 0], diff = [m[6] - m[9], m[8] - m[2], m[1] - m[4]], sl = Math.sqrt(diff[0] ** 2 + diff[1] ** 2 + diff[2] ** 2);
            if (sl > 0.001) axis = [diff[0] / sl, diff[1] / sl, diff[2] / sl];
            state.returning = { active: true, progress: 0, baseRotation: m, rotationAxis: axis, rotationAngle: -angle, startDist: Vec3.len(state.cameraPos), targetDist: getResponsiveZ(), coneStartPositions: state.cones.map(c => [...c.pos]) };
            state.landing.active = false; state.landing.showHandle = false;
        };

        function loop(ts) {
            const dt = Math.min((ts - state.lastTime) / 1000, 0.1); state.lastTime = ts;

            if (document.body.classList.contains('light-mode') && state.hasRotated) {
                document.body.style.backgroundColor = rgbToHex(...getSurfaceColor([0, 0, 1], [0, 0, 1]));
            }
            if (state.valueScrub.active && Math.abs(state.valueScrub.startY - state.mouse.y) > 5) {
                state.cones[state.valueScrub.coneIndex].pos[state.valueScrub.coordIndex] += Math.sign(state.valueScrub.startY - state.mouse.y) * Math.pow((Math.abs(state.valueScrub.startY - state.mouse.y) - 5) / 500, 3) * .05;
            }

            // --- ZOOM INTERACTION LOGIC ---
            // Zoom based on path length - longer path = more zoom
            let manualCameraZ = null;
            if (state.mouse.down && state.interaction && state.interaction.mode === 'zoom') {
                // Calculate total path length on sphere surface
                let pathLength = 0;
                for (let i = 1; i < state.pathPoints.length; i++) {
                    pathLength += Vec3.dist(state.pathPoints[i], state.pathPoints[i - 1]);
                }

                // Normalize: ~3.14 (half circumference) = full zoom
                const zoomProgress = Math.min(1, pathLength / Math.PI);
                const startZ = state.interaction.startZ;
                const targetZ = 1.25;

                manualCameraZ = startZ - (startZ - targetZ) * zoomProgress;
                state.cameraPos = [0, 0, manualCameraZ];
            }

            if (state.landing.active) {
                state.landing.progress = Math.min(state.landing.progress + dt * .5, 1);
                const t = state.landing.progress;
                if (t >= 1 && !state.landing.notified) {
                    window.parent.postMessage({ type: 'zoom-complete', color: state.landing.hex }, '*');
                    state.landing.notified = true;
                }
                if (t >= 1) {
                    const card = document.getElementById('login-card');
                    if (window.self === window.top && !card.classList.contains('visible')) { card.classList.add('visible'); card.style.opacity = ''; }
                    if (state.landing.shouldAutoEnter) {
                        if (window.enterRoomUI && window.self === window.top) window.enterRoomUI();
                        state.landing.shouldAutoEnter = false;
                    }
                }
                const rot = Mat4.rotationAxis(state.landing.rotationAxis, state.landing.rotationAngle * t * t);
                if (state.landing.showHandle) { state.handle.pos = transformPos(state.landing.handleStartPos, rot); if (t >= 1) state.landing.showHandle = false; }
                state.sphere.rotation = Mat4.multiply(rot, state.landing.baseRotation);
                state.cones.forEach((c, i) => c.pos = transformPos(state.landing.coneStartPositions[i], rot));
                state.cameraPos = Vec3.scale(Vec3.normalize([0, 0, 4]), state.landing.startDist + (state.landing.targetDist - state.landing.startDist) * t * t * t);
            }
            if (state.returning && state.returning.active) {
                state.returning.progress = Math.min(state.returning.progress + dt * 1.5, 1);
                const t = state.returning.progress, ease = 1 - Math.pow(1 - t, 3), rot = Mat4.rotationAxis(state.returning.rotationAxis, state.returning.rotationAngle * ease);
                state.sphere.rotation = Mat4.multiply(rot, state.returning.baseRotation);
                state.cameraPos = [0, 0, state.returning.startDist + (state.returning.targetDist - state.returning.startDist) * ease];
                state.cones.forEach((c, i) => c.pos = transformPos(state.returning.coneStartPositions[i], rot));
                if (t >= 1) {
                    state.returning.active = false; state.hasRotated = false; state.sphere.rotation = Mat4.identity();
                    state.cones = defaultCones.map(c => ({ ...c, pos: [...c.pos], color: [...c.color] }));
                    state.cameraPos = [0, 0, getResponsiveZ()];
                    document.body.style.backgroundColor = ''; document.getElementById('color-hex').innerText = "#FFFFFF";
                    document.getElementById('login-card').style.color = ''; document.getElementById('top-nav').style.removeProperty('--nav-color');
                    document.getElementById('login-card').style.opacity = ''; document.getElementById('login-card').style.transition = '';
                }
            }

            let renderBackgroundLayer = false;
            let bgCameraPos = [0, 0, 0];

            if (manualCameraZ === null && state.peeking && (state.peeking.active || state.peeking.value > 0)) {
                const zoomedInZ = state.landing.targetDist || 1.25;
                const zoomedOutZ = state.landing.startDist || 4.0;
                const t = state.peeking.value;
                const ease = t * t * (3 - 2 * t);
                const currentZ = zoomedInZ + (zoomedOutZ - zoomedInZ) * ease;
                state.cameraPos = [0, 0, currentZ];
                if (t > 0.01) {
                    renderBackgroundLayer = true;
                    bgCameraPos = [0, 0, zoomedInZ];
                }
            }

            state.vpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(state.cameraPos, [0, 0, 0], [0, 1, 0]));
            if (!document.body.classList.contains('light-mode')) {
                state.cones.forEach((c, i) => {
                    const cache = state.uiCache[i]; if (!cache) return;
                    if (cache.lastActive !== c.active) { cache.title.style.color = c.active ? c.cssColor : 'grey'; cache.lastActive = c.active; }
                    ['x', 'y', 'z'].forEach((ax, idx) => { if (Math.abs(c.pos[idx] - cache.lastPos[idx]) > 0.005) { cache[ax].innerText = c.pos[idx].toFixed(2); cache.lastPos[idx] = c.pos[idx]; } });
                });
                if (state.mouse.down) {
                    const tp = getTargetPos(state.mouse.x, state.mouse.y);
                    if (state.draggedConeIndex === -1 && tp) state.cones.forEach((c, i) => { if (c.active && Vec3.dist(c.pos, tp) < 0.8) state.draggedConeIndex = i; });
                    if (state.draggedConeIndex !== -1) { const np = calculateConePosition(state.mouse.x, state.mouse.y), c = state.cones[state.draggedConeIndex]; c.vel = Vec3.scale(Vec3.sub(np, c.pos), 1 / dt); c.pos = np; }
                } else state.draggedConeIndex = -1;
                state.cones.forEach(c => { if (state.draggedConeIndex === -1 || state.cones[state.draggedConeIndex] !== c) { if (Vec3.len(c.vel) > .001) { c.pos = Vec3.scale(Vec3.normalize(Vec3.add(c.pos, Vec3.scale(c.vel, dt))), 1.2); c.vel = Vec3.scale(c.vel, .95); } else c.pos = Vec3.scale(Vec3.normalize(c.pos), 1.2); } });
            } else if (state.mouse.down && state.dragStart.active) {
                state.landing.active = false; state.landing.showHandle = false;
                document.getElementById('login-card').classList.remove('visible'); document.getElementById('dashboard-panel').classList.remove('active');
                const tp = getTargetPos(state.mouse.x, state.mouse.y);
                if (tp) {
                    state.handle.pos = tp;
                    if (state.dragStart.lastTrackPos) { const axis = Vec3.cross(state.dragStart.lastTrackPos, tp); state.inertia = { active: false, axis: Vec3.len(axis) > 1e-5 ? Vec3.normalize(axis) : [1, 0, 0], val: Vec3.len(axis) }; }
                    state.dragStart.lastTrackPos = tp;
                    const a = Vec3.cross(state.dragStart.mouseDir, Vec3.normalize(tp));
                    if (Vec3.len(a) > .001) { const r = Mat4.rotationAxis(Vec3.normalize(a), Math.acos(Math.min(1, Math.max(-1, Vec3.dot(state.dragStart.mouseDir, Vec3.normalize(tp)))))); state.sphere.rotation = Mat4.multiply(r, state.dragStart.sphereRotation); state.cones.forEach((c, i) => c.pos = transformPos(state.dragStart.conePositions[i], r)); }
                }
            } else {
                state.dragStart.active = false; state.handle.active = false;
                if (state.inertia.val > 0.0001) { const r = Mat4.rotationAxis(state.inertia.axis, state.inertia.val); state.sphere.rotation = Mat4.multiply(r, state.sphere.rotation); state.cones.forEach(c => c.pos = transformPos(c.pos, r)); state.inertia.val *= 0.95; }
            }

            if (state.device && state.pipelines.sphere && state.msaaTexture) {
                const drawSphere = (encoder, viewProjMatrix, loadOp, depthOp) => {
                    state.uniforms.sphere.set(Mat4.multiply(viewProjMatrix, state.sphere.rotation), 0);
                    state.uniforms.sphere.set(state.sphere.rotation, 16); state.uniforms.sphere.set(state.sphere.rotation, 32); state.uniforms.sphere.set(state.cameraPos, 48);
                    [0, 1, 2].forEach(i => { state.uniforms.sphere.set(state.cones[i].pos, 52 + i * 8); state.uniforms.sphere.set(state.cones[i].active ? state.cones[i].color : [0, 0, 0], 56 + i * 8); });
                    state.uniforms.sphere[76] = state.debugMode ? 1.0 : 0.0;
                    state.device.queue.writeBuffer(state.buffers.sphereUniform, 0, state.uniforms.sphere);
                    const pass = encoder.beginRenderPass({
                        colorAttachments: [{ view: state.msaaTexture.createView(), resolveTarget: state.context.getCurrentTexture().createView(), clearValue: document.body.classList.contains('light-mode') ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, g: 0, b: 0, a: 1 }, loadOp: loadOp, storeOp: 'store' }],
                        depthStencilAttachment: { view: state.depthTexture.createView(), depthClearValue: 1, depthLoadOp: 'clear', depthStoreOp: depthOp }
                    });
                    pass.setPipeline(state.pipelines.sphere); pass.setBindGroup(0, state.bindGroups.sphere); pass.setVertexBuffer(0, state.buffers.sphereVertex); pass.setVertexBuffer(1, state.buffers.sphereNormal); pass.setIndexBuffer(state.buffers.sphereIndex, 'uint16'); pass.drawIndexed(state.sphere.indexCount);
                    return pass;
                };

                const drawCones = (pass) => {
                    pass.setPipeline(state.pipelines.cone); pass.setVertexBuffer(0, document.body.classList.contains('light-mode') ? state.buffers.sphereVertex : state.buffers.coneVertex); pass.setIndexBuffer(document.body.classList.contains('light-mode') ? state.buffers.sphereIndex : state.buffers.coneIndex, 'uint16');
                    if (!document.body.classList.contains('light-mode')) {
                        state.cones.forEach((c, i) => {
                            if (c.active) {
                                let m; if (Vec3.len(Vec3.cross([0, 1, 0], c.pos)) > .001) { const y = Vec3.normalize(c.pos), x = Vec3.normalize(Vec3.cross(Vec3.len(Vec3.cross([0, 1, 0], y)) < .01 ? [0, 0, 1] : [0, 1, 0], y)), z = Vec3.cross(x, y); m = [x[0], x[1], x[2], 0, y[0], y[1], y[2], 0, z[0], z[1], z[2], 0, c.pos[0], c.pos[1], c.pos[2], 1]; } else m = Mat4.multiply(Mat4.translation(c.pos), c.pos[1] < 0 ? Mat4.rotationX(Math.PI) : Mat4.identity());
                                state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(m, Mat4.scale([.5, .5, .5]))), 0); state.uniforms.cone.set([...c.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, i * 256, state.uniforms.cone); pass.setBindGroup(0, state.bindGroups.cones[i]); pass.drawIndexed(state.coneIndexCount);
                            }
                        });
                    } else {
                        let bindIdx = 4;
                        if (state.handle.active || state.landing.showHandle) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(state.handle.pos), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...state.handle.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, 3 * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(3)); pass.drawIndexed(state.sphere.indexCount); }
                        state.historyHandles.forEach(h => { const wp = transformPos(h.pos, state.sphere.rotation); if (wp[2] > -0.5) { state.uniforms.cone.set(Mat4.multiply(state.vpMatrix, Mat4.multiply(Mat4.translation(wp), Mat4.scale([.08, .08, .08]))), 0); state.uniforms.cone.set([...h.color, 1.0], 16); state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone); pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx)); pass.drawIndexed(state.sphere.indexCount); bindIdx++; } });


                        // Draw white path line on sphere surface during drag
                        if (state.pathPoints.length > 1 && (state.dragStart.active || state.landing.active)) {
                            const pathVerts = pathToVertices(state.pathPoints, state.sphere.rotation);
                            if (pathVerts && pathVerts.length > 0) {
                                // Create or update dynamic path buffer
                                if (!state.buffers.pathVertex || state.buffers.pathVertex.size < pathVerts.byteLength) {
                                    if (state.buffers.pathVertex) state.buffers.pathVertex.destroy();
                                    state.buffers.pathVertex = state.device.createBuffer({
                                        size: Math.max(pathVerts.byteLength, 1024 * 12), // Pre-allocate space
                                        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                                    });
                                }
                                state.device.queue.writeBuffer(state.buffers.pathVertex, 0, pathVerts);

                                // Use identity model matrix and white color
                                state.uniforms.cone.set(state.vpMatrix, 0);
                                state.uniforms.cone.set([1, 1, 1, 1], 16); // White color
                                state.device.queue.writeBuffer(state.buffers.coneUniform, bindIdx * 256, state.uniforms.cone);

                                pass.setPipeline(state.pipelines.cone);
                                pass.setBindGroup(0, state.getBindGroupForHandle(bindIdx));
                                pass.setVertexBuffer(0, state.buffers.pathVertex);
                                pass.draw(pathVerts.length / 3); // Draw as triangles
                            }
                        }
                    }
                };

                if (renderBackgroundLayer) {
                    const bgEncoder = state.device.createCommandEncoder();
                    const bgVpMatrix = Mat4.multiply(Mat4.perspective(Math.PI / 4, state.canvas.width / state.canvas.height, .001, 100), Mat4.lookAt(bgCameraPos, [0, 0, 0], [0, 1, 0]));
                    const bgPass = drawSphere(bgEncoder, bgVpMatrix, 'clear', 'discard');
                    bgPass.end(); state.device.queue.submit([bgEncoder.finish()]);
                    const fgEncoder = state.device.createCommandEncoder();
                    const fgPass = drawSphere(fgEncoder, state.vpMatrix, 'load', 'discard');
                    drawCones(fgPass); fgPass.end(); state.device.queue.submit([fgEncoder.finish()]);
                } else {
                    const encoder = state.device.createCommandEncoder();
                    const pass = drawSphere(encoder, state.vpMatrix, 'clear', 'discard');
                    drawCones(pass); pass.end(); state.device.queue.submit([encoder.finish()]);
                }
            }
            requestAnimationFrame(loop);
        }
        init();

        window.updateVisitedFromDB = async function () {
            const rooms = await (new window.ColorDB()).getAllRooms();
            state.historyHandles = [];
            if (rooms?.length) { rooms.forEach(r => { const p = findPositionFromColor('#' + r.hex); if (p) state.historyHandles.push({ pos: Vec3.normalize(p), color: hexToRgbNormalized('#' + r.hex), hex: '#' + r.hex, peerCount: 0 }); }); }
        };

        window.addEventListener("message", (e) => {
            if (e.data === "getSphereColor") e.source.postMessage(storageScope.getItem("lastSphereColor") || "#ff0000", e.origin);
            if (e.data?.type === 'handle-ready') {
                const hex = e.data.hex, pos = findPositionFromColor(hex);
                if (pos && !state.historyHandles.some(h => h.hex === hex)) {
                    state.historyHandles.push({ pos: Vec3.normalize(pos), color: hexToRgbNormalized(hex), hex, peerCount: e.data.count });
                    const d = document.createElement('div'); d.className = 'debug-room-item ' + (e.data.count > 0 ? 'active' : ''); d.innerHTML = `<span>${hex}</span> <span class="count">${e.data.count} peer(s)</span>`; document.getElementById('debug-rooms').appendChild(d);
                }
            }
        });

        async function initStorageAccess() {
            if (window.self === window.top) return;

            // Function to trigger zoom animation and notify parent when done
            const triggerZoomToColor = (hexColor) => {
                const matchPos = findPositionFromColor(hexColor);
                if (matchPos) {
                    // Switch to light mode for zoomed-in sphere view
                    if (!document.body.classList.contains('light-mode')) {
                        document.body.classList.add('light-mode');
                    }

                    // Trigger the landing animation
                    triggerLanding(Vec3.normalize(matchPos), matchPos, hexToRgbNormalized(hexColor), true);

                    // Watch for animation completion and send zoom-done
                    const checkLandingComplete = () => {
                        if (state.landing.progress >= 1) {
                            // Animation complete, send zoom-done to parent
                            window.parent.postMessage({ type: 'zoom-done', color: hexColor }, "*");
                        } else if (state.landing.active) {
                            requestAnimationFrame(checkLandingComplete);
                        }
                    };
                    requestAnimationFrame(checkLandingComplete);
                }
            };

            const access = async (h) => {
                try {
                    if (h?.localStorage) storageScope = h.localStorage;
                    const c = storageScope.getItem("lastSphereColor");
                    if (c) {
                        // Send color immediately for background styling
                        window.parent.postMessage(c, "*");
                        if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove();
                        document.body.style.backgroundColor = c;

                        // Trigger the zoom animation
                        triggerZoomToColor(c);
                    } else {
                        // No color stored - notify parent so it doesn't show product
                        window.parent.postMessage({ type: 'no-color' }, "*");
                        if (document.getElementById('saa-overlay')) document.getElementById('saa-overlay').remove();
                    }
                } catch (e) { }
            };
            try {
                if (await document.hasStorageAccess()) try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { access(null); }
                else {
                    const o = document.createElement('div'); o.id = 'saa-overlay'; Object.assign(o.style, { position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: '#fff', zIndex: 10000, display: 'flex', justifyContent: 'center', alignItems: 'center' });
                    const b = document.createElement("button"); b.innerText = "LOGIN"; Object.assign(b.style, { padding: "12px 24px", fontSize: "16px", cursor: "pointer", background: "#000", color: "#fff", border: "none", borderRadius: "8px" });
                    o.appendChild(b); document.body.appendChild(o); b.onclick = async () => { try { access(await document.requestStorageAccess({ localStorage: true })); } catch (e) { o.innerHTML = "Access Denied"; } };
                }
            } catch (e) { }
        }
        initStorageAccess();
    </script>
</body>

</html>
