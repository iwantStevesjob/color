<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Telemetry: Advanced Attestation</title>
    <style>
        :root {
            --bg: #050508;
            --card: #0f172a;
            --accent: #38bdf8;
            --danger: #ef4444;
            --success: #22c55e;
            --text: #f8fafc;
        }

        body {
            font-family: 'Monaco', 'Consolas', monospace;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }

        .terminal {
            background-color: var(--card);
            border: 1px solid #334155;
            border-radius: 12px;
            width: 100%;
            max-width: 480px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .header {
            background: #1e293b;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #334155;
        }

        .content { padding: 20px; }

        .viz-box {
            background: rgba(0,0,0,0.4);
            height: 120px;
            margin: 10px 0;
            border-radius: 8px;
            position: relative;
            border: 1px solid #1e293b;
        }

        canvas { width: 100%; height: 100%; }

        .status-badge {
            font-size: 0.7rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: #334155;
            text-transform: uppercase;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin: 8px 0;
            color: #94a3b8;
        }

        .metric-val { color: var(--accent); }

        .btn {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 15px;
            width: 100%;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: opacity 0.2s;
        }

        .btn:disabled { opacity: 0.3; cursor: not-allowed; }

        #log {
            font-size: 0.7rem;
            color: #64748b;
            height: 60px;
            overflow-y: auto;
            margin-top: 15px;
            border-top: 1px solid #1e293b;
            padding-top: 10px;
        }

        .alert {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.8rem;
            display: none;
        }
    </style>
</head>
<body>

<div class="terminal">
    <div class="header">
        <span>SECURITY_PROTOCOL_v4.2</span>
        <span id="shield-status" class="status-badge">Standby</span>
    </div>
    
    <div class="content">
        <div id="alert-box" class="alert"></div>

        <div class="metric-row">
            <span>CHALLENGE TYPE:</span>
            <span class="metric-val">Vibrational Nonce</span>
        </div>

        <div class="viz-box">
            <canvas id="bcgCanvas"></canvas>
            <div style="position:absolute; top:5px; left:10px; font-size:10px; color:#555;">HEART RECOIL (BCG)</div>
        </div>

        <div class="viz-box">
            <canvas id="jitterCanvas"></canvas>
            <div style="position:absolute; top:5px; left:10px; font-size:10px; color:#555;">TIMING JITTER (HARDWARE ATTESTATION)</div>
        </div>

        <div class="stats">
            <div class="metric-row">
                <span>TIMING ENTROPY:</span>
                <span id="val-entropy" class="metric-val">0.00ms</span>
            </div>
            <div class="metric-row">
                <span>REPLAY GUARD:</span>
                <span id="val-replay" class="metric-val">Inactive</span>
            </div>
            <div class="metric-row">
                <span>HEART RATE:</span>
                <span id="val-bpm" class="metric-val">-- BPM</span>
            </div>
        </div>

        <button id="start-btn" class="btn" onclick="initializeAuth()">AUTHORIZE DEVICE</button>
        
        <div id="log">Initializing sensors...</div>
    </div>
</div>

<script>
    const appConfig = {
        duration: 8000,
        challengePattern: [200, 100, 400], // Vibration pattern in ms
    };

    let recording = false;
    let data = [];
    let lastEventTime = null;
    let jitterLogs = [];

    const bcgCanvas = document.getElementById('bcgCanvas');
    const jitterCanvas = document.getElementById('jitterCanvas');
    const bCtx = bcgCanvas.getContext('2d');
    const jCtx = jitterCanvas.getContext('2d');

    function log(msg) {
        const l = document.getElementById('log');
        l.innerHTML = `> ${msg}<br>${l.innerHTML}`;
    }

    async function initializeAuth() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
                const res = await DeviceMotionEvent.requestPermission();
                if (res !== 'granted') return;
            } catch (e) { log("Permission Denied"); return; }
        }

        startScan();
    }

    function startScan() {
        recording = true;
        data = [];
        jitterLogs = [];
        lastEventTime = performance.now();
        
        document.getElementById('start-btn').disabled = true;
        document.getElementById('shield-status').innerText = "Scanning";
        document.getElementById('shield-status').style.background = "#eab308";
        
        // Start the Vibration Challenge (The "Nonce")
        // This embeds a unique physical signal into the stream
        if ("vibrate" in navigator) {
            log("Sending physical challenge...");
            navigator.vibrate(appConfig.challengePattern);
        }

        window.addEventListener('devicemotion', onMotion);
        
        setTimeout(stopScan, appConfig.duration);
        requestAnimationFrame(draw);
    }

    function onMotion(e) {
        if (!recording) return;
        
        const now = performance.now();
        const delta = now - lastEventTime;
        lastEventTime = now;

        const acc = e.accelerationIncludingGravity;
        if (!acc) return;

        data.push({ t: now, x: acc.x, y: acc.y, z: acc.z, dt: delta });
        
        // Track the timing jitter specifically
        if (jitterLogs.length > 100) jitterLogs.shift();
        jitterLogs.push(delta);
    }

    function stopScan() {
        recording = false;
        window.removeEventListener('devicemotion', onMotion);
        document.getElementById('start-btn').disabled = false;
        analyze();
    }

    function analyze() {
        log("Analyzing entropy...");
        
        // 1. Jitter Detection
        // Real hardware has variance. Bots are "perfect".
        const deltas = data.map(d => d.dt).filter(d => d > 0);
        const avg = deltas.reduce((a,b) => a+b, 0) / deltas.length;
        const variance = deltas.reduce((a,b) => a + Math.pow(b-avg, 2), 0) / deltas.length;
        const jitter = Math.sqrt(variance);
        
        document.getElementById('val-entropy').innerText = jitter.toFixed(4) + "ms";

        // 2. Replay/Pattern Detection
        // We look for the vibration pattern spikes in the Z-axis
        let challengeMet = false;
        const spikes = data.filter(d => Math.abs(d.z) > 15).length;
        if (spikes > 10) challengeMet = true; 
        
        document.getElementById('val-replay').innerText = challengeMet ? "Verified" : "Failed";

        // 3. Heart Rate Extraction
        const zData = data.map(d => d.z);
        const bpm = estimateBPM(zData);
        document.getElementById('val-bpm').innerText = bpm > 0 ? bpm + " BPM" : "Unstable";

        // Verdict
        const status = document.getElementById('shield-status');
        const alertBox = document.getElementById('alert-box');
        alertBox.style.display = "block";

        if (jitter < 0.001) {
            status.innerText = "REJECTED";
            status.style.background = var(--danger);
            alertBox.innerText = "CRITICAL: Clock-perfect timing detected. Virtual injector blocked.";
            alertBox.style.background = "rgba(239, 68, 68, 0.2)";
        } else if (!challengeMet) {
            status.innerText = "FAILED";
            alertBox.innerText = "FAILED: Device did not respond to physical challenge. Possible replay attack.";
        } else {
            status.innerText = "SECURE";
            status.style.background = "#22c55e";
            alertBox.innerText = "SUCCESS: Hardware attestation and biometric signature verified.";
            alertBox.style.background = "rgba(34, 197, 94, 0.2)";
        }
    }

    function estimateBPM(zs) {
        if (zs.length < 100) return 0;
        // Simple peak counting for demo
        let peaks = 0;
        const mean = zs.reduce((a,b) => a+b)/zs.length;
        for(let i=1; i<zs.length-1; i++) {
            if (zs[i] > mean + 0.1 && zs[i] > zs[i-1] && zs[i] > zs[i+1]) peaks++;
        }
        return Math.round((peaks / (appConfig.duration/1000)) * 60 / 2.5);
    }

    function draw() {
        if (!recording) return;

        // Draw Jitter Graph
        jCtx.clearRect(0,0,jitterCanvas.width, jitterCanvas.height);
        jCtx.strokeStyle = '#38bdf8';
        jCtx.beginPath();
        jitterLogs.forEach((v, i) => {
            const x = (i / jitterLogs.length) * jitterCanvas.width;
            const y = (jitterCanvas.height / 2) - (v - 16.6) * 10; // Center at 60fps (16.6ms)
            if (i === 0) jCtx.moveTo(x, y); else jCtx.lineTo(x, y);
        });
        jCtx.stroke();

        // Draw BCG Graph
        bCtx.clearRect(0,0,bcgCanvas.width, bcgCanvas.height);
        bCtx.strokeStyle = '#ef4444';
        bCtx.beginPath();
        const slice = data.slice(-100);
        const mean = slice.length ? slice.reduce((a,b)=>a+b.z,0)/slice.length : 0;
        slice.forEach((v, i) => {
            const x = (i / 100) * bcgCanvas.width;
            const y = (bcgCanvas.height/2) - (v.z - mean) * 200;
            if (i === 0) bCtx.moveTo(x, y); else bCtx.lineTo(x, y);
        });
        bCtx.stroke();

        requestAnimationFrame(draw);
    }
</script>

</body>
</html>

