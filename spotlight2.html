<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spotlight</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
// Vertex Shader
const vsSource = `
  attribute vec3 aPosition;
  attribute vec3 aNormal;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  uniform mat4 uNormalMatrix;

  varying vec3 vNormal;
  varying vec3 vPosition;

  void main(void) {
    vPosition = vec3(uModelViewMatrix * vec4(aPosition, 1.0));
    vNormal = mat3(uNormalMatrix) * aNormal;
    gl_Position = uProjectionMatrix * vec4(vPosition, 1.0);
  }
`;

// Fragment Shader
const fsSource = `
  precision mediump float;

  varying vec3 vNormal;
  varying vec3 vPosition;

  uniform vec3 uLightPosition;
  uniform vec3 uLightColor;
  uniform vec3 uObjectColor;

  void main(void) {
    vec3 normal = normalize(vNormal);
    vec3 lightDir = normalize(uLightPosition - vPosition);
    float diff = max(dot(normal, lightDir), 0.0);

    // Determine if the light is behind the surface
    float visibility = step(0.0, dot(normal, lightDir));

    // Eclipse effect: reduce diffuse component if light is behind
    vec3 diffuse = diff * uLightColor * visibility;
    vec3 ambient = 0.1 * uObjectColor;

    gl_FragColor = vec4(diffuse + ambient, 1.0);
  }
`;

// Initialize WebGL
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if (!gl) {
  alert('WebGL not supported in this browser.');
}

// Compile Shader
function compileShader(source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

// Create Shader Program
function createShaderProgram(vsSource, fsSource) {
  const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error('Unable to initialize the shader program:', gl.getProgramInfoLog(shaderProgram));
    return null;
  }
  return shaderProgram;
}

const shaderProgram = createShaderProgram(vsSource, fsSource);
gl.useProgram(shaderProgram);

// Get attribute and uniform locations
const attribLocations = {
  position: gl.getAttribLocation(shaderProgram, 'aPosition'),
  normal: gl.getAttribLocation(shaderProgram, 'aNormal'),
};

const uniformLocations = {
  projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
  modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
  normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
  lightPosition: gl.getUniformLocation(shaderProgram, 'uLightPosition'),
  lightColor: gl.getUniformLocation(shaderProgram, 'uLightColor'),
  objectColor: gl.getUniformLocation(shaderProgram, 'uObjectColor'),
};

// Geometry Creation Functions
function createSphere(radius, latitudeBands, longitudeBands) {
  const positions = [];
  const normals = [];
  const indices = [];

  for (let lat = 0; lat <= latitudeBands; lat++) {
    const theta = lat * Math.PI / latitudeBands;
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);

    for (let lon = 0; lon <= longitudeBands; lon++) {
      const phi = lon * 2 * Math.PI / longitudeBands;
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);

      const x = cosPhi * sinTheta;
      const y = cosTheta;
      const z = sinPhi * sinTheta;

      normals.push(x, y, z);
      positions.push(radius * x, radius * y, radius * z);
    }
  }

  for (let lat = 0; lat < latitudeBands; lat++) {
    for (let lon = 0; lon < longitudeBands; lon++) {
      const first = (lat * (longitudeBands + 1)) + lon;
      const second = first + longitudeBands + 1;

      indices.push(first, second, first + 1);
      indices.push(second, second + 1, first + 1);
    }
  }

  return {
    positions: new Float32Array(positions),
    normals: new Float32Array(normals),
    indices: new Uint16Array(indices),
  };
}

function createCone(radius, height, segments) {
  const positions = [];
  const normals = [];
  const indices = [];

  // Apex of the cone
  positions.push(0, height, 0);
  normals.push(0, 1, 0); // Will be recalculated per face

  // Base circle
  for (let i = 0; i <= segments; i++) {
    const theta = i * 2 * Math.PI / segments;
    const x = radius * Math.cos(theta);
    const z = radius * Math.sin(theta);
    positions.push(x, 0, z);

    // Calculate normals for the cone side
    const normal = normalize([x, radius / height, z]);
    normals.push(...normal);
  }

  // Indices for the cone sides
  for (let i = 1; i <= segments; i++) {
    indices.push(0, i, i + 1);
  }

  return {
    positions: new Float32Array(positions),
    normals: new Float32Array(normals),
    indices: new Uint16Array(indices),
  };
}

// Utility function to normalize a vector
function normalize(v) {
  const len = Math.hypot(...v);
  return v.map(component => component / len);
}

// Create Sphere and Cone
const sphere = createSphere(1, 30, 30);
const cone = createCone(0.3, 2, 30);

// Create Buffers
function createBuffer(data, type, usage) {
  const buffer = gl.createBuffer();
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, data, usage);
  return buffer;
}

// Sphere Buffers
const spherePositionBuffer = createBuffer(sphere.positions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
const sphereNormalBuffer = createBuffer(sphere.normals, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
const sphereIndexBuffer = createBuffer(sphere.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);

// Cone Buffers
const conePositionBuffer = createBuffer(cone.positions, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
const coneNormalBuffer = createBuffer(cone.normals, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
const coneIndexBuffer = createBuffer(cone.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);

// Enable Attributes for Sphere
function bindAttributes(positionBuffer, normalBuffer) {
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(attribLocations.position);
  gl.vertexAttribPointer(attribLocations.position, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.enableVertexAttribArray(attribLocations.normal);
  gl.vertexAttribPointer(attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
}

// Set up Projection Matrix
function resizeCanvasToDisplaySize(canvas) {
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
  }
}

const fieldOfView = 45 * Math.PI / 180; // in radians
let aspect = canvas.clientWidth / canvas.clientHeight;
const zNear = 0.1;
const zFar = 100.0;

// Simple Matrix Library
const mat4 = {
  create: function() {
    return new Float32Array([
      1, 0, 0, 0,
      0, 1, 0, 0, 
      0, 0, 1, 0,
      0, 0, 0, 1
    ]);
  },
  perspective: function(out, fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;

    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;

    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) / (near - far);
    out[11] = -1;

    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) / (near - far);
    out[15] = 0;
  },
  translate: function(out, a, v) {
    const x = v[0], y = v[1], z = v[2];
    out[12] = a[0] * x + a[4] * y + a[8]  * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9]  * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    return out;
  },
  lookAt: function(out, eye, center, up) {
    const x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
      return this.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.hypot(y0, y1, y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
  },
  invert: function(out, a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
  },
};

// Initialize Matrices
const projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
gl.uniformMatrix4fv(uniformLocations.projectionMatrix, false, projectionMatrix);

// Set up View Matrix (Camera)
const viewMatrix = mat4.create();
mat4.lookAt(viewMatrix, [0, 2, 6], [0, 0, 0], [0, 1, 0]);

// Enable Depth Test
gl.enable(gl.DEPTH_TEST);

// Set Light and Object Colors
gl.uniform3f(uniformLocations.lightColor, 1.0, 1.0, 1.0); // White light
gl.uniform3f(uniformLocations.objectColor, 0.6, 0.6, 0.8); // Light blue objects

// Handle Mouse Movement
let mouseX = 0;
let mouseY = 0;

canvas.addEventListener('mousemove', (event) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
});

// Animation Loop
function render() {
  resizeCanvasToDisplaySize(canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
  gl.uniformMatrix4fv(uniformLocations.projectionMatrix, false, projectionMatrix);

  gl.clearColor(0.1, 0.1, 0.1, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Calculate Light Position
  let lightX = mouseX * 3;
  let lightY = mouseY * 3;
  let lightZ = 2;

  // Simple projection check: if cursor is over the sphere (radius 1)
  const distance = Math.hypot(mouseX, mouseY);
  if (distance <= 1) {
    lightZ = 0;
  } else {
    // Move light behind the sphere based on distance
    lightZ = -distance;
  }

  gl.uniform3f(uniformLocations.lightPosition, lightX, lightY, lightZ);

  // Render Sphere
  bindAttributes(spherePositionBuffer, sphereNormalBuffer);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);

  // Model Matrix for Sphere
  const sphereModelMatrix = mat4.create();
  mat4.translate(sphereModelMatrix, sphereModelMatrix, [0, 0, 0]);

  // Calculate Normal Matrix
  const normalMatrix = mat4.create();
  mat4.invert(normalMatrix, sphereModelMatrix);
  // Transpose is not necessary for uniform lighting
  gl.uniformMatrix4fv(uniformLocations.modelViewMatrix, false, sphereModelMatrix);
  gl.uniformMatrix4fv(uniformLocations.normalMatrix, false, normalMatrix);

  gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);

  // Render Cone
  bindAttributes(conePositionBuffer, coneNormalBuffer);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coneIndexBuffer);

  // Model Matrix for Cone (hovering above the sphere)
  const coneModelMatrix = mat4.create();
  mat4.translate(coneModelMatrix, coneModelMatrix, [0, 1.5, 0]); // Adjust height as needed

  // Calculate Normal Matrix for Cone
  const normalMatrixCone = mat4.create();
  mat4.invert(normalMatrixCone, coneModelMatrix);
  gl.uniformMatrix4fv(uniformLocations.modelViewMatrix, false, coneModelMatrix);
  gl.uniformMatrix4fv(uniformLocations.normalMatrix, false, normalMatrixCone);

  gl.drawElements(gl.TRIANGLES, cone.indices.length, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

</script>
</body>
</html>