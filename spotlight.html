<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RGB</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        .spotlight-indicator {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            pointer-events: none;
        }
        #red-indicator { background-color: red; }
        #green-indicator { background-color: green; }
        #blue-indicator { background-color: blue; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="red-indicator" class="spotlight-indicator"></div>
    <div id="green-indicator" class="spotlight-indicator"></div>
    <div id="blue-indicator" class="spotlight-indicator"></div>
    <script>
        // Define mat4 object
        const mat4 = {
            create: function() {
                let out = new Float32Array(16);
                out[0] = 1;
                out[5] = 1;
                out[10] = 1;
                out[15] = 1;
                return out;
            },

            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            },

            translate: function(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                let a00, a01, a02, a03;
                let a10, a11, a12, a13;
                let a20, a21, a22, a23;

                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }

                return out;
            },

            perspective: function(out, fovy, aspect, near, far) {
                let f = 1.0 / Math.tan(fovy / 2);
                let nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            }
        };

        let gl;
        let shaderProgram;
        let sphereVertexPositionBuffer;
        let sphereVertexNormalBuffer;
        let sphereVertexIndexBuffer;
        let lightPositions = [
            [0, 0, 5], // Red light
            [0, 0, 5], // Green light
            [0, 0, 5]  // Blue light
        ];
        const lightColors = [
            [1.0, 0.0, 0.0], // Red
            [0.0, 1.0, 0.0], // Green
            [0.0, 0.0, 1.0]  // Blue
        ];

        const vsSource = `
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main(void) {
                vPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
                vNormal = normalize((uMVMatrix * vec4(aVertexNormal, 0.0)).xyz);
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 uLightPositions[3];
            uniform vec3 uLightColors[3];
            void main(void) {
                vec3 totalDiffuse = vec3(0.0, 0.0, 0.0);
                for(int i = 0; i < 3; i++) {
                    vec3 lightDir = normalize(uLightPositions[i] - vPosition);
                    float diff = max(dot(vNormal, lightDir), 0.0);
                    totalDiffuse += diff * uLightColors[i];
                }
                // Clamp the final color to [0.0, 1.0]
                totalDiffuse = clamp(totalDiffuse, 0.0, 1.0);
                gl_FragColor = vec4(totalDiffuse, 1.0);
            }
        `;

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialize WebGL.");
            }
        }

        function initShaders() {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialize shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.lightPositionsUniform = gl.getUniformLocation(shaderProgram, "uLightPositions");
            shaderProgram.lightColorsUniform = gl.getUniformLocation(shaderProgram, "uLightColors");
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            const latitudeBands = 30;
            const longitudeBands = 30;
            const radius = 1;

            const vertexPositionData = [];
            const normalData = [];
            for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                const theta = latNumber * Math.PI / latitudeBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    const phi = longNumber * 2 * Math.PI / longitudeBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    vertexPositionData.push(radius * x);
                    vertexPositionData.push(radius * y);
                    vertexPositionData.push(radius * z);

                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                }
            }

            const indexData = [];
            for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    const first = (latNumber * (longitudeBands + 1)) + longNumber;
                    const second = first + longitudeBands + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);

                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                }
            }

            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numItems = vertexPositionData.length / 3;

            sphereVertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
            sphereVertexNormalBuffer.itemSize = 3;
            sphereVertexNormalBuffer.numItems = normalData.length / 3;

            sphereVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            sphereVertexIndexBuffer.itemSize = 1;
            sphereVertexIndexBuffer.numItems = indexData.length;
        }

        let mvMatrix = mat4.create();
        let pMatrix = mat4.create();

        function setMatrixUniforms() {
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        }

        function drawScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective(pMatrix, 45 * Math.PI / 180, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, sphereVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            setMatrixUniforms();

            // Pass light positions and colors to the shader
            gl.uniform3fv(shaderProgram.lightPositionsUniform, new Float32Array(lightPositions.flat()));
            gl.uniform3fv(shaderProgram.lightColorsUniform, new Float32Array(lightColors.flat()));

            gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function updateSpotlightIndicators(xRed, yRed, xGreen, yGreen, xBlue, yBlue) {
            const redIndicator = document.getElementById('red-indicator');
            const greenIndicator = document.getElementById('green-indicator');
            const blueIndicator = document.getElementById('blue-indicator');

            redIndicator.style.left = `${xRed}px`;
            redIndicator.style.top = `${yRed}px`;

            greenIndicator.style.left = `${xGreen}px`;
            greenIndicator.style.top = `${yGreen}px`;

            blueIndicator.style.left = `${xBlue}px`;
            blueIndicator.style.top = `${yBlue}px`;
        }

        function webGLStart() {
            const canvas = document.getElementById("glCanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGL(canvas);
            initShaders();
            initBuffers();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            // Initialize light positions to center
            lightPositions = [
                [0, 0, 5], // Red
                [0, 0, 5], // Green
                [0, 0, 5]  // Blue
            ];

            canvas.onmousemove = function(event) {
                const rect = canvas.getBoundingClientRect();

                // Calculate normalized coordinates for each light
                // For simplicity, let's position all lights based on the mouse position
                const x = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / canvas.height) * 2 + 1;

                const distanceSquared = x * x + y * y;

                // Calculate z for each light
                const zRed = (1 - distanceSquared >= 0) 
                    ? Math.sqrt(1 - distanceSquared) 
                    : -Math.sqrt(distanceSquared - 1);
                const zGreen = zRed; // Same for simplicity
                const zBlue = zRed;  // Same for simplicity

                // Scale light positions
                lightPositions = [
                    [x * 5, y * 5, zRed * 5],    // Red
                    [x * 5, y * 5, zGreen * 5],  // Green
                    [x * 5, y * 5, zBlue * 5]    // Blue
                ];

                // Update indicators positions
                const indicatorX = event.clientX;
                const indicatorY = event.clientY;

                updateSpotlightIndicators(indicatorX, indicatorY, indicatorX, indicatorY, indicatorX, indicatorY);

                drawScene();
            };

            canvas.ontouchmove = function(event) {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const touch = event.touches[0];

                // Calculate normalized coordinates for each light
                const x = ((touch.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((touch.clientY - rect.top) / canvas.height) * 2 + 1;

                const distanceSquared = x * x + y * y;

                // Calculate z for each light
                const zRed = (1 - distanceSquared >= 0) 
                    ? Math.sqrt(1 - distanceSquared) 
                    : -Math.sqrt(distanceSquared - 1);
                const zGreen = zRed; // Same for simplicity
                const zBlue = zRed;  // Same for simplicity

                // Scale light positions
                lightPositions = [
                    [x * 5, y * 5, zRed * 5],    // Red
                    [x * 5, y * 5, zGreen * 5],  // Green
                    [x * 5, y * 5, zBlue * 5]    // Blue
                ];

                // Update indicators positions
                const indicatorX = touch.clientX;
                const indicatorY = touch.clientY;

                updateSpotlightIndicators(indicatorX, indicatorY, indicatorX, indicatorY, indicatorX, indicatorY);

                drawScene();
            };

            drawScene();
        }

        window.onload = webGLStart;
    </script>
</body>
</html>