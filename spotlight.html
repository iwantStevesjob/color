<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotlight on Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        #spotlight-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: white;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="spotlight-indicator"></div>
    <script>
        // Define mat4 object
        const mat4 = {
            create: function() {
                let out = new Float32Array(16);
                out[0] = 1;
                out[5] = 1;
                out[10] = 1;
                out[15] = 1;
                return out;
            },

            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            },

            translate: function(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                let a00, a01, a02, a03;
                let a10, a11, a12, a13;
                let a20, a21, a22, a23;

                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }

                return out;
            },

            perspective: function(out, fovy, aspect, near, far) {
                let f = 1.0 / Math.tan(fovy / 2);
                let nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            }
        };

        let gl;
        let shaderProgram;
        let sphereVertexPositionBuffer;
        let sphereVertexNormalBuffer;
        let sphereVertexIndexBuffer;
        let lightPosition = [0, 0, 5];

        const vsSource = `
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main(void) {
                vPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
                vNormal = (uMVMatrix * vec4(aVertexNormal, 0.0)).xyz;
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 uLightPosition;
            void main(void) {
                vec3 lightDir = normalize(uLightPosition - vPosition);
                float diff = max(dot(normalize(vNormal), lightDir), 0.0);
                gl_FragColor = vec4(diff, diff, diff, 1.0);
            }
        `;

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialize WebGL.");
            }
        }

        function initShaders() {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialize shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.lightPositionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            const latitudeBands = 30;
            const longitudeBands = 30;
            const radius = 1;

            const vertexPositionData = [];
            const normalData = [];
            for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                const theta = latNumber * Math.PI / latitudeBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    const phi = longNumber * 2 * Math.PI / longitudeBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    vertexPositionData.push(radius * x);
                    vertexPositionData.push(radius * y);
                    vertexPositionData.push(radius * z);

                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                }
            }

            const indexData = [];
            for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    const first = (latNumber * (longitudeBands + 1)) + longNumber;
                    const second = first + longitudeBands + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);

                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                }
            }

            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numItems = vertexPositionData.length / 3;

            sphereVertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
            sphereVertexNormalBuffer.itemSize = 3;
            sphereVertexNormalBuffer.numItems = normalData.length / 3;

            sphereVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            sphereVertexIndexBuffer.itemSize = 1;
            sphereVertexIndexBuffer.numItems = indexData.length;
        }

        let mvMatrix = mat4.create();
        let pMatrix = mat4.create();

        function setMatrixUniforms() {
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        }

        function drawScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective(pMatrix, 45 * Math.PI / 180, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);

            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -5.0]);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, sphereVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            setMatrixUniforms();
            gl.uniform3fv(shaderProgram.lightPositionUniform, lightPosition);
            gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function updateSpotlightIndicator(x, y) {
            const indicator = document.getElementById('spotlight-indicator');
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
        }

        function webGLStart() {
            const canvas = document.getElementById("glCanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGL(canvas);
            initShaders();
            initBuffers();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            canvas.onmousemove = function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / canvas.height) * 2 + 1;
                const z = Math.sqrt(1 - x*x - y*y);
                lightPosition = [x * 5, y * 5, z * 5];
                updateSpotlightIndicator(event.clientX, event.clientY);
                drawScene();
            };

            canvas.ontouchmove = function(event) {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = ((event.touches[0].clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((event.touches[0].clientY - rect.top) / canvas.height) * 2 + 1;
                const z = Math.sqrt(1 - x*x - y*y);
                lightPosition = [x * 5, y * 5, z * 5];
                updateSpotlightIndicator(event.touches[0].clientX, event.touches[0].clientY);
                drawScene();
            };

            drawScene();
        }

        window.onload = webGLStart;
    </script>
</body>
</html>