<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Spotlight on Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        let gl;
        let shaderProgram;
        let sphereVertexPositionBuffer;
        let sphereVertexNormalBuffer;
        let sphereVertexIndexBuffer;
        let lightPosition = [0, 0, 5];

        const vsSource = `
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main(void) {
                vPosition = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
                vNormal = (uMVMatrix * vec4(aVertexNormal, 0.0)).xyz;
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 uLightPosition;
            void main(void) {
                vec3 lightDir = normalize(uLightPosition - vPosition);
                float diff = max(dot(normalize(vNormal), lightDir), 0.0);
                gl_FragColor = vec4(diff, diff, diff, 1.0);
            }
        `;

        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialize WebGL.");
            }
        }

        function initShaders() {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialize shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.lightPositionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            const latitudeBands = 30;
            const longitudeBands = 30;
            const radius = 1;

            const vertexPositionData = [];
            const normalData = [];
            for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                const theta = latNumber * Math.PI / latitudeBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    const phi = longNumber * 2 * Math.PI / longitudeBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    vertexPositionData.push(radius * x);
                    vertexPositionData.push(radius * y);
                    vertexPositionData.push(radius * z);

                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                }
            }

            const indexData = [];
            for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    const first = (latNumber * (longitudeBands + 1)) + longNumber;
                    const second = first + longitudeBands + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);

                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                }
            }

            sphereVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            sphereVertexPositionBuffer.itemSize = 3;
            sphereVertexPositionBuffer.numItems = vertexPositionData.length / 3;

            sphereVertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
            sphereVertexNormalBuffer.itemSize = 3;
            sphereVertexNormalBuffer.numItems = normalData.length / 3;

            sphereVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            sphereVertexIndexBuffer.itemSize = 1;
            sphereVertexIndexBuffer.numItems = indexData.length;
        }

        let mvMatrix = mat4.create();
        let pMatrix = mat4.create();

        function setMatrixUniforms() {
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
        }

        function drawScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [0.0, 0.0, -5.0]);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, sphereVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
            setMatrixUniforms();
            gl.uniform3fv(shaderProgram.lightPositionUniform, lightPosition);
            gl.drawElements(gl.TRIANGLES, sphereVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }

        function webGLStart() {
            const canvas = document.getElementById("glCanvas");
            initGL(canvas);
            initShaders();
            initBuffers();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            canvas.onmousemove = function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / canvas.height) * 2 + 1;
                const z = Math.sqrt(1 - x*x - y*y);
                lightPosition = [x * 5, y * 5, z * 5];
                drawScene();
            };

            drawScene();
        }

        // Simple matrix library
        const mat4 = {
            create: function() {
                return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
            },
            identity: function(mat) {
                mat[0] = 1; mat[1] = 0; mat[2] = 0; mat[3] = 0;
                mat[4] = 0; mat[5] = 1; mat[6] = 0; mat[7] = 0;
                mat[8] = 0; mat[9] = 0; mat[10] = 1; mat[11] = 0;
                mat[12] = 0; mat[13] = 0; mat[14] = 0; mat[15] = 1;
            },
            translate: function(mat, vec) {
                mat[12] = mat[0] * vec[0] + mat[4] * vec[1] + mat[8] * vec[2] + mat[12];
                mat[13] = mat[1] * vec[0] + mat[5] * vec[1] + mat[9] * vec[2] + mat[13];
                mat[14] = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14];
                mat[15] = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15];
            },
            perspective: function(fovy, aspect, near, far, mat) {
                const f = 1.0 / Math.tan(fovy / 2);
                mat[0] = f / aspect;
                mat[1] = 0;
                mat[2] = 0;
                mat[3] = 0;
                mat[4] = 0;
                mat[5] = f;
                mat[6] = 0;
                mat[7] = 0;
                mat[8] = 0;
                mat[9] = 0;
                mat[11] = -1;
                mat[12] = 0;
                mat[13] = 0;
                mat[15] = 0;
                if (far != null && far !== Infinity) {
                    const nf = 1 / (near - far);
                    mat[10] = (far + near) * nf;
                    mat[14] = 2 * far * near * nf;
                } else {
                    mat[10] = -1;
                    mat[14] = -2 * near;
                }
            }
        };

        window.onload = webGLStart;
    </script>
</body>
</html>