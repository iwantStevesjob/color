<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="description" content="WebRTC File Transfer via Trystero">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <title>P2P File Transfer (BitTorrent Signaling)</title>
    
    <!-- CSS Styles -->
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 1em;
            word-break: break-word;
            background-color: #fafafa;
        }
        div#container {
            margin: 0 auto 0 auto;
            max-width: 60em;
            padding: 1em 1.5em 1.3em 1.5em;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }
        h1 {
            border-bottom: 1px solid #ccc;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            margin: 0 0 0.8em 0;
            padding-bottom: 0.2em;
        }
        div.input {
            margin: 0 0 1em 0;
        }
        
        progress {
            width: 100%;
            margin-bottom: 10px;
            height: 20px;
        }
        
        div.progress-label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        #status {
            color: #d32f2f;
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }

        a#download {
            display: none;
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: #1a73e8;
            text-decoration: none;
            border: 1px solid #1a73e8;
            padding: 10px;
            text-align: center;
        }
        
        a#download:hover {
            background-color: #e8f0fe;
        }
    </style>
</head>
<body>

<div id="container">
    <h1>P2P File Transfer</h1>
    <p>Open this page on two different devices. Wait for them to connect, then choose a file.</p>

    <div class="input">
        <input type="file" id="fileInput" disabled>
    </div>

    <div class="progress-label">Send progress:</div>
    <progress id="sendProgress" max="0" value="0"></progress>

    <div class="progress-label">Receive progress:</div>
    <progress id="receiveProgress" max="0" value="0"></progress>

    <div id="bitrate"></div>
    <a id="download"></a>
    <span id="status">Initializing Trystero (BitTorrent)...</span>
</div>

<!-- Main JavaScript Logic (ES Module) -->
<script type="module">
    // 1. IMPORT TRYSTERO DIRECTLY
    import { joinRoom, selfId } from 'https://esm.run/trystero/torrent'; 

    'use strict';

    // Trystero Configuration
    const roomConfig = { appId: 'trystero-file-transfer-demo-v2' };
    const roomName = 'transfer-room-global';
    
    let room;
    let sendFileSignal;
    let sendChunkSignal;
    let peers = [];

    // UI Elements
    const bitrateDiv = document.querySelector('div#bitrate');
    const fileInput = document.querySelector('input#fileInput');
    const downloadAnchor = document.querySelector('a#download');
    const sendProgress = document.querySelector('progress#sendProgress');
    const receiveProgress = document.querySelector('progress#receiveProgress');
    const statusMessage = document.querySelector('span#status');

    // Transfer State
    let receiveBuffer = [];
    let receivedSize = 0;
    let incomingFileInfo = null;

    let bytesPrev = 0;
    let timestampPrev = 0;
    let timestampStart;
    let statsInterval = null;
    let bitrateMax = 0;

    // Standard chunk size
    const chunkSize = 16384; 
    let fileReader;

    initTrystero();

    function initTrystero() {
        // 2. USE joinRoom DIRECTLY (No "Trystero." prefix)
        room = joinRoom(roomConfig, roomName);

        // Define Actions (Signals)
        const [sendMeta, getMeta] = room.makeAction('file-meta');
        sendFileSignal = sendMeta;

        const [sendChunk, getChunk] = room.makeAction('file-chunk');
        sendChunkSignal = sendChunk;

        // Handle Peer Connections
        room.onPeerJoin(peerId => {
            console.log(`Peer joined: ${peerId}`);
            peers.push(peerId);
            updateStatus();
        });

        room.onPeerLeave(peerId => {
            console.log(`Peer left: ${peerId}`);
            peers = peers.filter(p => p !== peerId);
            updateStatus();
        });

        // Handle Incoming Metadata
        getMeta((data, peerId) => {
            console.log("Received Metadata:", data);
            
            incomingFileInfo = data;
            receiveBuffer = [];
            receivedSize = 0;
            bytesPrev = 0;
            bitrateMax = 0;
            
            receiveProgress.max = data.size;
            receiveProgress.value = 0;
            downloadAnchor.textContent = '';
            downloadAnchor.removeAttribute('href');
            downloadAnchor.style.display = 'none';
            
            timestampStart = (new Date()).getTime();
            timestampPrev = timestampStart;
            statsInterval = setInterval(displayStats, 500);
            
            statusMessage.textContent = `Receiving ${data.name}...`;
        });

        // Handle Incoming Chunks
        getChunk((data, peerId) => {
            let chunk = data;
            
            // Safety check for array types
            if (!(chunk instanceof Uint8Array) && !(chunk instanceof ArrayBuffer)) {
                 chunk = new Uint8Array(Object.values(data));
            }

            receiveBuffer.push(chunk);
            receivedSize += chunk.byteLength || chunk.length;
            receiveProgress.value = receivedSize;

            if (receivedSize >= incomingFileInfo.size) {
                const received = new Blob(receiveBuffer);
                receiveBuffer = []; 

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = incomingFileInfo.name;
                downloadAnchor.textContent = `Download '${incomingFileInfo.name}' (${formatBytes(incomingFileInfo.size)})`;
                downloadAnchor.style.display = 'inline-block';
                statusMessage.textContent = 'Transfer Complete!';

                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                    displayStats(); 
                }
            }
        });
        
        statusMessage.textContent = `Initialized. ID: ${selfId}. Waiting for peers...`;
    }

    function updateStatus() {
        if (peers.length > 0) {
            statusMessage.textContent = `Connected to ${peers.length} peer(s). Ready to transfer.`;
            statusMessage.style.color = 'green';
            fileInput.disabled = false;
        } else {
            statusMessage.textContent = 'Waiting for another device to join...';
            statusMessage.style.color = '#d32f2f';
            fileInput.disabled = true;
        }
    }

    // Sender Logic
    fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (!file) return;
        if (peers.length === 0) {
            alert("No peers connected!");
            return;
        }

        console.log(`Sending file: ${file.name}`);
        statusMessage.textContent = `Sending ${file.name}...`;

        // Send Metadata
        sendFileSignal({
            name: file.name,
            size: file.size,
            type: file.type
        });

        sendProgress.max = file.size;
        sendProgress.value = 0;

        // Read and Send Chunks
        let offset = 0;
        fileReader = new FileReader();

        fileReader.addEventListener('error', error => console.error('Error reading file:', error));
        fileReader.addEventListener('load', e => {
            const arrayBuffer = e.target.result;
            
            sendChunkSignal(arrayBuffer);
            
            offset += arrayBuffer.byteLength;
            sendProgress.value = offset;

            if (offset < file.size) {
                setTimeout(() => readSlice(offset), 0);
            } else {
                statusMessage.textContent = 'File Sent!';
                fileInput.value = ''; 
            }
        });

        const readSlice = o => {
            const slice = file.slice(o, o + chunkSize);
            fileReader.readAsArrayBuffer(slice);
        };

        readSlice(0);
    });

    function displayStats() {
        const currentTimestamp = (new Date()).getTime();
        const duration = currentTimestamp - timestampPrev;
        
        if (duration > 0 && receivedSize > 0) {
            const bitRate = Math.round((receivedSize - bytesPrev) * 8 / duration);
            bitrateDiv.innerHTML = `<strong>Current Speed:</strong> ${bitRate} kbits/sec`;
        }
        timestampPrev = currentTimestamp;
        bytesPrev = receivedSize;
    }
    
    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

</script>
</body>
</html>
