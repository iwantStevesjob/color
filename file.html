<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="description" content="WebRTC File Transfer via Trystero">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <title>P2P File Transfer (BitTorrent Signaling)</title>
    
    <!-- CSS Styles -->
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 1em;
            word-break: break-word;
        }
        div#container {
            margin: 0 auto 0 auto;
            max-width: 60em;
            padding: 1em 1.5em 1.3em 1.5em;
        }
        h1 {
            border-bottom: 1px solid #ccc;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            margin: 0 0 0.8em 0;
            padding-bottom: 0.2em;
        }
        div.input {
            margin: 0 0 1em 0;
        }
        
        progress {
            width: 100%;
            margin-bottom: 10px;
        }
        
        div.progress-label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        #status {
            color: #d32f2f;
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }

        a#download {
            display: block;
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        button {
            background-color: #d84a38;
            border: none;
            border-radius: 2px;
            box-shadow: 0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12);
            color: white;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8em;
            margin: 0 10px 20px 0;
            padding: 0.5em 0.8em 0.5em 0.8em;
            text-transform: uppercase;
        }

        button:hover {
            background-color: #c13e2c;
        }

        button:disabled {
            background-color: #ccc;
            color: #999;
            cursor: default;
            box-shadow: none;
        }
    </style>
</head>
<body>

<div id="container">
    <h1>P2P File Transfer</h1>
    <p>Open this page on two different devices. Wait for them to connect, then choose a file.</p>

    <div class="input">
        <input type="file" id="fileInput" disabled>
    </div>

    <div class="progress-label">Send progress:</div>
    <progress id="sendProgress" max="0" value="0"></progress>

    <div class="progress-label">Receive progress:</div>
    <progress id="receiveProgress" max="0" value="0"></progress>

    <div id="bitrate"></div>
    <a id="download"></a>
    <span id="status">Initializing Trystero (BitTorrent)...</span>
</div>

<!-- Import Trystero (BitTorrent version) -->
<script src="https://unpkg.com/trystero/dist/trystero-torrent.min.js"></script>

<!-- Main JavaScript Logic -->
<script>
    'use strict';

    // Trystero Configuration
    // We use a fixed room ID so any two devices running this code will find each other
    const roomConfig = { appId: 'trystero-file-transfer-demo' };
    const roomName = 'transfer-room-v1';
    
    let room;
    let sendFileSignal;
    let sendChunkSignal;
    let peers = [];

    // UI Elements
    const bitrateDiv = document.querySelector('div#bitrate');
    const fileInput = document.querySelector('input#fileInput');
    const downloadAnchor = document.querySelector('a#download');
    const sendProgress = document.querySelector('progress#sendProgress');
    const receiveProgress = document.querySelector('progress#receiveProgress');
    const statusMessage = document.querySelector('span#status');

    // Transfer State
    let receiveBuffer = [];
    let receivedSize = 0;
    let incomingFileInfo = null;

    let bytesPrev = 0;
    let timestampPrev = 0;
    let timestampStart;
    let statsInterval = null;
    let bitrateMax = 0;

    // Standard chunk size
    const chunkSize = 16384; 
    let fileReader;

    initTrystero();

    function initTrystero() {
        // 1. Join the room
        room = Trystero.joinRoom(roomConfig, roomName);

        // 2. Define Actions (Signals)
        // Action to send file metadata (name, size, type)
        const [sendMeta, getMeta] = room.makeAction('file-meta');
        sendFileSignal = sendMeta;

        // Action to send binary chunks
        const [sendChunk, getChunk] = room.makeAction('file-chunk');
        sendChunkSignal = sendChunk;

        // 3. Handle Peer Connections
        room.onPeerJoin(peerId => {
            console.log(`Peer joined: ${peerId}`);
            peers.push(peerId);
            updateStatus();
        });

        room.onPeerLeave(peerId => {
            console.log(`Peer left: ${peerId}`);
            peers = peers.filter(p => p !== peerId);
            updateStatus();
        });

        // 4. Handle Incoming Data (Receiver Logic)
        getMeta((data, peerId) => {
            console.log("Received Metadata:", data);
            
            // Prepare for new file
            incomingFileInfo = data;
            receiveBuffer = [];
            receivedSize = 0;
            bytesPrev = 0;
            bitrateMax = 0;
            
            // Reset UI
            receiveProgress.max = data.size;
            receiveProgress.value = 0;
            downloadAnchor.textContent = '';
            downloadAnchor.removeAttribute('href');
            
            timestampStart = (new Date()).getTime();
            timestampPrev = timestampStart;
            statsInterval = setInterval(displayStats, 500);
            
            statusMessage.textContent = `Receiving ${data.name}...`;
        });

        getChunk((data, peerId) => {
            // "data" is the binary chunk (Uint8Array or ArrayBuffer)
            
            // If data comes in as a raw array (Trystero sometimes unpacks ArrayBuffers to Arrays), fix it:
            let chunk = data;
            if (!(chunk instanceof Uint8Array) && !(chunk instanceof ArrayBuffer)) {
                 chunk = new Uint8Array(Object.values(data));
            }

            receiveBuffer.push(chunk);
            receivedSize += chunk.byteLength || chunk.length;
            receiveProgress.value = receivedSize;

            if (receivedSize >= incomingFileInfo.size) {
                // Transfer Complete
                const received = new Blob(receiveBuffer);
                receiveBuffer = []; // clear memory

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = incomingFileInfo.name;
                downloadAnchor.textContent = `Click to download '${incomingFileInfo.name}' (${incomingFileInfo.size} bytes)`;
                downloadAnchor.style.display = 'block';
                statusMessage.textContent = 'Transfer Complete!';

                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                    displayStats(); // Final stats
                }
            }
        });
    }

    function updateStatus() {
        if (peers.length > 0) {
            statusMessage.textContent = `Connected to ${peers.length} peer(s). Ready to transfer.`;
            statusMessage.style.color = 'green';
            fileInput.disabled = false;
        } else {
            statusMessage.textContent = 'Waiting for another device to join...';
            statusMessage.style.color = '#d32f2f';
            fileInput.disabled = true;
        }
    }

    // Sender Logic
    fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (!file) return;
        if (peers.length === 0) {
            alert("No peers connected!");
            return;
        }

        console.log(`Sending file: ${file.name}`);
        statusMessage.textContent = `Sending ${file.name}...`;

        // 1. Send Metadata
        sendFileSignal({
            name: file.name,
            size: file.size,
            type: file.type
        });

        sendProgress.max = file.size;
        sendProgress.value = 0;

        // 2. Read and Send Chunks
        let offset = 0;
        fileReader = new FileReader();

        fileReader.addEventListener('error', error => console.error('Error reading file:', error));
        fileReader.addEventListener('load', e => {
            // Send the chunk
            const arrayBuffer = e.target.result;
            
            // Send to all peers
            sendChunkSignal(arrayBuffer);
            
            offset += arrayBuffer.byteLength;
            sendProgress.value = offset;

            if (offset < file.size) {
                // Read next slice
                // Simple flow control: using setTimeout(0) to allow UI updates and prevent freezing
                // Real WebRTC backpressure is handled internally by Trystero/Browser, 
                // but flooding the loop can freeze the main thread.
                setTimeout(() => readSlice(offset), 0);
            } else {
                statusMessage.textContent = 'File Sent!';
                fileInput.value = ''; // Reset input
            }
        });

        const readSlice = o => {
            const slice = file.slice(o, o + chunkSize);
            fileReader.readAsArrayBuffer(slice);
        };

        readSlice(0);
    });

    function displayStats() {
        const currentTimestamp = (new Date()).getTime();
        const duration = currentTimestamp - timestampPrev;
        
        if (duration > 0 && receivedSize > 0) {
            const bitRate = Math.round((receivedSize - bytesPrev) * 8 / duration);
            bitrateDiv.innerHTML = `<strong>Current Speed:</strong> ${bitRate} kbits/sec`;
            
            if (bitRate > bitrateMax) {
                bitrateMax = bitRate;
            }
        }
        timestampPrev = currentTimestamp;
        bytesPrev = receivedSize;
    }

</script>
</body>
</html>
