<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="description" content="WebRTC File Transfer Sample">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <title>WebRTC Data Channel File Transfer</title>

    <!-- CSS Styles -->
    <style>
        /* General Layout based on WebRTC samples main.css */
        body {
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 1em;
            word-break: break-word;
        }
        div#container {
            margin: 0 auto 0 auto;
            max-width: 60em;
            padding: 1em 1.5em 1.3em 1.5em;
        }
        h1 {
            border-bottom: 1px solid #ccc;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            margin: 0 0 0.8em 0;
            padding-bottom: 0.2em;
        }
        div.input {
            margin: 0 0 1em 0;
        }
        
        /* Specific Styles for File Transfer */
        progress {
            width: 100%;
            margin-bottom: 10px;
        }
        
        div.progress-label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        #status {
            color: #d32f2f;
            font-weight: bold;
            margin-top: 10px;
        }

        a#download {
            display: block;
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        button {
            background-color: #d84a38;
            border: none;
            border-radius: 2px;
            box-shadow: 0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12);
            color: white;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8em;
            margin: 0 10px 20px 0;
            padding: 0.5em 0.8em 0.5em 0.8em;
            text-transform: uppercase;
        }

        button:hover {
            box-shadow: 0 5px 11px 0 rgba(0,0,0,.18), 0 4px 15px 0 rgba(0,0,0,.15);
            background-color: #c13e2c;
        }

        button:disabled {
            background-color: #ccc;
            color: #999;
            cursor: default;
            box-shadow: none;
        }
    </style>
</head>

<body>

<div id="container">
    <h1>WebRTC Data Channel File Transfer</h1>
    <p>This page shows how to transfer a file via WebRTC datachannels. The file is split into chunks and transferred via the datachannel. The <code>RTCPeerConnection</code> objects (local and remote) are in the same page to demonstrate the logic without a server.</p>

    <div class="input">
        <input type="file" id="fileInput" disabled>
        <button id="abortButton" disabled>Abort Transfer</button>
    </div>

    <div class="progress-label">Send progress:</div>
    <progress id="sendProgress" max="0" value="0"></progress>

    <div class="progress-label">Receive progress:</div>
    <progress id="receiveProgress" max="0" value="0"></progress>

    <div id="bitrate"></div>
    <a id="download"></a>
    <span id="status"></span>
</div>

<!-- WebRTC Adapter for cross-browser compatibility -->
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

<!-- Main JavaScript Logic -->
<script>
    'use strict';

    let localConnection;
    let remoteConnection;
    let sendChannel;
    let receiveChannel;
    let fileReader;
    
    const bitrateDiv = document.querySelector('div#bitrate');
    const fileInput = document.querySelector('input#fileInput');
    const abortButton = document.querySelector('button#abortButton');
    const downloadAnchor = document.querySelector('a#download');
    const sendProgress = document.querySelector('progress#sendProgress');
    const receiveProgress = document.querySelector('progress#receiveProgress');
    const statusMessage = document.querySelector('span#status');

    let receiveBuffer = [];
    let receivedSize = 0;

    let bytesPrev = 0;
    let timestampPrev = 0;
    let timestampStart;
    let statsInterval = null;
    let bitrateMax = 0;

    // Standard chunk size for WebRTC is 16KB
    const chunkSize = 16384; 

    fileInput.addEventListener('change', handleFileInputChange, false);
    abortButton.addEventListener('click', () => {
        if (fileReader && fileReader.readyState === 1) {
            console.log('Abort read!');
            fileReader.abort();
        }
    });

    // Automatically create connection on load
    createConnection();

    async function createConnection() {
        abortButton.disabled = true;
        const configuration = null; // No STUN/TURN needed for local connection

        // Create the local peer connection
        localConnection = new RTCPeerConnection(configuration);

        // Create the data channel on the local connection
        sendChannel = localConnection.createDataChannel('sendDataChannel');
        sendChannel.binaryType = 'arraybuffer';
        sendChannel.onopen = onSendChannelStateChange;
        sendChannel.onclose = onSendChannelStateChange;

        // Create the remote peer connection
        remoteConnection = new RTCPeerConnection(configuration);
        
        // Handle ICE candidates
        localConnection.onicecandidate = e => {
            onIceCandidate(localConnection, e);
        };
        remoteConnection.onicecandidate = e => {
            onIceCandidate(remoteConnection, e);
        };

        // When remote receives a data channel
        remoteConnection.ondatachannel = receiveChannelCallback;

        // Exchange Offer/Answer
        try {
            const offer = await localConnection.createOffer();
            await localConnection.setLocalDescription(offer);
            await remoteConnection.setRemoteDescription(offer);

            const answer = await remoteConnection.createAnswer();
            await remoteConnection.setLocalDescription(answer);
            await localConnection.setRemoteDescription(answer);
        } catch (e) {
            console.error('Connection failed:', e);
        }
    }

    function onIceCandidate(pc, event) {
        getOtherPc(pc)
            .addIceCandidate(event.candidate)
            .then(
                () => console.log('AddIceCandidate success'),
                (err) => console.error('AddIceCandidate failed', err)
            );
    }

    function getOtherPc(pc) {
        return (pc === localConnection) ? remoteConnection : localConnection;
    }

    function sendData() {
        const file = fileInput.files[0];
        console.log(`File is ${[file.name, file.size, file.type, file.lastModified].join(' ')}`);

        // Reset UI
        statusMessage.textContent = '';
        downloadAnchor.textContent = '';
        if (file.size === 0) {
            statusMessage.textContent = 'File is empty, please select a non-empty file';
            closeDataChannels();
            return;
        }
        
        sendProgress.max = file.size;
        receiveProgress.max = file.size;
        
        fileReader = new FileReader();
        let offset = 0;
        
        fileReader.addEventListener('error', error => console.error('Error reading file:', error));
        fileReader.addEventListener('abort', event => console.log('File reading aborted:', event));
        
        fileReader.addEventListener('load', e => {
            // Send the chunk
            sendChannel.send(e.target.result);
            offset += e.target.result.byteLength;
            sendProgress.value = offset;
            
            if (offset < file.size) {
                readSlice(offset);
            }
        });

        const readSlice = o => {
            const slice = file.slice(offset, o + chunkSize);
            fileReader.readAsArrayBuffer(slice);
        };

        // Handle Backpressure (Flow Control)
        // If the buffer is full, wait until it drains before reading/sending next chunk
        const bufferHighThreshold = 65536; // 64KB
        
        const readSliceWrapper = (o) => {
             if (sendChannel.bufferedAmount > bufferHighThreshold) {
                 // Wait for the buffer to drain
                 const onBufferedAmountLow = () => {
                     sendChannel.removeEventListener('bufferedamountlow', onBufferedAmountLow);
                     readSliceWrapper(o);
                 };
                 sendChannel.addEventListener('bufferedamountlow', onBufferedAmountLow);
                 return;
             }
             const slice = file.slice(o, o + chunkSize);
             fileReader.readAsArrayBuffer(slice);
        };
        
        readSliceWrapper(0);
    }

    function handleFileInputChange() {
        const file = fileInput.files[0];
        if (!file) {
            console.log('No file chosen');
        } else {
            sendData();
        }
    }

    function receiveChannelCallback(event) {
        console.log('Receive Channel Callback');
        receiveChannel = event.channel;
        receiveChannel.binaryType = 'arraybuffer';
        receiveChannel.onmessage = onReceiveMessageCallback;
        receiveChannel.onopen = onReceiveChannelStateChange;
        receiveChannel.onclose = onReceiveChannelStateChange;

        receivedSize = 0;
        bitrateMax = 0;
        downloadAnchor.textContent = '';
        downloadAnchor.removeAttribute('download');
        
        if (downloadAnchor.href) {
            URL.revokeObjectURL(downloadAnchor.href);
            downloadAnchor.removeAttribute('href');
        }
    }

    function onReceiveMessageCallback(event) {
        receiveBuffer.push(event.data);
        receivedSize += event.data.byteLength;

        receiveProgress.value = receivedSize;

        // Determine if transfer is complete
        const file = fileInput.files[0];
        if (receivedSize === file.size) {
            const received = new Blob(receiveBuffer);
            receiveBuffer = [];

            downloadAnchor.href = URL.createObjectURL(received);
            downloadAnchor.download = file.name;
            downloadAnchor.textContent = `Click to download '${file.name}' (${file.size} bytes)`;
            downloadAnchor.style.display = 'block';

            // Calculate bitrate stats
            const bitrate = Math.round(receivedSize * 8 / ((new Date()).getTime() - timestampStart));
            bitrateDiv.innerHTML = `<strong>Average Bitrate:</strong> ${bitrate} kbits/sec (max: ${bitrateMax} kbits/sec)`;

            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }

            closeDataChannels();
        }
    }

    function onSendChannelStateChange() {
        const readyState = sendChannel.readyState;
        console.log('Send channel state is: ' + readyState);
        if (readyState === 'open') {
            fileInput.disabled = false;
            fileInput.focus();
        } else {
            fileInput.disabled = true;
            abortButton.disabled = true;
        }
    }

    function onReceiveChannelStateChange() {
        const readyState = receiveChannel.readyState;
        console.log(`Receive channel state is: ${readyState}`);
        if (readyState === 'open') {
            timestampStart = (new Date()).getTime();
            timestampPrev = timestampStart;
            statsInterval = setInterval(displayStats, 500);
            displayStats();
        }
    }

    function displayStats() {
        if (remoteConnection && remoteConnection.iceConnectionState === 'connected') {
            const currentTimestamp = (new Date()).getTime();
            if (bytesPrev > 0) {
                const bitRate = Math.round((receivedSize - bytesPrev) * 8 / (currentTimestamp - timestampPrev));
                bitrateDiv.innerHTML = `<strong>Current Bitrate:</strong> ${bitRate} kbits/sec`;
                
                if (bitRate > bitrateMax) {
                    bitrateMax = bitRate;
                }
            }
            timestampPrev = currentTimestamp;
            bytesPrev = receivedSize;
        }
    }
    
    function closeDataChannels() {
        console.log('Closing data channels');
        sendChannel.close();
        console.log('Closed data channel with label: ' + sendChannel.label);
        if (receiveChannel) {
            receiveChannel.close();
            console.log('Closed data channel with label: ' + receiveChannel.label);
        }
        localConnection.close();
        remoteConnection.close();
        localConnection = null;
        remoteConnection = null;
        console.log('Closed peer connections');
        
        // Re-enable connection for next file? 
        // In this demo logic, we must reload or re-call createConnection.
        // For simplicity, we create a new connection immediately to allow another transfer.
        setTimeout(createConnection, 500);
    }
</script>

</body>
</html>
