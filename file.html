<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>P2P File Transfer (Trystero BitTorrent)</title>
    <style>
        body { font-family: 'Roboto', sans-serif; padding: 2em; background: #f9f9f9; }
        #container { max-width: 600px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; font-size: 1.5rem; }
        progress { width: 100%; height: 20px; margin: 10px 0; }
        .status { font-weight: bold; margin: 15px 0; color: #d32f2f; }
        .connected { color: #2e7d32; }
        #download { display: none; background: #007bff; color: white; padding: 10px; text-decoration: none; border-radius: 4px; text-align: center; margin-top: 10px; }
        input[type="file"] { margin: 20px 0; }
    </style>
</head>
<body>

<div id="container">
    <h1>P2P File Transfer</h1>
    <p>Open this page on two devices. Once they discover each other via BitTorrent trackers, the file input will enable.</p>
    
    <div id="connectionStatus" class="status">Initializing BitTorrent signaling...</div>

    <input type="file" id="fileInput" disabled>

    <div id="progressArea" style="display:none;">
        <label id="progressLabel">Transfer Progress:</label>
        <progress id="transferProgress" value="0" max="100"></progress>
        <div id="speed">Speed: 0 KB/s</div>
    </div>

    <a id="download" href="#">Download Received File</a>
</div>

<!-- Use Script Type Module to support imports -->
<script type="module">
    // Import from ESM-compatible CDN
    import { joinRoom } from 'https://esm.run/trystero/torrent';

    const statusEl = document.getElementById('connectionStatus');
    const fileInput = document.getElementById('fileInput');
    const progressArea = document.getElementById('progressArea');
    const progressBar = document.getElementById('transferProgress');
    const progressLabel = document.getElementById('progressLabel');
    const downloadBtn = document.getElementById('download');
    const speedEl = document.getElementById('speed');

    // Configuration
    const config = { appId: 'my-unique-file-transfer-app-123' };
    const room = joinRoom(config, 'global-file-room');

    // Define the "file-transfer" action
    // Trystero handles chunking and reassembly automatically for large data!
    const [sendFile, getFile] = room.makeAction('file-transfer');

    let startTime;

    // --- RECEIVER LOGIC ---
    getFile((data, peerId, metadata) => {
        console.log('Receiving file:', metadata.name);
        
        // Convert the received ArrayBuffer/Uint8Array to a Blob
        const blob = new Blob([data]);
        const url = URL.createObjectURL(blob);
        
        downloadBtn.href = url;
        downloadBtn.download = metadata.name;
        downloadBtn.textContent = `Download "${metadata.name}" (${(metadata.size / 1024 / 1024).toFixed(2)} MB)`;
        downloadBtn.style.display = 'block';
        
        statusEl.textContent = 'File received successfully!';
        progressArea.style.display = 'none';
    }, {
        // This callback tracks the progress of the incoming file
        onProgress: (progress) => {
            progressArea.style.display = 'block';
            progressLabel.textContent = "Receiving File...";
            progressBar.value = progress * 100;
        }
    });

    // --- SENDER LOGIC ---
    fileInput.addEventListener('change', async () => {
        const file = fileInput.files[0];
        if (!file) return;

        statusEl.textContent = `Sending ${file.name}...`;
        progressArea.style.display = 'block';
        progressLabel.textContent = "Sending File...";
        startTime = Date.now();

        // Trystero's makeAction sender accepts: (data, targetPeers, metadata, onProgress)
        // We pass 'null' for targetPeers to send to everyone in the room.
        await sendFile(file, null, { name: file.name, size: file.size }, (progress) => {
            progressBar.value = progress * 100;
            
            // Basic speed calculation
            const elapsed = (Date.now() - startTime) / 1000;
            const sentBits = progress * file.size;
            const kbps = (sentBits / 1024 / elapsed).toFixed(2);
            speedEl.textContent = `Speed: ${kbps} KB/s`;
        });

        statusEl.textContent = 'File sent!';
        fileInput.value = ''; // Reset
    });

    // --- ROOM EVENTS ---
    room.onPeerJoin(peerId => {
        console.log('Peer joined:', peerId);
        statusEl.textContent = 'Peer Connected. Ready to transfer.';
        statusEl.className = 'status connected';
        fileInput.disabled = false;
    });

    room.onPeerLeave(peerId => {
        console.log('Peer left:', peerId);
        if (Object.keys(room.getPeers()).length === 0) {
            statusEl.textContent = 'Waiting for peers...';
            statusEl.className = 'status';
            fileInput.disabled = true;
        }
    });
</script>

</body>
</html>        }
        
        div.progress-label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        #status {
            color: #d32f2f;
            font-weight: bold;
            display: block;
            margin-top: 10px;
        }

        a#download {
            display: block;
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        button {
            background-color: #d84a38;
            border: none;
            border-radius: 2px;
            box-shadow: 0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12);
            color: white;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 0.8em;
            margin: 0 10px 20px 0;
            padding: 0.5em 0.8em 0.5em 0.8em;
            text-transform: uppercase;
        }

        button:hover {
            background-color: #c13e2c;
        }

        button:disabled {
            background-color: #ccc;
            color: #999;
            cursor: default;
            box-shadow: none;
        }
    </style>
</head>
<body>

<div id="container">
    <h1>P2P File Transfer</h1>
    <p>Open this page on two different devices. Wait for them to connect, then choose a file.</p>

    <div class="input">
        <input type="file" id="fileInput" disabled>
    </div>

    <div class="progress-label">Send progress:</div>
    <progress id="sendProgress" max="0" value="0"></progress>

    <div class="progress-label">Receive progress:</div>
    <progress id="receiveProgress" max="0" value="0"></progress>

    <div id="bitrate"></div>
    <a id="download"></a>
    <span id="status">Initializing Trystero (BitTorrent)...</span>
</div>

<!-- Import Trystero (BitTorrent version) -->
<script src="https://unpkg.com/trystero/dist/trystero-torrent.min.js"></script>

<!-- Main JavaScript Logic -->
<script>
    'use strict';

    // Trystero Configuration
    // We use a fixed room ID so any two devices running this code will find each other
    const roomConfig = { appId: 'trystero-file-transfer-demo' };
    const roomName = 'transfer-room-v1';
    
    let room;
    let sendFileSignal;
    let sendChunkSignal;
    let peers = [];

    // UI Elements
    const bitrateDiv = document.querySelector('div#bitrate');
    const fileInput = document.querySelector('input#fileInput');
    const downloadAnchor = document.querySelector('a#download');
    const sendProgress = document.querySelector('progress#sendProgress');
    const receiveProgress = document.querySelector('progress#receiveProgress');
    const statusMessage = document.querySelector('span#status');

    // Transfer State
    let receiveBuffer = [];
    let receivedSize = 0;
    let incomingFileInfo = null;

    let bytesPrev = 0;
    let timestampPrev = 0;
    let timestampStart;
    let statsInterval = null;
    let bitrateMax = 0;

    // Standard chunk size
    const chunkSize = 16384; 
    let fileReader;

    initTrystero();

    function initTrystero() {
        // 1. Join the room
        room = Trystero.joinRoom(roomConfig, roomName);

        // 2. Define Actions (Signals)
        // Action to send file metadata (name, size, type)
        const [sendMeta, getMeta] = room.makeAction('file-meta');
        sendFileSignal = sendMeta;

        // Action to send binary chunks
        const [sendChunk, getChunk] = room.makeAction('file-chunk');
        sendChunkSignal = sendChunk;

        // 3. Handle Peer Connections
        room.onPeerJoin(peerId => {
            console.log(`Peer joined: ${peerId}`);
            peers.push(peerId);
            updateStatus();
        });

        room.onPeerLeave(peerId => {
            console.log(`Peer left: ${peerId}`);
            peers = peers.filter(p => p !== peerId);
            updateStatus();
        });

        // 4. Handle Incoming Data (Receiver Logic)
        getMeta((data, peerId) => {
            console.log("Received Metadata:", data);
            
            // Prepare for new file
            incomingFileInfo = data;
            receiveBuffer = [];
            receivedSize = 0;
            bytesPrev = 0;
            bitrateMax = 0;
            
            // Reset UI
            receiveProgress.max = data.size;
            receiveProgress.value = 0;
            downloadAnchor.textContent = '';
            downloadAnchor.removeAttribute('href');
            
            timestampStart = (new Date()).getTime();
            timestampPrev = timestampStart;
            statsInterval = setInterval(displayStats, 500);
            
            statusMessage.textContent = `Receiving ${data.name}...`;
        });

        getChunk((data, peerId) => {
            // "data" is the binary chunk (Uint8Array or ArrayBuffer)
            
            // If data comes in as a raw array (Trystero sometimes unpacks ArrayBuffers to Arrays), fix it:
            let chunk = data;
            if (!(chunk instanceof Uint8Array) && !(chunk instanceof ArrayBuffer)) {
                 chunk = new Uint8Array(Object.values(data));
            }

            receiveBuffer.push(chunk);
            receivedSize += chunk.byteLength || chunk.length;
            receiveProgress.value = receivedSize;

            if (receivedSize >= incomingFileInfo.size) {
                // Transfer Complete
                const received = new Blob(receiveBuffer);
                receiveBuffer = []; // clear memory

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = incomingFileInfo.name;
                downloadAnchor.textContent = `Click to download '${incomingFileInfo.name}' (${incomingFileInfo.size} bytes)`;
                downloadAnchor.style.display = 'block';
                statusMessage.textContent = 'Transfer Complete!';

                if (statsInterval) {
                    clearInterval(statsInterval);
                    statsInterval = null;
                    displayStats(); // Final stats
                }
            }
        });
    }

    function updateStatus() {
        if (peers.length > 0) {
            statusMessage.textContent = `Connected to ${peers.length} peer(s). Ready to transfer.`;
            statusMessage.style.color = 'green';
            fileInput.disabled = false;
        } else {
            statusMessage.textContent = 'Waiting for another device to join...';
            statusMessage.style.color = '#d32f2f';
            fileInput.disabled = true;
        }
    }

    // Sender Logic
    fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (!file) return;
        if (peers.length === 0) {
            alert("No peers connected!");
            return;
        }

        console.log(`Sending file: ${file.name}`);
        statusMessage.textContent = `Sending ${file.name}...`;

        // 1. Send Metadata
        sendFileSignal({
            name: file.name,
            size: file.size,
            type: file.type
        });

        sendProgress.max = file.size;
        sendProgress.value = 0;

        // 2. Read and Send Chunks
        let offset = 0;
        fileReader = new FileReader();

        fileReader.addEventListener('error', error => console.error('Error reading file:', error));
        fileReader.addEventListener('load', e => {
            // Send the chunk
            const arrayBuffer = e.target.result;
            
            // Send to all peers
            sendChunkSignal(arrayBuffer);
            
            offset += arrayBuffer.byteLength;
            sendProgress.value = offset;

            if (offset < file.size) {
                // Read next slice
                // Simple flow control: using setTimeout(0) to allow UI updates and prevent freezing
                // Real WebRTC backpressure is handled internally by Trystero/Browser, 
                // but flooding the loop can freeze the main thread.
                setTimeout(() => readSlice(offset), 0);
            } else {
                statusMessage.textContent = 'File Sent!';
                fileInput.value = ''; // Reset input
            }
        });

        const readSlice = o => {
            const slice = file.slice(o, o + chunkSize);
            fileReader.readAsArrayBuffer(slice);
        };

        readSlice(0);
    });

    function displayStats() {
        const currentTimestamp = (new Date()).getTime();
        const duration = currentTimestamp - timestampPrev;
        
        if (duration > 0 && receivedSize > 0) {
            const bitRate = Math.round((receivedSize - bytesPrev) * 8 / duration);
            bitrateDiv.innerHTML = `<strong>Current Speed:</strong> ${bitRate} kbits/sec`;
            
            if (bitRate > bitrateMax) {
                bitrateMax = bitRate;
            }
        }
        timestampPrev = currentTimestamp;
        bytesPrev = receivedSize;
    }

</script>
</body>
</html>
