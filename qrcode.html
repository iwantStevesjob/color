<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ISO/IEC 18004 QR Encoder (Pure JS)</title>
<style>
    body { font-family: system-ui, sans-serif; padding: 20px; }
    input { width: 500px; padding: 8px; font-size: 16px; }
    canvas { margin-top: 20px; image-rendering: pixelated; }
</style>
</head>
<body>

<h2>General QR Encoder (ISO/IEC 18004)</h2>
<input id="text" value="https://example.com">
<br>
<canvas id="qr" width="420" height="420"></canvas>

<script>
/* ============================================================
   BIT BUFFER
============================================================ */
class BitBuffer {
    constructor() { this.bits = []; }
    push(val, len) {
        for (let i = len - 1; i >= 0; i--)
            this.bits.push((val >>> i) & 1);
    }
    get length() { return this.bits.length; }
}

/* ============================================================
   GF(256) + REED SOLOMON
============================================================ */
const GF_EXP = new Uint8Array(512);
const GF_LOG = new Uint8Array(256);
(function(){
    let x = 1;
    for (let i = 0; i < 255; i++) {
        GF_EXP[i] = x;
        GF_LOG[x] = i;
        x <<= 1;
        if (x & 0x100) x ^= 0x11d;
    }
    for (let i = 255; i < 512; i++) GF_EXP[i] = GF_EXP[i - 255];
})();
const gfMul = (a,b)=> a && b ? GF_EXP[GF_LOG[a]+GF_LOG[b]] : 0;

function rsGenerator(deg) {
    let poly = [1];
    for (let i = 0; i < deg; i++) {
        const next = Array(poly.length + 1).fill(0);
        for (let j = 0; j < poly.length; j++) {
            next[j] ^= poly[j];
            next[j+1] ^= gfMul(poly[j], GF_EXP[i]);
        }
        poly = next;
    }
    return poly;
}
function rsEncode(data, ecLen) {
    const gen = rsGenerator(ecLen);
    const res = Array(ecLen).fill(0);
    for (const d of data) {
        const factor = d ^ res[0];
        res.shift(); res.push(0);
        for (let i = 0; i < ecLen; i++)
            res[i] ^= gfMul(gen[i+1], factor);
    }
    return res;
}

/* ============================================================
   QR CONSTANTS (tables truncated for sanity)
============================================================ */
const EC_LEVEL = { L:1, M:0, Q:3, H:2 };
const MODE = { NUM:1, ALPHA:2, BYTE:4 };

const CAPACITY = requireCapacity();

/* ============================================================
   DATA ENCODING
============================================================ */
function encodeData(text, version, ecLevel) {
    const bb = new BitBuffer();
    bb.push(MODE.BYTE, 4);
    bb.push(text.length, version < 10 ? 8 : 16);
    for (const b of new TextEncoder().encode(text))
        bb.push(b, 8);

    const cap = CAPACITY[version][ecLevel].data * 8;
    bb.push(0, Math.min(4, cap - bb.length));
    while (bb.length % 8) bb.push(0,1);

    const data = [];
    for (let i = 0; i < bb.bits.length; i += 8)
        data.push(parseInt(bb.bits.slice(i,i+8).join(""),2));

    const pads = [0xec,0x11];
    let p = 0;
    while (data.length < CAPACITY[version][ecLevel].data)
        data.push(pads[p++%2]);

    return data;
}

/* ============================================================
   MATRIX BUILDING
============================================================ */
function buildMatrix(version) {
    const size = version * 4 + 17;
    const m = Array.from({length:size},()=>Array(size).fill(null));

    function finder(x,y){
        for(let dy=-1;dy<=7;dy++)
            for(let dx=-1;dx<=7;dx++){
                const xx=x+dx, yy=y+dy;
                if(xx<0||yy<0||xx>=size||yy>=size) continue;
                const v =
                    dx>=0&&dx<=6&&dy>=0&&dy<=6 &&
                    (dx===0||dx===6||dy===0||dy===6||(dx>=2&&dx<=4&&dy>=2&&dy<=4));
                m[yy][xx]=v?1:0;
            }
    }
    finder(0,0); finder(size-7,0); finder(0,size-7);

    for(let i=8;i<size-8;i++){
        m[6][i]=i%2?0:1;
        m[i][6]=i%2?0:1;
    }

    m[size-8][8]=1; // dark module
    return m;
}

/* ============================================================
   MASKING + PENALTY
============================================================ */
function maskFn(mask,x,y){
    switch(mask){
        case 0: return (x+y)%2===0;
        case 1: return y%2===0;
        case 2: return x%3===0;
        case 3: return (x+y)%3===0;
        case 4: return ((y>>1)+(x/3|0))%2===0;
        case 5: return (x*y)%2+(x*y)%3===0;
        case 6: return ((x*y)%2+(x*y)%3)%2===0;
        case 7: return ((x+y)%2+(x*y)%3)%2===0;
    }
}

function scoreMatrix(m){
    let score=0;
    const n=m.length;
    // Adjacent
    for(let y=0;y<n;y++)
        for(let x=0;x<n-1;x++)
            if(m[y][x]===m[y][x+1]) score++;
    for(let x=0;x<n;x++)
        for(let y=0;y<n-1;y++)
            if(m[y][x]===m[y+1][x]) score++;

    // Balance
    let dark=0;
    for(let y=0;y<n;y++)
        for(let x=0;x<n;x++) if(m[y][x]) dark++;
    score+=Math.abs(dark*20/(n*n)-10)*10;
    return score;
}

/* ============================================================
   RENDER
============================================================ */
function render(text){
    let version=1, ec="L";
    while(version<=40){
        try { encodeData(text,version,ec); break; }
        catch { version++; }
    }
    const data = encodeData(text,version,ec);
    const ecw = rsEncode(data, CAPACITY[version][ec].ec);
    const bits=[...data,...ecw].flatMap(b=>b.toString(2).padStart(8,"0")).map(Number);

    let best=null, bestScore=1e9;
    for(let mask=0;mask<8;mask++){
        const m=buildMatrix(version);
        placeBits(m,bits,mask);
        const s=scoreMatrix(m);
        if(s<bestScore){bestScore=s; best=m;}
    }
    draw(best);
}

function placeBits(m,bits,mask){
    let dir=-1, x=m.length-1, i=0;
    while(x>0){
        if(x===6) x--;
        for(let y=dir===-1?m.length-1:0;dir===-1?y>=0:y<m.length;y+=dir){
            for(let dx=0;dx<2;dx++){
                const xx=x-dx;
                if(m[y][xx]!==null) continue;
                let b=bits[i++]||0;
                if(maskFn(mask,xx,y)) b^=1;
                m[y][xx]=b;
            }
        }
        x-=2; dir*=-1;
    }
}

function draw(m){
    const c=document.getElementById("qr");
    const ctx=c.getContext("2d");
    const qz=4;
    const s=c.width/(m.length+qz*2);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle="#000";
    for(let y=0;y<m.length;y++)
        for(let x=0;x<m.length;x++)
            if(m[y][x])
                ctx.fillRect((x+qz)*s,(y+qz)*s,s,s);
}

/* ============================================================
   CAPACITY TABLE (generated)
============================================================ */
function requireCapacity(){
    const t={};
    for(let v=1;v<=40;v++){
        t[v]={L:{data:19+(v-1)*4,ec:7},M:{data:16,ec:10},Q:{data:13,ec:13},H:{data:9,ec:17}};
    }
    return t;
}

/* ============================================================
   UI
============================================================ */
document.getElementById("text").oninput=e=>{
    try{render(e.target.value);}catch{}
};
render(document.getElementById("text").value);
</script>

</body>
</html>
