<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline QR Tool (Full Math)</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background: #f0f2f5; color: #333; }
        .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h2 { margin-top: 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        
        /* Generator UI */
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
        input { flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 6px; }
        button { padding: 12px 20px; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        button:hover { background: #1d4ed8; }
        button.stop { background: #dc2626; }
        button.stop:hover { background: #b91c1c; }
        
        #canvas-container { text-align: center; margin-top: 20px; min-height: 200px; display: flex; align-items: center; justify-content: center; background: #fafafa; border: 1px dashed #ccc; border-radius: 8px; }
        canvas { max-width: 100%; height: auto; }

        /* Reader UI */
        #video-wrapper { position: relative; background: #000; border-radius: 8px; overflow: hidden; display: none; margin-top: 15px;}
        video { width: 100%; height: 300px; object-fit: cover; display: block; }
        #scan-result { margin-top: 15px; padding: 10px; background: #e0f2fe; border-left: 4px solid #2563eb; font-family: monospace; word-break: break-all; display: none; }
        .error { color: #dc2626; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>

    <!-- GENERATOR -->
    <div class="card">
        <h2>QR Generator (Client-Side)</h2>
        <div class="input-group">
            <input type="text" id="qr-text" placeholder="Enter text to encode..." value="Hello World">
            <button onclick="generate()">Generate</button>
        </div>
        <div id="canvas-container">
            <span style="color:#999">QR Code will appear here</span>
        </div>
    </div>

    <!-- READER -->
    <div class="card">
        <h2>QR Reader (Camera)</h2>
        <div style="margin-bottom: 10px;">
            <button id="btn-start" onclick="startCamera()">Start Camera</button>
            <button id="btn-stop" class="stop" onclick="stopCamera()" style="display:none">Stop Camera</button>
        </div>
        <div id="error-msg" class="error"></div>
        
        <div id="video-wrapper">
            <video id="qr-video" playsinline muted></video>
        </div>
        <div id="scan-result"></div>
    </div>

    <script>
        /**
         * ==========================================
         * PART 1: THE MATH (QR ENCODER ENGINE)
         * Implements Reed-Solomon & Matrix Logic
         * Based on standard ISO 18004 algorithms
         * ==========================================
         */
        
        const QREngine = (function() {
            // Galois Field 256 Math for Reed-Solomon
            const EXP_TABLE = new Uint8Array(256);
            const LOG_TABLE = new Uint8Array(256);
            
            // Initialize Log/Exp tables
            (function initTables() {
                let x = 1;
                for (let i = 0; i < 255; i++) {
                    EXP_TABLE[i] = x;
                    LOG_TABLE[x] = i;
                    x <<= 1;
                    if (x & 0x100) x ^= 0x11D; // Primitive polynomial
                }
            })();

            function glog(n) { return LOG_TABLE[n]; }
            function gexp(n) { return EXP_TABLE[n % 255]; }

            // Polynomial Math
            class Polynomial {
                constructor(num, shift = 0) {
                    let offset = 0;
                    while (offset < num.length && num[offset] === 0) offset++;
                    this.num = new Uint8Array(num.length - offset + shift);
                    for (let i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
                }
                
                get(index) { return this.num[index]; }
                getLength() { return this.num.length; }
                
                multiply(e) {
                    const num = new Uint8Array(this.getLength() + e.getLength() - 1);
                    for (let i = 0; i < this.getLength(); i++) {
                        for (let j = 0; j < e.getLength(); j++) {
                            num[i + j] ^= gexp(glog(this.get(i)) + glog(e.get(j)));
                        }
                    }
                    return new Polynomial(num);
                }
                
                mod(e) {
                    if (this.getLength() - e.getLength() < 0) return this;
                    const ratio = glog(this.get(0)) - glog(e.get(0));
                    const num = new Uint8Array(this.getLength());
                    for(let i=0; i<this.getLength(); i++) num[i] = this.get(i);
                    
                    for (let i = 0; i < e.getLength(); i++) {
                        num[i] ^= gexp(glog(e.get(i)) + ratio);
                    }
                    return new Polynomial(num).mod(e);
                }
            }

            // QR Code Class
            return class QRCode {
                constructor(typeNumber, errorCorrectLevel) {
                    this.typeNumber = typeNumber;
                    this.errorCorrectLevel = errorCorrectLevel;
                    this.modules = null;
                    this.moduleCount = 0;
                    this.dataCache = null;
                    this.dataList = [];
                }

                addData(data) {
                    const newData = new Uint8Array(new TextEncoder().encode(data));
                    this.dataList.push(newData);
                    this.dataCache = null;
                }

                make() {
                    this.makeImpl(false, this.getBestMaskPattern());
                }

                makeImpl(test, maskPattern) {
                    this.moduleCount = this.typeNumber * 4 + 17;
                    this.modules = Array(this.moduleCount).fill(null).map(() => Array(this.moduleCount).fill(null));
                    
                    this.setupPositionProbePattern(0, 0);
                    this.setupPositionProbePattern(this.moduleCount - 7, 0);
                    this.setupPositionProbePattern(0, this.moduleCount - 7);
                    this.setupPositionAdjustPattern();
                    this.setupTimingPattern();
                    this.setupTypeInfo(test, maskPattern);
                    if (this.typeNumber >= 7) this.setupTypeNumber(test);
                    if (this.dataCache == null) this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
                    this.mapData(this.dataCache, maskPattern);
                }

                setupPositionProbePattern(row, col) {
                    for (let r = -1; r <= 7; r++) {
                        for (let c = -1; c <= 7; c++) {
                            if (row + r <= -1 || this.moduleCount <= row + r || col + c <= -1 || this.moduleCount <= col + c) continue;
                            if ((0 <= r && r <= 6 && (c == 0 || c == 6)) || (0 <= c && c <= 6 && (r == 0 || r == 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                                this.modules[row + r][col + c] = true;
                            } else {
                                this.modules[row + r][col + c] = false;
                            }
                        }
                    }
                }

                getBestMaskPattern() {
                    let minPenalty = 0;
                    let bestPattern = 0;
                    for (let i = 0; i < 8; i++) {
                        this.makeImpl(true, i);
                        const penalty = this.getPenalty(); // Simplified: assuming 0 for brevity in this minimal version, or implement full penalty calc
                        if (i == 0 || penalty < minPenalty) {
                            minPenalty = penalty;
                            bestPattern = i;
                        }
                    }
                    return bestPattern;
                }
                
                // Placeholder for full penalty calculation to save space
                getPenalty() { return 0; } 

                setupTimingPattern() {
                    for (let r = 8; r < this.moduleCount - 8; r++) {
                        if (this.modules[r][6] != null) continue;
                        this.modules[r][6] = (r % 2 == 0);
                    }
                    for (let c = 8; c < this.moduleCount - 8; c++) {
                        if (this.modules[6][c] != null) continue;
                        this.modules[6][c] = (c % 2 == 0);
                    }
                }

                setupPositionAdjustPattern() {
                    // Simplified: Only for Version 1-10 (sufficient for minimal tool)
                    // Full list would be huge. 
                    const pos = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50]];
                    if(this.typeNumber > 10) return; // Limit for minimal code
                    
                    const p = pos[this.typeNumber - 1];
                    for (let i = 0; i < p.length; i++) {
                        for (let j = 0; j < p.length; j++) {
                            const row = p[i], col = p[j];
                            if (this.modules[row][col] != null) continue;
                            for (let r = -2; r <= 2; r++) {
                                for (let c = -2; c <= 2; c++) {
                                    this.modules[row + r][col + c] = (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0));
                                }
                            }
                        }
                    }
                }

                setupTypeInfo(test, maskPattern) {
                    const data = (this.errorCorrectLevel << 3) | maskPattern;
                    const bits = this.getBCHTypeInfo(data);
                    for (let i = 0; i < 15; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        if (i < 6) this.modules[i][8] = mod;
                        else if (i < 8) this.modules[i + 1][8] = mod;
                        else this.modules[this.moduleCount - 15 + i][8] = mod;
                        
                        if (i < 8) this.modules[8][this.moduleCount - i - 1] = mod;
                        else if (i < 9) this.modules[8][15 - i - 1 + 1] = mod;
                        else this.modules[8][15 - i - 1] = mod;
                    }
                    this.modules[this.moduleCount - 8][8] = (!test);
                }

                mapData(data, maskPattern) {
                    let inc = -1, row = this.moduleCount - 1, bitIndex = 7, byteIndex = 0;
                    for (let col = this.moduleCount - 1; col > 0; col -= 2) {
                        if (col == 6) col--;
                        while (true) {
                            for (let c = 0; c < 2; c++) {
                                if (this.modules[row][col - c] == null) {
                                    let dark = false;
                                    if (byteIndex < data.length) dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                                    const mask = this.getMask(maskPattern, row, col - c);
                                    if (mask) dark = !dark;
                                    this.modules[row][col - c] = dark;
                                    bitIndex--;
                                    if (bitIndex == -1) { byteIndex++; bitIndex = 7; }
                                }
                            }
                            row += inc;
                            if (row < 0 || this.moduleCount <= row) { row -= inc; inc = -inc; break; }
                        }
                    }
                }

                createData(typeNumber, errorCorrectLevel, dataList) {
                    const rsBlocks = this.getRSBlocks(typeNumber, errorCorrectLevel);
                    const buffer = [];
                    // 1. Write Data (Byte Mode 8-bit)
                    buffer.push(4); // Mode 8-bit
                    buffer.push(dataList[0].length >>> 4); // Length High
                    buffer.push(dataList[0].length & 0xF); // Length Low (Simplified for ver < 10)
                    for(let b of dataList[0]) for(let i=7; i>=0; i--) buffer.push((b >>> i) & 1);
                    
                    // 2. Padding
                    const totalDataCount = rsBlocks.reduce((a,b) => a + b.dataCount, 0) * 8;
                    if (buffer.length + 4 <= totalDataCount) buffer.push(0,0,0,0);
                    while (buffer.length % 8 != 0) buffer.push(0);
                    while (buffer.length < totalDataCount) {
                        for(let b of [236, 17]) for(let i=7; i>=0; i--) if(buffer.length < totalDataCount) buffer.push((b >>> i) & 1);
                    }

                    // 3. Error Correction Calculation
                    const dataBytes = new Uint8Array(buffer.length / 8);
                    for(let i=0; i<dataBytes.length; i++) {
                         let b = 0; for(let j=0; j<8; j++) b = (b << 1) | buffer[i*8+j];
                         dataBytes[i] = b;
                    }
                    
                    let offset = 0;
                    const finalBytes = [];
                    const ecBytesArr = [];
                    
                    for(let block of rsBlocks) {
                        const dc = block.dataCount;
                        const ec = block.totalCount - dc;
                        const rawPoly = new Polynomial(dataBytes.slice(offset, offset + dc));
                        
                        // Generating Generator Polynomial
                        let genPoly = new Polynomial([1]);
                        for (let i = 0; i < ec; i++) genPoly = genPoly.multiply(new Polynomial([1, gexp(i)]));
                        
                        const ecPoly = rawPoly.mod(genPoly);
                        
                        for(let i=0; i<dc; i++) finalBytes.push(dataBytes[offset+i]);
                        const ecData = ecPoly.num;
                        // Pad EC if needed
                        const ecPadding = ec - ecData.length;
                        for(let i=0; i<ecPadding; i++) ecBytesArr.push(0);
                        for(let i=0; i<ecData.length; i++) ecBytesArr.push(ecData[i]);
                        
                        offset += dc;
                    }
                    return new Uint8Array([...finalBytes, ...ecBytesArr]);
                }

                getBCHTypeInfo(data) {
                    let d = data << 10;
                    while (this.getBCHDigit(d) - this.getBCHDigit(1335) >= 0) {
                        d ^= (1335 << (this.getBCHDigit(d) - this.getBCHDigit(1335)));
                    }
                    return ((data << 10) | d) ^ 21522;
                }

                getBCHDigit(data) {
                    let digit = 0; while (data != 0) { digit++; data >>>= 1; } return digit;
                }

                getMask(maskPattern, i, j) {
                    switch (maskPattern) {
                        case 0: return (i + j) % 2 == 0;
                        case 1: return i % 2 == 0;
                        case 2: return j % 3 == 0;
                        case 3: return (i + j) % 3 == 0;
                        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
                        case 5: return ((i * j) % 2 + (i * j) % 3) == 0;
                        case 6: return (((i * j) % 2 + (i * j) % 3) % 2) == 0;
                        case 7: return (((i + j) % 2 + (i * j) % 3) % 2) == 0;
                        default: return false;
                    }
                }

                getRSBlocks(typeNumber, errorCorrectLevel) {
                    // Simplified Table for Versions 1-4 (Low/Medium)
                    // Extending this requires the full ISO table (~2kb). 
                    // This covers typical text lengths up to ~100 chars.
                    const rs = [
                        [1, 26, 19], [1, 44, 34], [1, 70, 55], [1, 100, 80], // L
                        [1, 26, 16], [1, 44, 28], [1, 70, 44], [2, 100, 64]  // M
                    ];
                    // Mapping simplified: Index = (Version-1) + (Level=='M'?4:0)
                    const idx = (typeNumber - 1) + (errorCorrectLevel == 0 ? 4 : 0); // 0=M, 1=L
                    const b = rs[idx];
                    return [{ totalCount: b[1], dataCount: b[2] }];
                }
            };
        })();

        /**
         * ==========================================
         * PART 2: UI CONTROLLER
         * ==========================================
         */

        // --- GENERATOR LOGIC ---
        function generate() {
            const text = document.getElementById('qr-text').value;
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';

            try {
                // 1. Determine Version (1-4) based on length (Simplified logic)
                // A robust system calculates exact bits. Here we estimate.
                let typeNumber = 4;
                if(text.length < 15) typeNumber = 1;
                else if(text.length < 30) typeNumber = 2;
                else if(text.length < 50) typeNumber = 3;

                // 2. Initialize Engine (Level M = 0)
                const qr = new QREngine(typeNumber, 0); 
                qr.addData(text);
                qr.make();

                // 3. Render to Canvas
                const cellSize = 5;
                const margin = 4;
                const size = qr.moduleCount * cellSize + (margin * 2 * cellSize);
                
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Fill white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, size, size);

                // Draw modules
                ctx.fillStyle = '#000000';
                for (let r = 0; r < qr.moduleCount; r++) {
                    for (let c = 0; c < qr.moduleCount; c++) {
                        if (qr.modules[r][c]) {
                            ctx.fillRect(
                                (c + margin) * cellSize,
                                (r + margin) * cellSize,
                                cellSize, cellSize
                            );
                        }
                    }
                }
                container.appendChild(canvas);

            } catch (e) {
                container.textContent = "Error: Text too long for this minimal version (Max ~80 chars).";
                console.error(e);
            }
        }

        // --- READER LOGIC ---
        let stream = null;
        let detector = null;
        let interval = null;
        const video = document.getElementById('qr-video');
        const resultDiv = document.getElementById('scan-result');
        const errorMsg = document.getElementById('error-msg');

        async function startCamera() {
            // Check for Native Barcode API
            if (!('BarcodeDetector' in window)) {
                errorMsg.textContent = "Error: Your browser does not support the native 'BarcodeDetector' API. Please use Chrome, Edge, or Android.";
                return;
            }

            try {
                detector = new BarcodeDetector({ formats: ['qr_code'] });
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment" }
                });
                video.srcObject = stream;
                await video.play();

                document.getElementById('video-wrapper').style.display = 'block';
                document.getElementById('btn-start').style.display = 'none';
                document.getElementById('btn-stop').style.display = 'inline-block';
                resultDiv.style.display = 'none';
                errorMsg.textContent = '';

                interval = setInterval(scan, 100);
            } catch (err) {
                errorMsg.textContent = "Camera Error: " + err.message;
            }
        }

        async function scan() {
            if (!video.videoWidth) return;
            try {
                const codes = await detector.detect(video);
                if (codes.length > 0) {
                    const val = codes[0].rawValue;
                    resultDiv.textContent = "Scanned: " + val;
                    resultDiv.style.display = 'block';
                    // Optional: Stop on detect
                    // stopCamera(); 
                }
            } catch (err) {
                // Ignore empty frames
            }
        }

        function stopCamera() {
            if (stream) stream.getTracks().forEach(t => t.stop());
            clearInterval(interval);
            document.getElementById('video-wrapper').style.display = 'none';
            document.getElementById('btn-start').style.display = 'inline-block';
            document.getElementById('btn-stop').style.display = 'none';
        }
        
        // Init default QR
        generate();
    </script>
</body>
</html>
