<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pure JS QR Code Generator (No Libraries)</title>
<style>
    body {
        font-family: system-ui, sans-serif;
        padding: 20px;
    }
    input {
        width: 400px;
        padding: 8px;
        font-size: 16px;
    }
    canvas {
        margin-top: 20px;
        image-rendering: pixelated;
        border: 1px solid #ccc;
    }
</style>
</head>
<body>

<h2>QR Code Generator (Pure JS)</h2>
<input id="text" value="https://example.com">
<br>
<canvas id="qr" width="210" height="210"></canvas>

<script>
/* ==============================
   GALOIS FIELD (GF(256))
============================== */
const GF_EXP = new Uint8Array(512);
const GF_LOG = new Uint8Array(256);

(function initGF() {
    let x = 1;
    for (let i = 0; i < 255; i++) {
        GF_EXP[i] = x;
        GF_LOG[x] = i;
        x <<= 1;
        if (x & 0x100) x ^= 0x11d;
    }
    for (let i = 255; i < 512; i++) {
        GF_EXP[i] = GF_EXP[i - 255];
    }
})();

function gfMul(a, b) {
    if (a === 0 || b === 0) return 0;
    return GF_EXP[GF_LOG[a] + GF_LOG[b]];
}

/* ==============================
   REED-SOLOMON
============================== */
function rsGeneratorPoly(degree) {
    let poly = [1];
    for (let i = 0; i < degree; i++) {
        poly = rsPolyMul(poly, [1, GF_EXP[i]]);
    }
    return poly;
}

function rsPolyMul(p1, p2) {
    const res = new Array(p1.length + p2.length - 1).fill(0);
    for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
            res[i + j] ^= gfMul(p1[i], p2[j]);
        }
    }
    return res;
}

function rsEncode(data, ecLength) {
    const gen = rsGeneratorPoly(ecLength);
    const res = new Array(ecLength).fill(0);

    for (let byte of data) {
        const factor = byte ^ res[0];
        res.shift();
        res.push(0);
        for (let i = 0; i < gen.length - 1; i++) {
            res[i] ^= gfMul(gen[i + 1], factor);
        }
    }
    return res;
}

/* ==============================
   QR CORE (Version 1, EC-L)
============================== */
const SIZE = 21;
const EC_CODEWORDS = 7;

function drawQR(text) {
    const canvas = document.getElementById("qr");
    const ctx = canvas.getContext("2d");
    const scale = canvas.width / SIZE;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = encodeData(text);
    const ec = rsEncode(data, EC_CODEWORDS);
    const bits = [...data, ...ec].flatMap(b =>
        b.toString(2).padStart(8, "0").split("").map(Number)
    );

    const matrix = makeMatrix();
    placeData(matrix, bits);
    drawMatrix(ctx, matrix, scale);
}

function encodeData(text) {
    const bytes = [...new TextEncoder().encode(text)];
    const bits = [];

    bits.push(0,1,0,0); // byte mode
    bits.push(...bytes.length.toString(2).padStart(8, "0").split("").map(Number));
    for (let b of bytes) {
        bits.push(...b.toString(2).padStart(8, "0").split("").map(Number));
    }
    bits.push(0,0,0,0);

    while (bits.length % 8) bits.push(0);

    const codewords = [];
    for (let i = 0; i < bits.length; i += 8) {
        codewords.push(parseInt(bits.slice(i, i+8).join(""), 2));
    }

    const pads = [0xec, 0x11];
    let padIndex = 0;
    while (codewords.length < 19) {
        codewords.push(pads[padIndex++ % 2]);
    }

    return codewords;
}

function makeMatrix() {
    const m = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    drawFinder(m, 0, 0);
    drawFinder(m, SIZE-7, 0);
    drawFinder(m, 0, SIZE-7);
    drawTiming(m);
    return m;
}

function drawFinder(m, x, y) {
    for (let dy = 0; dy < 7; dy++) {
        for (let dx = 0; dx < 7; dx++) {
            const v = dx === 0 || dx === 6 || dy === 0 || dy === 6 ||
                      (dx >= 2 && dx <= 4 && dy >= 2 && dy <= 4);
            m[y + dy][x + dx] = v ? 1 : 0;
        }
    }
}

function drawTiming(m) {
    for (let i = 8; i < SIZE - 8; i++) {
        const v = i % 2 === 0;
        if (m[6][i] === null) m[6][i] = v ? 1 : 0;
        if (m[i][6] === null) m[i][6] = v ? 1 : 0;
    }
}

function placeData(m, bits) {
    let dir = -1;
    let x = SIZE - 1;
    let bitIndex = 0;

    while (x > 0) {
        if (x === 6) x--;
        for (let y = dir === -1 ? SIZE - 1 : 0;
             dir === -1 ? y >= 0 : y < SIZE;
             y += dir) {

            for (let dx = 0; dx < 2; dx++) {
                const xx = x - dx;
                if (m[y][xx] !== null) continue;
                m[y][xx] = bits[bitIndex++] || 0;
            }
        }
        x -= 2;
        dir *= -1;
    }
}

function drawMatrix(ctx, m, scale) {
    ctx.fillStyle = "#000";
    for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
            if (m[y][x]) {
                ctx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }
}

/* ==============================
   LIVE UPDATE
============================== */
document.getElementById("text").addEventListener("input", e => {
    drawQR(e.target.value);
});

drawQR(document.getElementById("text").value);
</script>

</body>
</html>
