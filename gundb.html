<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Ownership Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        :root {
            --bg: #ffffff;
            --text: #1a1a1a;
            --blur: 0px;
        }
        
        body { 
            margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg); color: var(--text); 
            overflow: hidden; height: 100vh; display: flex; flex-direction: column; 
        }

        /* --- LOGIN & HEADER --- */
        #login {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 5000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #login.hidden { display: none; }
        #login input { padding: 15px; border: 2px solid #333; margin-bottom: 10px; border-radius: 8px; text-align: center; }
        #login button { padding: 15px 30px; background: #333; color: #fff; border: none; cursor: pointer; border-radius: 8px; }

        #header {
            height: 50px; background: #f8f9fa; border-bottom: 1px solid #ddd;
            display: flex; justify-content: space-between; align-items: center; padding: 0 20px;
            z-index: 100;
        }
        .status { font-size: 0.8rem; color: #666; display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; }
        .dot.on { background: #00e676; box-shadow: 0 0 5px #00e676; }

        /* --- EDITOR SURFACE --- */
        #container { 
            flex: 1; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; 
            padding-bottom: 50vh; position: relative;
        }

        #display {
            min-height: 100%; outline: none; 
            padding: 40px 80px; /* Space for labels */
        }

        /* --- THE LINE BLOCK --- */
        .line {
            position: relative;
            min-height: 28px;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            outline: none;
            transition: all 0.3s ease;
            /* Dynamic Blur Logic */
            filter: blur(var(--blur));
            opacity: 1;
        }

        /* 1. MY LINES */
        .line[contenteditable="true"] {
            cursor: text;
        }

        /* 2. PEER LINES */
        .line[contenteditable="false"] {
            cursor: pointer;
            border: 1px solid transparent;
        }
        .line[contenteditable="false"]:hover {
            background-color: #f5f5f5;
            border-color: #ddd;
        }

        /* 3. HEX LABELS */
        .line::before {
            content: attr(data-hex);
            position: absolute;
            left: -70px; top: 6px;
            font-family: monospace; font-size: 0.7rem;
            color: white;
            background-color: var(--owner-color);
            padding: 2px 5px; border-radius: 4px;
            opacity: 0.5; pointer-events: none;
        }
        .line:hover::before { opacity: 1; }

        /* 4. NOTIFICATION HIGHLIGHT (When someone replies to you) */
        .line.ping-highlight {
            background-color: var(--pinger-color) !important;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            filter: blur(0px) !important; /* Always visible */
            z-index: 20;
        }

        /* --- FOCUS MODE (BLUR OTHERS) --- */
        /* When body has .focus-mode, all lines blur EXCEPT the active one */
        body.focus-mode { --blur: 3px; }
        
        body.focus-mode .line.active-thread,
        body.focus-mode .line.ping-highlight {
            --blur: 0px;
            opacity: 1;
            transform: scale(1.01);
            z-index: 10;
            background: white;
            box-shadow: 0 0 0 100vw rgba(255,255,255,0.7); /* Hacks a backdrop */
        }

        /* --- ANIMATION --- */
        @keyframes slideOpen {
            from { opacity: 0; transform: translateY(-10px); max-height: 0; margin: 0; }
            to { opacity: 1; transform: translateY(0); max-height: 500px; margin-bottom: 6px; }
        }
        .slide-in {
            animation: slideOpen 0.3s ease forwards;
        }

    </style>
</head>
<body>

    <!-- LOGIN -->
    <div id="login">
        <h2>P2P Owner Editor</h2>
        <input type="text" id="room-input" placeholder="Room Name" required>
        <button id="btn-enter">Enter</button>
    </div>

    <!-- UI -->
    <div id="header">
        <strong>P2P Layers</strong>
        <div class="status">
            <span class="dot"></span>
            <span id="peer-count">Connecting...</span>
        </div>
    </div>

    <div id="container">
        <!-- Not contenteditable! The children are. -->
        <div id="display"></div>
    </div>

    <script type="module">
        import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

        // --- STATE ---
        const ui = {
            login: document.getElementById('login'),
            input: document.getElementById('room-input'),
            display: document.getElementById('display'),
            container: document.getElementById('container'),
            peerCount: document.getElementById('peer-count'),
            dot: document.querySelector('.dot')
        };

        const myColor = stringToColor(selfId);
        let roomId = null;
        let roomDB, room;
        const act = {}; 

        // --- 1. BOOTSTRAP ---
        function checkHash() {
            const hash = window.location.hash.replace('#', '');
            if(hash) {
                roomId = 'doc-owner-v2-' + hash;
                ui.login.classList.add('hidden');
                initNetwork();
            } else {
                ui.login.classList.remove('hidden');
            }
        }
        document.getElementById('btn-enter').onclick = () => {
            const val = ui.input.value.trim();
            if(val) { window.location.hash = val; checkHash(); }
        };
        window.addEventListener('load', checkHash);

        // --- 2. NETWORK ---
        function initNetwork() {
            // Gun
            const gun = Gun({ peers: [], localStorage: true });
            roomDB = gun.get(roomId);

            // Trystero (Stable Trackers)
            const config = { 
                appId: 'doc-owner-v2',
                trackerUrls: [
                    'wss://tracker.webtorrent.dev', 
                    'wss://tracker.openwebrtc.io',
                    'wss://tracker.files.fm:7073/announce'
                ]
            };
            room = joinRoom(config, roomId);

            // Actions
            const [sendContent, getContent] = room.makeAction('content');
            const [sendPing, getPing] = room.makeAction('ping');
            const [pushSync, getPushSync] = room.makeAction('sync');

            act.sendContent = sendContent;
            act.sendPing = sendPing;
            act.pushSync = pushSync;

            // Handlers
            getContent(handleRemoteContent);
            getPing(handlePing);
            getPushSync((html) => {
                ui.display.innerHTML = html;
                roomDB.get('content').put(html);
                enforceOwnership();
            });

            room.onPeerJoin(id => {
                updateStatus();
                if(ui.display.innerHTML.length > 50) act.pushSync(ui.display.innerHTML, id);
            });
            room.onPeerLeave(updateStatus);

            // Local Load
            roomDB.get('content').once((data) => {
                if(data && data.includes('class="line"')) {
                    ui.display.innerHTML = data;
                } else {
                    // Create 10 empty lines owned by NO ONE (so anyone can claim? or me?)
                    // Let's create 10 lines owned by Me for start
                    let html = '';
                    for(let i=0; i<10; i++) html += createLineHTML('', selfId);
                    ui.display.innerHTML = html;
                }
                enforceOwnership();
            });
        }

        // --- 3. DOM & OWNERSHIP ---

        function createLineHTML(text = '', owner) {
            const id = 'line-' + Math.random().toString(36).substr(2, 9);
            const color = stringToColor(owner);
            // NOTE: We set contenteditable in HTML string, but enforceOwnership() fixes it on load/sync
            return `<div id="${id}" class="line" 
                        data-owner="${owner}" 
                        data-hex="${color}"
                        style="--owner-color: ${color}">${text || '<br>'}</div>`;
        }

        // Scans DOM and locks/unlocks based on SelfID
        function enforceOwnership() {
            const lines = Array.from(ui.display.children);
            lines.forEach(line => {
                const owner = line.getAttribute('data-owner');
                if (owner === selfId) {
                    line.setAttribute('contenteditable', 'true');
                } else {
                    line.setAttribute('contenteditable', 'false');
                }
            });
        }

        // --- 4. INTERACTION LOGIC (The Core) ---

        // CLICK HANDLING
        ui.display.addEventListener('click', (e) => {
            const line = e.target.closest('.line');
            if(!line) return;

            const isMine = line.getAttribute('data-owner') === selfId;

            // SCENARIO A: Clicking MY line (Check for Highlight)
            if (isMine) {
                if(line.classList.contains('ping-highlight')) {
                    // Clear notification
                    line.classList.remove('ping-highlight');
                    line.style.setProperty('--pinger-color', '');
                    saveAndSend();
                    
                    // Slide down to the reply
                    const next = line.nextElementSibling;
                    if(next) {
                        next.scrollIntoView({behavior:'smooth', block:'center'});
                        focusLine(next);
                    }
                }
                activateFocusMode(line);
                return;
            }

            // SCENARIO B: Clicking PEER line (The Reply)
            if (!isMine) {
                e.preventDefault(); // Don't focus the read-only line
                
                // 1. Create Reply Line
                const newLineHTML = createLineHTML('', selfId);
                line.insertAdjacentHTML('afterend', newLineHTML);
                
                const newLine = line.nextElementSibling;
                newLine.classList.add('slide-in');
                
                // 2. Focus and Blur others
                activateFocusMode(newLine); // Focus me, blur rest
                newLine.focus();

                // 3. Notify Owner
                const owner = line.getAttribute('data-owner');
                act.sendPing({ targetId: line.id, pingerColor: myColor }, owner);

                saveAndSend();
            }
        });

        // FOCUS MODE (Blur Effect)
        function activateFocusMode(activeElement) {
            // Clear old active classes
            document.querySelectorAll('.active-thread').forEach(el => el.classList.remove('active-thread'));
            
            // Activate
            document.body.classList.add('focus-mode');
            activeElement.classList.add('active-thread');
        }

        // Deactivate Focus Mode when clicking outside lines
        ui.container.addEventListener('click', (e) => {
            if(!e.target.closest('.line')) {
                document.body.classList.remove('focus-mode');
                document.querySelectorAll('.active-thread').forEach(el => el.classList.remove('active-thread'));
            }
        });

        // --- 5. INPUT & KEYS ---

        // Custom Enter Key (Create new line owned by ME)
        ui.display.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                e.preventDefault();
                const newLineHTML = createLineHTML('', selfId);
                
                // Insert after current
                const sel = window.getSelection();
                const currentLine = sel.anchorNode.nodeType===3 ? sel.anchorNode.parentNode.closest('.line') : sel.anchorNode.closest('.line');
                
                if(currentLine) {
                    currentLine.insertAdjacentHTML('afterend', newLineHTML);
                    const next = currentLine.nextElementSibling;
                    focusLine(next);
                } else {
                    // Fallback
                    document.execCommand('insertHTML', false, newLineHTML);
                }
                
                enforceOwnership();
                saveAndSend();
            }
        });

        ui.display.addEventListener('input', () => {
            saveAndSend();
        });

        function saveAndSend() {
            const html = ui.display.innerHTML;
            roomDB.get('content').put(html);
            if(act.sendContent) act.sendContent(html);
        }

        function handleRemoteContent(html) {
            // Save state
            const wasFocus = document.hasFocus();
            let savedSel = null;
            if(wasFocus) savedSel = saveSelection();

            roomDB.get('content').put(html);
            ui.display.innerHTML = html;
            
            enforceOwnership(); // Critical: re-lock lines
            
            if(wasFocus && savedSel) restoreSelection(savedSel);
        }

        // --- 6. PING HANDLER ---
        function handlePing(data) {
            // { targetId, pingerColor }
            const el = document.getElementById(data.targetId);
            if(el && el.getAttribute('data-owner') === selfId) {
                // Highlight my line
                el.classList.add('ping-highlight');
                el.style.setProperty('--pinger-color', data.pingerColor);
                
                // Also trigger focus mode locally so I see it clearly?
                // Optional: For now just highlight
            }
        }

        // --- HELPERS ---
        function updateStatus() {
            const count = Object.keys(room.getPeers()).length;
            ui.peerCount.innerText = count > 0 ? `${count} Peer(s)` : 'Offline';
            ui.dot.classList.toggle('on', count > 0);
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return '#' + '00000'.substring(0, 6 - c.length) + c;
        }

        function focusLine(el) {
            const range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            el.focus();
            activateFocusMode(el);
        }

        function saveSelection() {
            const sel = window.getSelection();
            if(!sel.rangeCount) return null;
            const range = sel.getRangeAt(0);
            const line = (range.startContainer.nodeType===3 ? range.startContainer.parentNode : range.startContainer).closest('.line');
            if(!line) return null;
            return { lineId: line.id, offset: range.startOffset };
        }

        function restoreSelection(saved) {
            if(!saved) return;
            const line = document.getElementById(saved.lineId);
            if(line) {
                const range = document.createRange();
                // Safe restore logic
                if(line.childNodes.length > 0) {
                     try { range.setStart(line.childNodes[0], Math.min(saved.offset, line.innerText.length)); }
                     catch(e) { range.selectNodeContents(line); }
                } else {
                    range.selectNodeContents(line);
                }
                range.collapse(true);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        // Infinite Scroll (Append empty lines for Me if at bottom)
        ui.container.addEventListener('scroll', () => {
             if(ui.container.scrollHeight - ui.container.scrollTop - ui.container.clientHeight < 100) {
                 let html = '';
                 for(let i=0;i<3;i++) html += createLineHTML('', selfId);
                 ui.display.insertAdjacentHTML('beforeend', html);
                 enforceOwnership();
             }
        });

    </script>
</body>
</html>
