<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Layered Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        :root {
            --bg: #ffffff;
            --text: #1a1a1a;
            --line-height: 28px;
            --blur-strength: 4px;
        }
        
        body { 
            margin: 0; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: var(--bg); color: var(--text); 
            overflow: hidden; height: 100vh; display: flex; flex-direction: column; 
        }

        /* --- LOGIN --- */
        #login {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 3000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #login.hidden { display: none; }
        #login input { padding: 15px; font-size: 1.2rem; border: 2px solid #333; margin-bottom: 15px; text-align: center; border-radius: 8px; }
        #login button { padding: 15px 30px; background: #333; color: white; border: none; cursor: pointer; font-size: 1rem; border-radius: 8px; font-weight: bold; }

        /* --- UI STRUCTURE --- */
        #header {
            height: 50px; background: #f8f9fa; border-bottom: 1px solid #ddd;
            display: flex; justify-content: space-between; align-items: center; padding: 0 20px;
            z-index: 100;
        }
        .status { font-size: 0.8rem; color: #666; display: flex; align-items: center; gap: 8px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; transition: background 0.3s; }
        .dot.on { background: #00e676; box-shadow: 0 0 5px #00e676; }

        #container { 
            flex: 1; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; 
            position: relative; padding-bottom: 50vh;
        }

        #display {
            min-height: 100%; outline: none; 
            padding: 40px 80px; /* Extra left padding for tags */
            font-size: 16px; 
            line-height: var(--line-height);
            transition: filter 0.3s;
        }

        /* --- LINE LOGIC --- */
        
        /* Base Line Style */
        .line {
            position: relative;
            min-height: var(--line-height);
            padding: 2px 5px;
            margin-bottom: 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
            transform-origin: top;
        }

        /* The Hex Label (Floating Left) */
        .line::before {
            content: attr(data-hex);
            position: absolute;
            left: -70px; top: 50%; transform: translateY(-50%);
            font-size: 0.65rem;
            font-family: monospace;
            color: #fff;
            background-color: var(--line-color, #ccc);
            padding: 2px 6px;
            border-radius: 4px;
            opacity: 0.7;
            pointer-events: none;
        }

        /* --- OWNERSHIP STYLES --- */

        /* MY LINES: Editable */
        .line[contenteditable="true"] {
            cursor: text;
        }

        /* PEER LINES: Non-Editable (Protected) */
        .line[contenteditable="false"] {
            cursor: pointer; /* Indicates clickability */
            user-select: none; /* Can't select text easily */
            border: 1px solid transparent;
        }

        /* Hovering over peer line (Light Grey) */
        .line[contenteditable="false"]:hover {
            background-color: #f0f0f0;
            border-color: #e0e0e0;
        }

        /* The "Alert" Highlight (When someone comments on your line) */
        .line.alert-highlight {
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        /* --- FOCUS MODE (BLUR) --- */
        
        /* When we are in a "Thread", body gets this class */
        body.focus-active #display .line {
            filter: blur(var(--blur-strength));
            opacity: 0.4;
            pointer-events: none;
        }

        /* The lines involved in the interaction stay sharp */
        body.focus-active #display .line.focused-thread {
            filter: none;
            opacity: 1;
            pointer-events: auto;
            transform: scale(1.02);
            z-index: 10;
            background: white;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        /* Animation for new line sliding in */
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); max-height: 0; }
            to { opacity: 1; transform: translateY(0); max-height: 100px; }
        }
        .slide-in {
            animation: slideDown 0.3s ease forwards;
        }

    </style>
</head>
<body>

    <div id="login">
        <h2>Layered P2P Editor</h2>
        <input type="text" id="room-input" placeholder="Room Name" required>
        <button id="btn-login">Enter</button>
    </div>

    <div id="header">
        <strong>P2P Layers</strong>
        <div class="status">
            <span class="dot"></span>
            <span id="peer-count">Offline</span>
        </div>
    </div>

    <div id="container">
        <div id="display" contenteditable="true" spellcheck="false"></div>
    </div>

    <script type="module">
        import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

        // --- 1. SETUP ---
        const ui = {
            login: document.getElementById('login'),
            roomInput: document.getElementById('room-input'),
            display: document.getElementById('display'),
            container: document.getElementById('container'),
            peerCount: document.getElementById('peer-count'),
            dot: document.querySelector('.dot')
        };

        const myColor = stringToColor(selfId);
        let roomId = null;
        let roomDB, room;
        const act = {}; 

        // --- 2. BOOTSTRAP ---
        
        function checkHash() {
            const hash = window.location.hash.replace('#', '');
            if(hash) {
                roomId = 'layer-doc-v1-' + hash;
                ui.login.classList.add('hidden');
                initNetwork();
            } else {
                ui.login.classList.remove('hidden');
            }
        }

        document.getElementById('btn-login').onclick = () => {
            const val = ui.roomInput.value.trim();
            if(val) { window.location.hash = val; checkHash(); }
        };
        window.addEventListener('load', checkHash);

        // --- 3. NETWORK ---

        function initNetwork() {
            const gun = Gun({ peers: [], localStorage: true });
            roomDB = gun.get(roomId);

            const config = { 
                appId: 'layer-doc-v1',
                trackerUrls: ['wss://tracker.webtorrent.dev', 'wss://tracker.openwebrtc.io']
            };
            room = joinRoom(config, roomId);

            // Actions
            const [sendContent, getContent] = room.makeAction('content');
            const [sendPing, getPing] = room.makeAction('ping'); // For highlighting lines
            const [reqSync, getReqSync] = room.makeAction('req');
            const [pushSync, getPushSync] = room.makeAction('sync');

            act.sendContent = sendContent;
            act.sendPing = sendPing;
            act.pushSync = pushSync;
            act.reqSync = reqSync;

            // Listeners
            getContent(handleRemoteContent);
            getPing(handlePing); // Handle Highlight Pings
            getReqSync((_, pid) => act.pushSync(ui.display.innerHTML, pid));
            getPushSync((html) => {
                ui.display.innerHTML = html;
                roomDB.get('content').put(html);
                enforceProtection(); // Re-run protection logic on sync
            });

            room.onPeerJoin(id => {
                updateStatus();
                if(ui.display.innerHTML.length > 50) act.pushSync(ui.display.innerHTML, id);
                else act.reqSync(null, id);
            });
            room.onPeerLeave(updateStatus);

            // Local Load
            roomDB.get('content').once((data) => {
                if(data && data.includes('class="line"')) {
                    ui.display.innerHTML = data;
                } else {
                    initFresh();
                }
                enforceProtection();
            });
        }

        // --- 4. DOM LOGIC & PROTECTION ---

        function createLine(text = '', owner = selfId) {
            const id = 'line-' + Math.random().toString(36).substr(2, 9);
            const color = stringToColor(owner);
            // Default to Editable if I created it
            const editable = (owner === selfId) ? "true" : "false";
            
            return `<div id="${id}" class="line" 
                        data-owner="${owner}" 
                        data-hex="${color}" 
                        style="--line-color: ${color}"
                        contenteditable="${editable}">${text || '<br>'}</div>`;
        }

        function initFresh() {
            let html = '';
            for(let i=0; i<10; i++) html += createLine();
            ui.display.innerHTML = html;
        }

        // The Enforcer: Scans DOM and locks lines that aren't mine
        function enforceProtection() {
            const lines = Array.from(ui.display.children);
            lines.forEach(line => {
                if(!line.classList.contains('line')) return; // skip junk

                const owner = line.getAttribute('data-owner');
                
                if (owner === selfId) {
                    // It's mine
                    line.setAttribute('contenteditable', 'true');
                } else {
                    // It's someone else's -> PROTECT IT
                    line.setAttribute('contenteditable', 'false');
                }
            });
        }

        // --- 5. INTERACTION (CLICK & REPLY) ---

        ui.display.addEventListener('click', (e) => {
            // Find clicked line
            const targetLine = e.target.closest('.line');
            if (!targetLine) return;

            // Check if it's protected (someone else's)
            const isProtected = targetLine.getAttribute('contenteditable') === 'false';
            
            // SCENARIO 1: Clicking Someone Else's Line (To Comment)
            if (isProtected) {
                // 1. Enter Focus Mode
                enterFocusMode(targetLine);

                // 2. Create New Line Below
                const newLineHTML = createLine('', selfId);
                targetLine.insertAdjacentHTML('afterend', newLineHTML);
                
                const newLine = targetLine.nextElementSibling;
                newLine.classList.add('slide-in'); // Animation
                newLine.classList.add('focused-thread'); // Keep it sharp in blur mode
                
                // 3. Move Cursor
                placeCaret(newLine);

                // 4. Notify Owner (Highlight their screen)
                const ownerId = targetLine.getAttribute('data-owner');
                act.sendPing({ 
                    targetId: targetLine.id, 
                    actorColor: myColor 
                }, ownerId); // Send specifically to owner? No, Trystero is broadcast usually, logic in handlePing

                saveAndBroadcast();
                return;
            }

            // SCENARIO 2: Clicking My Own Line (That might be highlighted)
            if (targetLine.classList.contains('alert-highlight')) {
                // Remove highlight
                targetLine.classList.remove('alert-highlight');
                targetLine.style.backgroundColor = '';
                
                // If there's a comment below, reveal/focus it
                const next = targetLine.nextElementSibling;
                if(next) {
                    enterFocusMode(targetLine, next);
                    next.scrollIntoView({behavior:'smooth', block:'center'});
                }
                saveAndBroadcast();
            }
        });

        // Focus Mode Logic (Blur Background)
        function enterFocusMode(mainLine, secondaryLine = null) {
            document.body.classList.add('focus-active');
            
            // Clean previous thread focus
            document.querySelectorAll('.focused-thread').forEach(el => el.classList.remove('focused-thread'));

            // Highlight current thread
            mainLine.classList.add('focused-thread');
            if(secondaryLine) secondaryLine.classList.add('focused-thread');

            // Exit focus mode when clicking background
            const exitHandler = (e) => {
                if(!e.target.closest('.focused-thread')) {
                    document.body.classList.remove('focus-active');
                    document.querySelectorAll('.focused-thread').forEach(el => el.classList.remove('focused-thread'));
                    document.removeEventListener('click', exitHandler, true);
                }
            };
            // Delay listener slightly so immediate click doesn't trigger it
            setTimeout(() => document.addEventListener('click', exitHandler, true), 50);
        }

        // --- 6. PING HANDLER (The Notification) ---

        function handlePing(data) {
            // Check if the ping is for a line I have locally
            const el = document.getElementById(data.targetId);
            if(el) {
                // Check if I am the owner of this line
                const myLine = el.getAttribute('data-owner') === selfId;
                
                if(myLine) {
                    // Highlight it with the Actor's color
                    el.classList.add('alert-highlight');
                    el.style.backgroundColor = data.actorColor;
                }
            }
        }

        // --- 7. INPUT & SYNC ---

        ui.display.addEventListener('input', () => {
            saveAndBroadcast();
        });

        // Custom Enter Key (Always creates a DIV with ID)
        ui.display.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                e.preventDefault();
                // Insert new line
                const newLineHTML = createLine('', selfId);
                document.execCommand('insertHTML', false, newLineHTML);
                // Fix structure immediately (execCommand can be messy)
                enforceProtection();
                saveAndBroadcast();
            }
        });

        function saveAndBroadcast() {
            const html = ui.display.innerHTML;
            roomDB.get('content').put(html);
            if(act.sendContent) act.sendContent(html);
        }

        function handleRemoteContent(html) {
            roomDB.get('content').put(html);
            
            // Store current selection/focus
            const hadFocus = document.hasFocus();
            let savedSel = null;
            if(hadFocus) savedSel = saveSelection();

            ui.display.innerHTML = html;
            
            // Re-apply protection (crucial so I can't edit new lines from others)
            enforceProtection();

            if(hadFocus && savedSel) restoreSelection(savedSel);
        }

        // --- HELPERS ---

        function updateStatus() {
            const count = Object.keys(room.getPeers()).length;
            ui.peerCount.innerText = count > 0 ? `${count} Peer(s)` : 'Offline';
            ui.dot.classList.toggle('on', count > 0);
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return '#' + '00000'.substring(0, 6 - c.length) + c;
        }

        function placeCaret(el) {
            const range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(true);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            el.focus();
        }

        function saveSelection() {
            const sel = window.getSelection();
            if(!sel.rangeCount) return null;
            const range = sel.getRangeAt(0);
            const node = range.startContainer.nodeType === 3 ? range.startContainer.parentNode : range.startContainer;
            const line = node.closest('.line');
            if(!line) return null;
            return { lineId: line.id, offset: range.startOffset };
        }

        function restoreSelection(saved) {
            if(!saved) return;
            const line = document.getElementById(saved.lineId);
            if(line) {
                const range = document.createRange();
                // Try to restore offset safely
                try {
                    if(line.childNodes[0]) {
                        range.setStart(line.childNodes[0], Math.min(saved.offset, line.innerText.length));
                    } else {
                        range.selectNodeContents(line);
                    }
                } catch(e) { range.selectNodeContents(line); }
                
                range.collapse(true);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

    </script>
</body>
</html>
